{"meta":{"title":"kysonyangs","subtitle":"Stay Hungry, Stay Foolish","description":"kysonyangs个人站，备忘","author":"kysonyangs","url":"https://kysonyangs.github.io"},"pages":[{"title":"categories","date":"2018-06-19T02:34:25.000Z","updated":"2018-06-19T02:34:35.000Z","comments":false,"path":"categories/index.html","permalink":"https://kysonyangs.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-06-19T02:40:54.000Z","updated":"2018-06-20T02:06:23.137Z","comments":false,"path":"about/index.html","permalink":"https://kysonyangs.github.io/about/index.html","excerpt":"","text":"个人简介： KysonYangs iOSer 来自江西 现居上海 Email: kysonyangs@gmail.com"},{"title":"tags","date":"2018-06-19T02:33:55.000Z","updated":"2018-06-19T02:34:15.000Z","comments":false,"path":"tags/index.html","permalink":"https://kysonyangs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Runtime相关","slug":"runtime相关","date":"2018-06-14T16:00:00.000Z","updated":"2018-09-21T07:59:37.687Z","comments":true,"path":"default/runtime相关/","link":"","permalink":"https://kysonyangs.github.io/default/runtime相关/","excerpt":"RuntimeRuntime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。 KVO 实现原理简单理解 KVO是基于runtime机制实现的 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制 如果原类为Person，那么生成的派生类名为 NSKVONotifying_Person 每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。","text":"RuntimeRuntime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。 KVO 实现原理简单理解 KVO是基于runtime机制实现的 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制 如果原类为Person，那么生成的派生类名为 NSKVONotifying_Person 每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 深入理解 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听； 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。 （isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制. 子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 消息发送原理如下这个方法：1[lisi read:huozhe]; 会被编译成1objc_sgSend(lisi, @selector(read:), huozhe); objc_msgSend的具体流程如下： 通过isa指针找到所属类 查找类的cache列表, 如果没有则下一步 查找类的”方法列表” 如果能找到与选择子名称相符的方法, 就跳至其实现代码 找不到, 就沿着继承体系继续向上查找 如果能找到与选择子名称相符的方法, 就跳至其实现代码 找不到, 执行”消息转发”. 消息转发机制原理消息转发机制基本分为三个步骤： 动态方法解析 备用接受者 完整转发 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod:(实例方法)或者 +resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过 class_addMethod 函数动态添加到类里面就可以了。 1234567891011121314151617181920@interface HiClass: NSObject- (void)hello;@end@implementation HiClassvoid functionForMethod(id self, SEL _cmd) &#123; NSLog(@&quot;hello!&quot;);&#125;// selector : 那个未知的选择子// 返回YES则结束消息转发// 返回NO则进入备用接受者+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSLog(@&quot;resolveInstanceMethod&quot;); NSString *selString = NSStringFromSelector(sel); if ([selString isEqualToString:@&quot;hello&quot;]) &#123; class_addMethod(self, @selector(hello), (IMP)functionForMethod, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end 备用接受者动态方法解析无法处理消息，则会走备用接受者。这个备用接受者只能是一个新的对象，不能是self本身，否则就会出现无限循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。123456789101112131415161718192021222324252627@interface RuntimeMethodHelper: NSObject@end@implementation RuntimeMethodHelper- (void)hello &#123; NSLog(@&quot;%@, %p -&gt; hello&quot;, self, _cmd);&#125;@end@interface HiClass: NSObject&#123; RuntimeMethodHelper *_helper;&#125;- (void)hello;@end@implementation HiClass// selector : 那个未知的消息// 返回一个能响应该未知选择子的备用对象- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSLog(@&quot;forwardingTargetForSelector&quot;); NSString *selectorString = NSStringFromSelector(aSelector); // 将消息交给_helper来处理 if ([selectorString isEqualToString:@&quot;hello&quot;]) &#123; return _helper; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 完整消息转发如果动态方法解析和备用接受者都没有处理这个消息，那么就会走完整消息转发： 123456789101112131415161718192021222324252627282930313233343536@interface RuntimeMethodHelper: NSObject@end@implementation RuntimeMethodHelper- (void)hello &#123; NSLog(@&quot;%@, %p -&gt; hello&quot;, self, _cmd);&#125;@end@interface HiClass: NSObject&#123; RuntimeMethodHelper *_helper;&#125;- (void)hello;@end@implementation HiClass// invocation : 封装了与那条尚未处理的消息相关的所有细节的对象- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; NSLog(@&quot;forwardInvocation&quot;); if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:_helper]; &#125;&#125;// 必须重新这个方法，消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象// NSMethodSignature : 该selector对应的方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSLog(@&quot;methodSignatureForSelector&quot;); NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([RuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123; signature = [RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;@end weak实现原理Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 附加： 实现weak后，为什么对象释放后会自动为nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？ 调用objc_release 因为对象的引用计数为0，所以执行dealloc 在dealloc中，调用了_objc_rootDealloc函数 在_objc_rootDealloc中，调用了object_dispose函数 调用objc_destructInstance 最后调用objc_clear_deallocating,详细过程如下： a. 从weak表中获取废弃对象的地址为键值的记录 b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil c. 将weak表中该记录删除 d. 从引用计数表中删除废弃对象的地址为键值的记录","categories":[],"tags":[]},{"title":"LLDB调试","slug":"LLDB调试","date":"2018-06-09T16:00:00.000Z","updated":"2018-08-30T03:25:51.173Z","comments":true,"path":"default/LLDB调试/","link":"","permalink":"https://kysonyangs.github.io/default/LLDB调试/","excerpt":"LLDBLLDB是XCode内置的为我们开发者提供的调试工具，它与LLVM编译器一起，存在于主窗口底部的控制台中，能够带给我们更丰富的流程控制和数据检测的调试功能。在调试过程中熟练使用LLDB，可以让你debug事半功倍。 LLDB可以带来以下体验： 允许你在程序运行的特定时暂停它 查看变量的值 执行自定的指令 按照你所认为合适的步骤来操作程序的进展 More","text":"LLDBLLDB是XCode内置的为我们开发者提供的调试工具，它与LLVM编译器一起，存在于主窗口底部的控制台中，能够带给我们更丰富的流程控制和数据检测的调试功能。在调试过程中熟练使用LLDB，可以让你debug事半功倍。 LLDB可以带来以下体验： 允许你在程序运行的特定时暂停它 查看变量的值 执行自定的指令 按照你所认为合适的步骤来操作程序的进展 More 常用基本命令expr可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。如图设置断点，然后运行程序。程序中断后输入下面的命令： bt打印调用堆栈，加all可打印所有thread的堆栈 打印打印变量的值可以使用print命令，print命令的简化方式有prin pri p，幸运的是p被lldb实现为特指print。该命令如果打印的是简单类型，则会列出简单类型的类型和值。如果是对象，还会打印出对象指针地址，如下所示：123456789101112(lldb) print a(NSInteger) $0 = 0(lldb) print b(NSInteger) $1 = 0(lldb) print str(NSString *) $2 = 0x0000000100001048 @&quot;abc&quot;(lldb) print url(NSURL *) $3 = 0x0000000100206cc0 @&quot;abc&quot; 在输出结果中我们还能看到类似于$0,$1这样的符号，我们可以将其看作是指向对象的一个引用，我们在控制面板中可以直接使用这个符号来操作对应的对象，这些东西存在于LLDB的全名空间中，目的是为了辅助调试。如下所示：1234(lldb) exp $0 = 100(NSInteger) $9 = 100(lldb) p a(NSInteger) $10 = 100 另外$后面的数值是递增的，每打印一个与对象相关的命令，这个值都会加1。 上面的print命令会打印出对象的很多信息，如果我们只想查看对象的值的信息，则可以使用po(print object的缩写)命令，如下所示：12(lldb) po strabc 当然，po命令是”exp -O —“命令的别名，使用”exp -O —”能达到同样的效果。 对于简单类型，我们还可以为其指定不同的打印格式，其命令格式是print/，如下所示：12(lldb) p/x a(NSInteger) $13 = 0x0000000000000064 格式的完整清单可以参考Output Formats。 expression在开发中，我们经常会遇到这样一种情况：我们设置一个视图的背景颜色，运行后发现颜色不好看。嗯，好吧，在代码里面修改一下，再编译运行一下，嗯，还是不好看，然后再修改吧～～这样无形中浪费了我们大把的时间。在这种情况下，expression命令强大的功能就能体现出来了，它不仅会改变调试器中的值，还改变了程序中的实际值。我们先来看看实际效果，如下所示：12345(lldb) exp a = 10(NSInteger) $0 = 10(lldb) exp b = 100(NSInteger) $1 = 1002015-01-25 14:00:41.313 test[18064:71466] a + b = 110, abc expression命令的功能不仅于此，正如上面的po命令，其实际也是”expression -O —“命令的别名。更详细使用可以参考Evaluating Expressions。","categories":[],"tags":[]},{"title":"Swift-Tips","slug":"Swift-Tips","date":"2018-06-09T16:00:00.000Z","updated":"2018-09-10T08:40:04.243Z","comments":true,"path":"default/Swift-Tips/","link":"","permalink":"https://kysonyangs.github.io/default/Swift-Tips/","excerpt":"cell分割线置顶1tableView.separatorInset = UIEdgeInsets.zero Swift中lazy作惰性求值函数式编程中有惰性求值的概念，即一次计算在真正需要时才执行，尽可能推迟求解表达式。假如我们有一个数组，我们对每个元素作 element*2 的 map 操作，获取其中某一个元素，我们会如下代码处理:123let array = [1, 2, 4, 5, 3, 7]let element = array.map&#123; $0 * 2 &#125;[3]print(element) 这个计算对每个元素都*2，最后我们只取了其中一个值，也就是说在这个场景中另外5次计算是无意义的。 这时使用惰性求值就可以避免这算浪费。我们知道Swift中有个lazy关键字，如果用来修饰属性之类的，可以实现属性的惰性求值。同样，Swift扩展了LazySequenceProtocol协议，提供了一个lazy属性，用于处理map，filter等操作的惰性求值，定义如下代码所示：1234extension LazySequenceProtocol &#123; /// Identical to `self`. public var lazy: Self &#123; get &#125;&#125; 所以，上面这个例子如果要实现惰性求值，则可以如下代码处理：123let array = [1, 2, 4, 5, 3, 7]let element = array.lazy.map&#123; $0 * 2 &#125;[3]print(element)","text":"cell分割线置顶1tableView.separatorInset = UIEdgeInsets.zero Swift中lazy作惰性求值函数式编程中有惰性求值的概念，即一次计算在真正需要时才执行，尽可能推迟求解表达式。假如我们有一个数组，我们对每个元素作 element*2 的 map 操作，获取其中某一个元素，我们会如下代码处理:123let array = [1, 2, 4, 5, 3, 7]let element = array.map&#123; $0 * 2 &#125;[3]print(element) 这个计算对每个元素都*2，最后我们只取了其中一个值，也就是说在这个场景中另外5次计算是无意义的。 这时使用惰性求值就可以避免这算浪费。我们知道Swift中有个lazy关键字，如果用来修饰属性之类的，可以实现属性的惰性求值。同样，Swift扩展了LazySequenceProtocol协议，提供了一个lazy属性，用于处理map，filter等操作的惰性求值，定义如下代码所示：1234extension LazySequenceProtocol &#123; /// Identical to `self`. public var lazy: Self &#123; get &#125;&#125; 所以，上面这个例子如果要实现惰性求值，则可以如下代码处理：123let array = [1, 2, 4, 5, 3, 7]let element = array.lazy.map&#123; $0 * 2 &#125;[3]print(element) Swift的stride操作创建一个一定步长的数组, Swift提供了一个便捷函数：stride，可以在某个区间内创建一个任意可变步长的序列，这个步长可以是任意值。123let array = stride(from: 0, to: 3, by: 0.3).map &#123; $0&#125; stride有两个变种： stride(from:to:by)，开区间处理，最后一个值严格小于最大值； stride(from:through:by)，闭区间处理，最后一个值小于或等于最大值 static方法与class方法的区别static和class这两个关键字都可以修饰类的方法，以表明这个方法是一个类方法。不过这两者稍微有一些区别：class修饰的类方法可以被子类重写，而static修饰的类方法则不能。 Swift中的函数值在Swift中，函数是一等公民，即函数也是一种类型，可充当参数、返回值等角色，当然也可以定义函数类型的常量/变量。利用这个特性，在某些场景下可以简化我们的代码，如下代码所示：12345let setInt: (Int, String) -&gt; Void = UserDefaults.standard.setlet getInt: (String) -&gt; Int = UserDefaults.standard.integersetInt(10, &quot;key&quot;)print(getInt(&quot;key&quot;)) Array.contains操作Swift中判断一个Array中是否包含某个元素，我们可以使用contains方法，如下代码所示：12let array = [2, 5, 6, 7, 19, 40]array.contains(10) // false 不过这个方法要求数组中的元素类型实现了Equatable协议，否则无法使用，如下代码所示：1234567enum Animal &#123; case dog case cat(Int)&#125;let animals: [Animal] = [.dog, .dog]let hasCat = animals.contains(.cat(100)) // 编译器错误 还好Swift为我们提供了另一个contains方法，可以自定义谓词条件作为判断依据，其定义如下：1public func contains(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool 这个方法会查看数组是否包含满足给定的谓词条件的元素。可以看到这个方法是一个高阶函数，其参数是一个尾随闭包，在闭包内我们可以根据实际需要来实现我们自己的判断。所以上面的判断可以如下代码实现：1234567891011121314enum Animal &#123; case dog case cat(Int)&#125;let animals: [Animal] = [.dog, .dog]let hasCat = animals.contains &#123; animal in if case .cat = animal &#123; return true &#125; else &#123; return false &#125;&#125; 当然，对于元素类型实现了Equatable协议的数组，也可以使用这个方法。可以自定义谓词条件，查看数组是否有满足此条件的元素，如下代码所示：12345let array = [2, 5, 6, 7, 19, 40]array.contains &#123; (element) -&gt; Bool in element % 7 == 0&#125; filter与flatMap过滤nil使用高阶函数过滤一个数组中的nil可以有两种方法：filter和flatMap。filter方法如下代码所示：1234567let array: [Int?] = [1, 2, 3, 5, nil, 9]let result = array.filter &#123; element in element != nil&#125;print(result) // [Optional(1), Optional(2), Optional(3), Optional(5), Optional(9)] flatMap方法如下代码所示：123456let array: [Int?] = [1, 2, 3, 5, nil, 9]let result: [Int] = array.flatMap &#123; $0&#125;print(result) // [1, 2, 3, 5, 9] 从输出可以看出，filter返回的仍然是一个Optional数组，而flatMap返回的是一个非Optional数组。一般推荐使用第二种方法。 Extension-Selector在Swift中，我们可以使用#selector设置target-action模式中的action操作，如下代码所示：1button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside) 如果你有代码洁癖，想把#selector集中起来管理，则可以定义一个结构体，来统一归集这样的代码，如下图所示。这样看着是不是会更整洁一些？1234fileprivate struct Action &#123; static let buttonTapped = #selector(ViewController.buttonTapped)&#125;button.addTarget(self, action: Action.buttonTapped, for: .touchUpInside) 不过，还有种更好的方式，就是直接扩展Selector结构体，如下代码所示，这样可以在使用时直接用.buttonTapped这种方式来引用，就像我们使用.red这样的UIColor属性一样简洁。1234extension Selector &#123; static let buttonTapped = #selector(ViewController.buttonTapped)&#125;button.addTarget(self, action: .buttonTapped, for: .touchUpInside) typealias泛型闭包在 Swift 中我们可以用 typealias 来为已经存在的类型重新定义名字的,通过命名可以使代码变得更加清晰。当然也可以给闭包类型定义一个新名字，给带有泛型的闭包重新定义名字的方式如下代码所示：123456789typealias Block&lt;U&gt; = (U, U) -&gt; Boolfunc compare&lt;T: Comparable&gt;(number1: T, number2: T, algorithm: Block&lt;T&gt;) -&gt; Bool &#123; return algorithm(number1, number2)&#125;compare(number1: 10, number2: 20) &#123; $0 &lt; $1&#125; Swift自定义操作符在Swift中，自定义操作符就是简单的二步：首先在全局使用operator关键字来声明操作符，同时用prefix、infix或postfix来声明操作符的位置；然后在所需要的类/结构体中实现操作符。如下代码所示：123456789101112postfix operator &gt;?postfix operator &gt;!extension MIType &#123; public static postfix func &gt;?(type: MIType) -&gt; MIType &#123; return MIType(&quot;Optional&lt;\\(type.name)&gt;&quot;) &#125; public static postfix func &gt;!(type: MIType) -&gt; MIType &#123; return MIType(&quot;ImplicitlyUnwrappedOptional&lt;\\(type.name)&gt;&quot;) &#125;&#125; 自定义操作符需要以两类字符开头： ASCII字符中的 /, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?, ~ Unicode 中的 Mathematical Operators, Miscellaneous Symbols和Dingbats Unicode blocks这些字符中的字符 然后后面允许使用组合的Unicode字符。如下代码是以一个Miscellaneous Symbols开头的实现向量加法的操作符。1234567891011121314151617181920infix operator ★+struct Vector2D &#123; var x: CGFloat var y: CGFloat&#125;extension Vector2D &#123; static func ★+ (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125;let vector1 = Vector2D(x: 10, y: 20)let vector2 = Vector2D(x: 30, y: 10)let vector = vector1 ★+ vector2vector.x // 40.0vector.y // 30.0 自定义操作符中的.在自定义操作符时，可以以dot(.)开头，这种情况下，操作符后面还可以包含其它的dot(.)，如下代码所示：1234567891011121314151617181920infix operator .+.struct Vector2D &#123; var x: CGFloat var y: CGFloat&#125;extension Vector2D &#123; static func .+.(left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125;let vector1 = Vector2D(x: 10, y: 20)let vector2 = Vector2D(x: 30, y: 10)let vector = vector1 .+. vector2vector.xvector.y 但如果操作符不是以dot开头，则后面不能再包含dot，如operator +.+这个声明会被看成是”+”操作符后面跟了个”.+”操作符。编译器会给出如下错误提示：1infix operator +.+ // error: operator with postfix spacing cannot start a subexpression Swift中操作符优先级Swift 3中改进了操作符的优先级及结合性的声明方式。在Swift 3之前，是使用magic numbers(魔数)的方式来声明操作符的优先级，如下代码所示：1234infix operator &lt;~ &#123; associativity left precedence 125&#125; magic numbers总归是一个不好的东西，所以Swift 3改用precedence groups(优先级组)的方式来声明操作符的优先级，如下代码所示：1234567precedencegroup Equivalence &#123; associativity: left higherThan: LogicalConjunctionPrecedence lowerThan: ComparisonPrecedence&#125;infix operator ~ : Equivalence 系统为我们提供了一些默认的precedence groups，如下代码所示：12345678910111213141516171819202122232425262728293031323334353637383940414243precedencegroup AssignmentPrecedence &#123; assignment: true associativity: right&#125;precedencegroup TernaryPrecedence &#123; associativity: right higherThan: AssignmentPrecedence&#125;precedencegroup DefaultPrecedence &#123; higherThan: TernaryPrecedence&#125;precedencegroup LogicalDisjunctionPrecedence &#123; associativity: left higherThan: TernaryPrecedence&#125;precedencegroup LogicalConjunctionPrecedence &#123; associativity: left higherThan: LogicalDisjunctionPrecedence&#125;precedencegroup ComparisonPrecedence &#123; higherThan: LogicalConjunctionPrecedence&#125;precedencegroup NilCoalescingPrecedence &#123; associativity: right higherThan: ComparisonPrecedence&#125;precedencegroup CastingPrecedence &#123; higherThan: NilCoalescingPrecedence&#125;precedencegroup RangeFormationPrecedence &#123; higherThan: CastingPrecedence&#125;precedencegroup AdditionPrecedence &#123; associativity: left higherThan: RangeFormationPrecedence&#125;precedencegroup MultiplicationPrecedence &#123; associativity: left higherThan: AdditionPrecedence&#125;precedencegroup BitwiseShiftPrecedence &#123; higherThan: MultiplicationPrecedence&#125; wift打印对象的地址在Swift中，我们可以使用 withUnsafePointer(to:_:) 函数来获取一个变量的指针，如下代码所示：123456789101112131415var x = 42var y = 3.14var z = &quot;foo&quot;var obj = NSObject()withUnsafePointer(to: &amp;x) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;y) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;z) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;obj) &#123;ptr in print(ptr)&#125;// 输出// 0x000000011a145660// 0x000000011a145668// 0x000000011a145670// 0x000000011a145688 withUnsafePointer(to:_:) 将第一个参数转换为指针，然后将这个指针作为参数去调用第二个参数指定的闭包。如果闭包有返回值，它将作为函数的返回值。需要注意的是，�生成的指针的生命周期限定于闭包内部，不能将其指定给外部的变量。 第二种打印变量的指针的方式如下代码所示：12345678910111213141516171819var x = 42var y = 3.14var z = &quot;foo&quot;var obj = NSObject()func printPointer&lt;T&gt;(ptr: UnsafePointer&lt;T&gt;) &#123; print(ptr)&#125;printPointer(ptr: &amp;x)printPointer(ptr: &amp;y)printPointer(ptr: &amp;z)printPointer(ptr: &amp;obj)// 输出// 0x000000011a145660// 0x000000011a145668// 0x000000011a145670// 0x000000011a145688 ArraySlice的用途Swift提供了ArraySlice来执行数组的切片操作。类似于其它语言中的切片(如Python)，ArraySlice对象复用了原始数组的存储结构，而不是新开辟一块内存区域来将数组片断的元素拷贝过来。因此，它能让我们快速高效地对大数组的片段执行操作。如下代码所示：1234567891011121314var array: [Int] = []for i in 0..&lt;1000 &#123; array.append(i)&#125;let slice = array[100..&lt;300]let result = slice.map &#123; $0 * 2&#125;.reduce(0) &#123; $0 + $1&#125;print(result) // 79800 ArraySlice与Array有相同的接口，所以通常可以在切片数组上执行与原始数组相同的操作。注意 ArraySlice会维持对原始数组的一个强引用，而不仅仅是它所表示的片断。这样即使原始数组对象的生命周期结束了，也可能无法释放。所以不建议长期存储ArraySlice对象，仅用于临时操作。 与Array不同的是，ArraySlice起始索引不一定是0，而是取决于其创建方式。一般是采用共享索引的方式，即ArraySlice对象的起始索引就是切片的开始位置，如代码清单8-2-2所示，切片是从100开始，所以slice[100]是OK的，而slice[99]会报越界错误。通常建议使用startIndex和endIndex来取代指定的索引值. ####","categories":[],"tags":[]},{"title":"YYModel 使用","slug":"YYModel 使用","date":"2018-06-09T16:00:00.000Z","updated":"2018-09-10T07:26:20.853Z","comments":true,"path":"default/YYModel 使用/","link":"","permalink":"https://kysonyangs.github.io/default/YYModel 使用/","excerpt":"YYModel 使用（为了便利查找）","text":"YYModel 使用（为了便利查找） 简单的 Model 与 JSON 相互转换12345678910111213// JSON:&#123; &quot;uid&quot;:123456, &quot;name&quot;:&quot;Harry&quot;, &quot;created&quot;:&quot;1965-07-31T00:00:00+0000&quot;&#125;// Model:@interface User : NSObject@property UInt64 uid;@property NSString *name;@property NSDate *created;@end JSON Model12345// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:User *user = [User yy_modelWithJSON:json];// 将 Model 转换为 JSON 对象:NSDictionary *json = [user yy_modelToJSONObject]; 当 JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。 JSON/Dictionary Model NSString NSNumber, NSURL, SEL, Class NSNumber NSString NSString/NSNumber C number (BOOL, int, float, NSUInteger, UInt64, …) NaN and Inf will be ignored NSString NSDate parsed with these formats: yyyy-MM-dd yyyy-MM-dd HH:mm:ss yyyy-MM-dd’T’HH:mm:ss yyyy-MM-dd’T’HH:mm:ssZ EEE MMM dd HH:mm:ss Z yyyy NSDate NSString formatted with ISO8601: “YYYY-MM-dd’T’HH:mm:ssZ” NSValue struct (CGRect,CGSize,…) NSNull nil, 0 “no”, “false”, … @(NO), 0 “yes”, “true”, … @(YES), 1 Model 属性名和 JSON 中的 Key 不相同1234567891011121314151617181920212223242526// JSON:&#123; &quot;n&quot;:&quot;Harry Pottery&quot;, &quot;p&quot;: 256, &quot;ext&quot; : &#123; &quot;desc&quot; : &quot;A book written by J.K.Rowing.&quot; &#125;, &quot;ID&quot; : 100010&#125;// Model:@interface Book : NSObject@property NSString *name;@property NSInteger page;@property NSString *desc;@property NSString *bookID;@end@implementation Book//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@&quot;name&quot; : @&quot;n&quot;, @&quot;page&quot; : @&quot;p&quot;, @&quot;desc&quot; : @&quot;ext.desc&quot;, @&quot;bookID&quot; : @[@&quot;id&quot;,@&quot;ID&quot;,@&quot;book_id&quot;]&#125;;&#125;@end 你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。 在 json-&gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。 在 model-&gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。 Model 包含其他的 Model12345678910111213141516171819202122232425// JSON&#123; &quot;author&quot;:&#123; &quot;name&quot;:&quot;J.K.Rowling&quot;, &quot;birthday&quot;:&quot;1965-07-31T00:00:00+0000&quot; &#125;, &quot;name&quot;:&quot;Harry Potter&quot;, &quot;pages&quot;:256&#125;// Model: 什么都不用做，转换会自动完成@interface Author : NSObject@property NSString *name;@property NSDate *birthday;@end@implementation Author@end@interface Book : NSObject@property NSString *name;@property NSUInteger pages;@property Author *author; //Book 包含 Author 属性@end@implementation Book@end 容器类属性12345678910111213141516@class Shadow, Border, Attachment;@interface Attributes@property NSString *name;@property NSArray *shadows; //Array&lt;Shadow&gt;@property NSSet *borders; //Set&lt;Border&gt;@property NSMutableDictionary *attachments; //Dict&lt;NSString,Attachment&gt;@end@implementation Attributes// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@&quot;shadows&quot; : [Shadow class], @&quot;borders&quot; : Border.class, @&quot;attachments&quot; : @&quot;Attachment&quot; &#125;;&#125;@end 在实际使用过过程中，[Shadow class]， Border.class， @&quot;Attachment&quot; 没有明显的区别。 黑名单与白名单123456789101112131415@interface User@property NSString *name;@property NSUInteger age;@end@implementation Attributes// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性+ (NSArray *)modelPropertyBlacklist &#123; return @[@&quot;test1&quot;, @&quot;test2&quot;];&#125;// 如果实现了该方法，则处理过程中不会处理该列表外的属性。+ (NSArray *)modelPropertyWhitelist &#123; return @[@&quot;name&quot;];&#125;@end 数据校验与自定义转换实际这个分类的目的比较简单和明确。 就是对判断是否为时间戳，然后对时间戳进行处理，调用 _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; 获取时间。 1234567891011121314151617181920212223242526272829303132// JSON:&#123; &quot;name&quot;:&quot;Harry&quot;, &quot;timestamp&quot; : 1445534567 //时间戳&#125;// Model:@interface User@property NSString *name;@property NSDate *createdAt;@end@implementation User// 当 JSON 转为 Model 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; NSNumber *timestamp = dic[@&quot;timestamp&quot;]; if (![timestamp isKindOfClass:[NSNumber class]]) return NO; _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; return YES;&#125;// 当 Model 转为 JSON 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123; if (!_createdAt) return NO; dic[@&quot;timestamp&quot;] = @(n.timeIntervalSince1970); return YES;&#125;@end Coding/Copying/hash/equal/description以下方法都是YYModel的简单封装，实际使用过程和系统方法区别不大。对其感兴趣的可以点进方法内部查看。 123456789101112131415161718192021222324252627@interface YYShadow :NSObject &lt;NSCoding, NSCopying&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) CGSize size;@end@implementation YYShadow// 直接添加以下代码即可自动完成- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder];&#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder];&#125;- (id)copyWithZone:(NSZone *)zone &#123; return [self yy_modelCopy];&#125;- (NSUInteger)hash &#123; return [self yy_modelHash];&#125;- (BOOL)isEqual:(id)object &#123; return [self yy_modelIsEqual:object];&#125;- (NSString *)description &#123; return [self yy_modelDescription];&#125;@end","categories":[],"tags":[]},{"title":"iOS 线程安全、锁","slug":"iOS 线程安全、锁","date":"2018-06-09T16:00:00.000Z","updated":"2018-09-05T02:59:56.373Z","comments":true,"path":"default/iOS 线程安全、锁/","link":"","permalink":"https://kysonyangs.github.io/default/iOS 线程安全、锁/","excerpt":"iOS 线程安全、锁nonatomic 与 atomic nonatomic: 不会对生成的 getter、setter 方法加同步锁（非原子性） atomic: 会对生成的 getter、setter 加同步锁（原子性）setter / getter 被 atomic 修饰的属性时，该属性是读写安全的。然而读写安全并不代表线程安全。","text":"iOS 线程安全、锁nonatomic 与 atomic nonatomic: 不会对生成的 getter、setter 方法加同步锁（非原子性） atomic: 会对生成的 getter、setter 加同步锁（原子性）setter / getter 被 atomic 修饰的属性时，该属性是读写安全的。然而读写安全并不代表线程安全。 线程安全概念（thread safety） 线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 验证 atomic 非线程安全如下代码12345678910111213141516171819202122232425@interface ViewController ()@property (atomic, copy) NSString *name;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; self.name = @&quot;kyson&quot;; NSLog(@&quot;kyson == %@&quot;, self.name); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; self.name = @&quot;shen&quot;; NSLog(@&quot;shen == %@&quot;, self.name); &#125; &#125;);&#125;@end 输出结果123456782018-07-09 15:28:05.681759+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:05.681857+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:05.681956+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:05.721291+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:05.721291+0800 YSThreadSafetyTest[3186:1387832] kyson == shen2018-07-09 15:28:06.347283+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:06.386894+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:06.386894+0800 YSThreadSafetyTest[3186:1387942] shen == kyson 第五行和第8行可以看出， atomic 非线程安全。 也就是说 atomic 只能做到读写安全并不能做到线程安全，若要实现线程安全还需要采用更为深层的锁定机制才行。 iOS开发时一般都会使用 nonatomic 属性，因为在iOS中使用同步锁的开销较大，这会带来性能问题，但是在Mac OS X程序时，使用 atomic 属性通常都不会有性能瓶颈。 锁的概念在计算机科学中，锁是一种同步机制，用于在存在多线程的环境中实施对资源的访问限制。 锁的作用 通俗来讲：就是为了防止在多线程的情况下对共享资源的脏读或者脏写。 也可以理解为：执行多线程时用于强行限制资源访问的同步机制，即并发控制中保证互斥的要求。 iOS开发中常用的锁 @synchronized NSLock 对象锁 NSRecursiveLock 递归锁 NSConditionLock 条件锁 pthread_mutex 互斥锁（C语言） dispatch_semaphore 信号量实现加锁（GCD） OSSpinLock 自旋锁 性能：ibireme 大神博客盗的性能图 =-= @synchronized@synchronized 其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读性。@synchronized 是我们平常使用最多的但是性能最差的。123456789// OC@synchronized(self) &#123; // 需要执行的代码块&#125;// Swiftobjc_sync_enter(self)// 需要执行的代码块objc_sync_exit(self) 如下代码示例1234567891011121314dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; @synchronized(self) &#123; NSLog(@&quot;第一个线程同步操作开始&quot;); sleep(3); NSLog(@&quot;第一个线程同步操作结束&quot;); &#125;&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); @synchronized(self) &#123; NSLog(@&quot;第二个线程同步操作&quot;); &#125;&#125;); 输出结果1232018-07-09 15:42:06.226069+0800 YSThreadSafetyTest[3294:1487479] 第一个线程同步操作开始2018-07-09 15:42:09.226758+0800 YSThreadSafetyTest[3294:1487479] 第一个线程同步操作结束2018-07-09 15:42:09.226942+0800 YSThreadSafetyTest[3294:1487480] 第二个线程同步操作 @synchronized(self) 指令使用的 self 为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的 self 改成其它对象，线程2就不会被阻塞。 @synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized 块会隐式的添加一个异常处理来保护代码，该处理会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 如果在 @sychronized(object){} 内部 object 被释放或被设为 nil，从我做的测试的结果来看，的确没有问题，但如果 object 一开始就是 nil，则失去了锁的功能。不过虽然 nil 不行，但 @synchronized([NSNull null]) 是完全可以的。 NSLock 对象锁 NSLock 中实现了一个简单的互斥锁。通过 NSLocking 协议定义了 lock 和 unlock 方法。 1234@protocol NSLocking- (void)lock;- (void)unlock;@end 代码示例：银行取钱1234567891011121314151617181920212223242526272829- (void)nslockTest &#123; _money = 1000; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self drawMoney:@&quot;小明&quot;]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self drawMoney:@&quot;小红&quot;]; &#125;);&#125;- (void)drawMoney:(NSString *)person &#123; while (1) &#123; sleep(1); // 加锁 [_lock lock]; if (_money &gt; 0) &#123; _money -= 200; NSLog(@&quot;%@ 取出200元，剩余：%zd元&quot;, person, _money); &#125; else &#123; NSLog(@&quot;%@ 小明 没钱了，勿取&quot;, person); break; &#125; // 解锁 [_lock unlock]; &#125;&#125; 加锁结果：1234562018-07-09 16:04:06.603614+0800 YSThreadSafetyTest[3547:1618383] 小红 取出200元，剩余：800元2018-07-09 16:04:06.603813+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：600元2018-07-09 16:04:07.608957+0800 YSThreadSafetyTest[3547:1618383] 小红 取出200元，剩余：400元2018-07-09 16:04:07.609166+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：200元2018-07-09 16:04:08.611343+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：0元2018-07-09 16:04:08.611538+0800 YSThreadSafetyTest[3547:1618383] 小红 小明 没钱了，勿取 不加锁结果：12345672018-07-09 16:05:10.608726+0800 YSThreadSafetyTest[3565:1624593] 小红 取出200元，剩余：600元2018-07-09 16:05:10.608736+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：800元2018-07-09 16:05:11.612305+0800 YSThreadSafetyTest[3565:1624593] 小红 取出200元，剩余：200元2018-07-09 16:05:11.612305+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：400元2018-07-09 16:05:12.616221+0800 YSThreadSafetyTest[3565:1624593] 小红 小明 没钱了，勿取2018-07-09 16:05:12.616220+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：0元2018-07-09 16:05:13.617584+0800 YSThreadSafetyTest[3565:1624590] 小明 小明 没钱了，勿取 NSLock 类还增加了 tryLock 和 lockBeforeDate: 方法 12- (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; tryLock 尝试加锁，它不会阻塞线程，失败返回NO。 lockBeforeDate: 在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。示例代码： 123456789101112131415161718192021222324252627282930- (void)nslockTest2 &#123; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [_lock lock]; NSLog(@&quot;线程1同步开始&quot;); sleep(5); NSLog(@&quot;线程1同步结束&quot;); [_lock unlock]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); NSLog(@&quot;尝试加锁&quot;); if ([_lock tryLock]) &#123;//尝试加锁，如果不行返回NO，不会阻塞该线程 NSLog(@&quot;加锁成功&quot;); [_lock unlock]; &#125; else &#123; NSLog(@&quot;加锁失败，已经有锁了&quot;); &#125; NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3]; NSLog(@&quot;3s后尝试加锁&quot;); if ([_lock lockBeforeDate:date]) &#123;//尝试在未来的3s内加锁，并阻塞该线程，如果3s内不行恢复线程, 返回NO,不会阻塞该线程 NSLog(@&quot;没有超时，加锁成功&quot;); [_lock unlock]; &#125; else &#123; NSLog(@&quot;超时，加锁失败&quot;); &#125; NSLog(@&quot;线程2 OK&quot;); &#125;);&#125; 输出结果：12345672018-07-09 16:33:51.939314+0800 YSThreadSafetyTest[3874:1773831] 线程1同步开始2018-07-09 16:33:52.944446+0800 YSThreadSafetyTest[3874:1773854] 尝试加锁2018-07-09 16:33:52.944671+0800 YSThreadSafetyTest[3874:1773854] 加锁失败，已经有锁了2018-07-09 16:33:52.944826+0800 YSThreadSafetyTest[3874:1773854] 3s后尝试加锁2018-07-09 16:33:55.946002+0800 YSThreadSafetyTest[3874:1773854] 超时，加锁失败2018-07-09 16:33:55.946176+0800 YSThreadSafetyTest[3874:1773854] 线程2 OK2018-07-09 16:33:56.944367+0800 YSThreadSafetyTest[3874:1773831] 线程1同步结束 NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁。 如下代码：12345678910111213141516171819- (void)recursiveLockTest &#123; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;递归开始&quot;); static void(^TestMethod)(int); TestMethod = ^(int value)&#123; [_lock lock]; if (value &gt; 0) &#123; sleep(1); value--; NSLog(@&quot;递归中 %zd&quot;, value); TestMethod(value); &#125; [_lock unlock]; &#125;; TestMethod(5); NSLog(@&quot;结束&quot;); &#125;);&#125; 输出结果：122018-07-09 16:39:52.833302+0800 YSThreadSafetyTest[3947:1804640] 递归开始2018-07-09 16:39:53.834239+0800 YSThreadSafetyTest[3947:1804640] 递归中 4 可以看到永远都不会结束，这是一个死锁情况。在这个线程中，TestMethod 递归调用，每次进入Block 都会去加一次锁，而从第二次开始，由于锁已经使用了且没有解锁，所以他需要等待锁被解除，这样就导致死锁，线程被阻塞住。 这里可以使用 NSRecursiveLock 递归锁来解决。递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。 NSConditionLock 条件锁NSCoditionLock 做多线程之间的任务等待调用，而且是线程安全的。 NSConditionLock 源码：123456789101112131415161718@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125;- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;@property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);@end NSConditionLock 和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock，tryLockWhenCondition:，NSConditionLock 可以称为条件锁，只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。而 unlockWithCondition: 并不是当 condition符合条件时才解锁，而是解锁之后，修改 Condition 的值。 如下代码：1234567891011121314151617181920212223242526- (void)conditionLockTest &#123; NSMutableArray *products = [NSMutableArray array]; NSInteger HAS_DATA = 1; NSInteger NO_DATA = 0; _conditionLock = [[NSConditionLock alloc] initWithCondition:NO_DATA]; // 初始化一个条件 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; [_conditionLock lockWhenCondition:NO_DATA]; // 当条件为NO_DATA时加锁 [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;生产&quot;); [_conditionLock unlockWithCondition:HAS_DATA]; // 解锁并将条件置为HAS_DATA sleep(5); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; NSLog(@&quot;等待&quot;); [_conditionLock lockWhenCondition:HAS_DATA]; // 当条件为HAS_DATA时加锁 [products removeObjectAtIndex:0]; NSLog(@&quot;售卖&quot;); [_conditionLock unlockWithCondition:NO_DATA]; // 解锁并将条件置为NO_DATA &#125; &#125;);&#125; 输出结果：123452018-07-09 16:55:54.080428+0800 YSThreadSafetyTest[4077:1872496] 等待2018-07-09 16:55:54.080425+0800 YSThreadSafetyTest[4077:1872434] 生产2018-07-09 16:55:54.080664+0800 YSThreadSafetyTest[4077:1872496] 售卖2018-07-09 16:55:54.080751+0800 YSThreadSafetyTest[4077:1872496] 等待... NSCondition一种最基本的条件锁。手动控制线程wait和signal。 NSCondition 源码：12345678910111213@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125;- (void)wait;- (BOOL)waitUntilDate:(NSDate *)limit;- (void)signal;- (void)broadcast;@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);@end NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，经测试，NSCondition 并不会像上文的那些锁一样，先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 示例代码：1234567891011121314151617181920212223242526- (void)conditionTest &#123; NSCondition *condition = [[NSCondition alloc] init]; NSMutableArray *products = [NSMutableArray array]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; if ([products count] == 0) &#123; NSLog(@&quot;等待添加&quot;); [condition wait]; // waitUntilDate: 方法有个等待时间限制，指定的时间到了，则放回 NO，继续运行接下来的任务 &#125; [products removeObjectAtIndex:0]; NSLog(@&quot;删除第一个&quot;); [condition unlock]; &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;数组 总量:%zi&quot;,products.count); [condition signal]; [condition unlock]; sleep(1); &#125; &#125;);&#125; 输出结果：12342018-07-09 17:08:52.504797+0800 YSThreadSafetyTest[4144:1951113] 等待添加2018-07-09 17:08:52.504920+0800 YSThreadSafetyTest[4144:1951112] 数组 总量:12018-07-09 17:08:52.505196+0800 YSThreadSafetyTest[4144:1951113] 删除第一个... waitUntilDate: 方法有个等待时间限制，指定的时间到了，则放回 NO，继续运行接下来的任务 其中 signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。如果没有等待的线程，这两个方法都没有作用。 pthread_mutex 互斥锁（C语言）c语言定义下多线程加锁方式。 pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr); 初始化锁变量mutex。attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t mutex); 加锁 pthread_mutex_tylock(*pthread_mutex_t *mutex); 加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t* mutex); 使用完后释放 示例代码:123456789101112131415161718#import &lt;pthread.h&gt;- (void)pthread_mutex_test &#123; __block pthread_mutex_t theLock; pthread_mutex_init(&amp;theLock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;theLock); NSLog(@&quot;线程1同步开始&quot;); sleep(3); NSLog(@&quot;线程1同步结束&quot;); pthread_mutex_unlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;theLock); NSLog(@&quot;线程2同步操作&quot;); pthread_mutex_unlock(&amp;theLock); &#125;);&#125; 输出结果：1232018-07-09 17:18:39.172501+0800 YSThreadSafetyTest[4201:2003796] 线程1同步开始2018-07-09 17:18:42.177652+0800 YSThreadSafetyTest[4201:2003796] 线程1同步结束2018-07-09 17:18:42.177872+0800 YSThreadSafetyTest[4201:2004380] 线程2同步操作 pthread_mutex 还可以创建条件锁，提供了和 NSCondition 一样的条件控制，初始化互斥锁同时使用 pthread_cond_init 来初始化条件数据结构 123456789101112// 初始化int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);// 等待（会阻塞）int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);// 定时等待int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);// 唤醒int pthread_cond_signal (pthread_cond_t *cond);// 广播唤醒int pthread_cond_broadcast (pthread_cond_t *cond);// 销毁int pthread_cond_destroy (pthread_cond_t *cond); pthread_mutex 还提供了很多函数，有一套完整的API，包含 Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。 dispatch_semaphore 信号量实现加锁（GCD）dispatch_semaphore_t GCD 中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量 +1；每当发送一个等待信号时信号量 -1,；如果信号量为 0 则信号会处于等待状态，直到信号量大于 0(或者超时) 开始执行之后代码。 源码如下：123456789101112131415161718192021222324252627282930/*! * @param value * 信号量的起始值，当传入的值小于零时返回NULL * @result * 成功返回一个新的信号量，失败返回NULL */dispatch_semaphore_t dispatch_semaphore_create(long value)/*! * @discussion * 信号量减1，如果结果小于0，那么等待队列中信号增量到来直到timeout * @param dsema * 信号量 * @param timeout * 等待时间 * 类型为dispatch_time_t，这里有两个宏DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER * @result * 若等待成功返回0，timeout返回非0 */long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);/*! * @discussion * 信号量加1，如果之前的信号量小于0，将唤醒一条等待线程 * @param dsema * 信号量 * @result * 唤醒一条线程返回非0，否则返回0 */long dispatch_semaphore_signal(dispatch_semaphore_t dsema) 示例代码:12345678910111213141516171819202122- (void)semaphoreTest &#123; // 创建信号量 dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC); //线程1 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(semaphore, overTime); // DISPATCH_TIME_FOREVER NSLog(@&quot;任务1开始&quot;); sleep(3); NSLog(@&quot;任务1结束&quot;); dispatch_semaphore_signal(semaphore); &#125;); //线程2 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, overTime); NSLog(@&quot;任务2&quot;); dispatch_semaphore_signal(semaphore); &#125;);&#125; 输出结果：1232018-07-09 17:30:16.753036+0800 YSThreadSafetyTest[4309:2092729] 任务1开始2018-07-09 17:30:19.755907+0800 YSThreadSafetyTest[4309:2092729] 任务1结束2018-07-09 17:30:19.755907+0800 YSThreadSafetyTest[4309:2092656] 任务2 将超时代码设置为1，则输出：1232018-07-09 17:28:41.082817+0800 YSThreadSafetyTest[4286:2081073] 任务1开始2018-07-09 17:28:42.085262+0800 YSThreadSafetyTest[4286:2081075] 任务22018-07-09 17:28:44.084425+0800 YSThreadSafetyTest[4286:2081073] 任务1结束 OSSpinLock 自旋锁示例代码：12345678910111213141516171819#import &lt;libkern/OSAtomic.h&gt;- (void)osspinlockTest &#123; __block OSSpinLock theLock = OS_SPINLOCK_INIT; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); NSLog(@&quot;线程1同步操作开始&quot;); sleep(3); NSLog(@&quot;线程1同步操作结束&quot;); OSSpinLockUnlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); sleep(1); NSLog(@&quot;线程2同步操作&quot;); OSSpinLockUnlock(&amp;theLock); &#125;);&#125; 输出结果：1232018-07-09 17:33:04.759875+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作开始2018-07-09 17:33:07.762309+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作结束2018-07-09 17:33:08.817638+0800 YSThreadSafetyTest[4349:2110977] 线程2同步操作 OSSpinLock 自旋锁，性能最高的锁。它的缺点是当等待时会消耗大量 CPU 资源，不太适用于较长时间的任务。 YY大神在博客 不再安全的 OSSpinLock 中说明了OSSpinLock 已经不再安全，暂不建议使用。 iOS 10 之后，苹果给出了解决方案，就是用 os_unfair_lock 代替 OSSpinLock。1&apos;OSSpinLockLock&apos; is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock_lock() from &lt;os/lock.h&gt; instead 示例代码1234567891011121314151617#import &lt;os/lock.h&gt;__block os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; os_unfair_lock_lock(&amp;lock); NSLog(@&quot;线程1同步操作开始&quot;); sleep(8); NSLog(@&quot;线程1同步操作结束&quot;); os_unfair_lock_unlock(&amp;lock);&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); os_unfair_lock_lock(&amp;lock); NSLog(@&quot;线程2同步操作&quot;); os_unfair_lock_unlock(&amp;lock);&#125;); 输出结果：1232018-07-09 17:33:04.759875+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作开始2018-07-09 17:33:07.762309+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作结束2018-07-09 17:33:08.817638+0800 YSThreadSafetyTest[4349:2110977] 线程2同步操作 总结 @synchronized：适用线程不多，任务量不大的多线程加锁 NSLock：性能不算差，但感觉用的人不多。 dispatch_semaphore_t：使用信号来做加锁，性能很高和 OSSpinLock 差不多。推荐 NSConditionLock：多线程处理不同任务的通信建议时用， 只加锁的话性能很低。 NSRecursiveLock：性能不错，使用场景限制于递归。 POSIX(pthread_mutex)：C语言的底层api，复杂的多线程处理建议使用，也可以封装自己的多线程。 OSSpinLock：性能非常高，可惜不安全了，使用 os_unfair_lock 来代替。","categories":[],"tags":[]},{"title":"iOS小技巧","slug":"iOS 小技巧","date":"2018-06-09T16:00:00.000Z","updated":"2018-09-18T07:31:02.393Z","comments":true,"path":"default/iOS 小技巧/","link":"","permalink":"https://kysonyangs.github.io/default/iOS 小技巧/","excerpt":"截屏12345678- (UIImage *)screenshot &#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; UIGraphicsBeginImageContextWithOptions(window.bounds.size, YES, [UIScreen mainScreen].scale); [window.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 设置pageControl单页不显示1self.pageControl.hidesForSinglePage = YES; 让数组中的所有对象都执行一下方法1[self.view.subViews makeObjectsPerformSelector:@selecter(removeFromSuperView)]; scrollsToTopscrollsToTop是UIScrollView的一个属性，主要用于点击设备的状态栏时，是scrollsToTop == YES的控件滚动返回至顶部。每一个默认的UIScrollView的实例，他的scrollsToTop属性默认为YES，所以要实现某一UIScrollView的实例点击设备状态栏返回顶部，则需要关闭其他的UIScrollView的实例的scrollsToTop属性为NO。 SB跳转12345678910// 跳转[self performSegueWithIdentifier:@&quot;login2Contact&quot; sender:nil];// 在执行跳转之前的时候调用- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; UIViewController *vc = segue.destinationViewController; vc.title = [NSString stringWithFormat:@&quot;%@的联系人列表&quot;, _accountField.text]; NSLog(@&quot;%@--%@&quot;,segue.sourceViewController,segue.destinationViewController);&#125; iOS 10拨打系统电话发现弹出框会延迟2s左右解决方案一：12345678910111213+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; NSComparisonResult compare = [[UIDevice currentDevice].systemVersion compare:@&quot;10.0&quot;]; if (compare == NSOrderedDescending || compare == NSOrderedSame) &#123; /// 大于等于10.0系统使用此openURL方法 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone] options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;&#125; 解决方案二：123456789+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;);&#125; 修改TableViewHeaderView字体大小123456- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section &#123; UITableViewHeaderFooterView *header = (UITableViewHeaderFooterView *)view; header.textLabel.textColor = [UIColor grayColor]; header.textLabel.font = [UIFont systemFontOfSize:15]; header.contentView.backgroundColor = [UIColor groupTableViewBackgroundColor];&#125; heightForHeaderInSection设置高度无效1234iOS11默认开启Self-Sizing，关闭Self-Sizing即可。self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0; 屏蔽一些无知的警告Xcode8里边 Edit Scheme-&gt; Run -&gt; Arguments, 在Environment Variables里边添加 OS_ACTIVITY_MODE ＝ Disable · 如果写了之后还是打印log,请重新勾选对勾，就可以解决了。 UITableView收起键盘1tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; tableviewcell置顶12345678//1.调整(iOS7以上)表格分隔线边距if ([leftTableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; leftTableView.separatorInset = UIEdgeInsetsZero;&#125;//2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效)if ([leftTableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; leftTableView.layoutMargins = UIEdgeInsetsZero;&#125; 长按复制功能123456789- (void)viewDidLoad &#123; [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];&#125;- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress &#123; if (longPress.state == UIGestureRecognizerStateBegan) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;需要复制的文本&quot;; &#125;&#125; 禁止手机睡眠1[UIApplication sharedApplication].idleTimerDisabled = YES; 禁用button高亮123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 控制屏幕旋转，在控制器中写1234567891011121314/** 是否支持自动转屏 */- (BOOL)shouldAutorotate &#123; return YES;&#125;/** 支持哪些屏幕方向 */- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;&#125;/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;&#125; 获取app缓存大小123456789101112131415161718- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; UITextView中打开或禁用复制，剪切，选择，全选等功能12345678910111213141516171819// 继承UITextView重写这个方法- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; // 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125; 禁止textField和textView的复制粘贴菜单123456- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if ([UIMenuController sharedMenuController]) &#123; [UIMenuController sharedMenuController].menuVisible = NO; &#125; return NO;&#125; 为一个view添加虚线边框1234567 CAShapeLayer *border = [CAShapeLayer layer];border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;border.fillColor = nil;border.lineDashPattern = @[@4, @2];border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;border.frame = view.bounds;[view.layer addSublayer:border]; 设置tableView分割线颜色1[self.tableView setSeparatorColor:[UIColor myColor]]; UIImage和base64互转12345678- (NSString *)encodeToBase64String:(UIImage *)image &#123; return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];&#125;- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData &#123; NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [UIImage imageWithData:data];&#125; 摇一摇功能12345678910111、打开摇一摇功能[UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;2、让需要摇动的控制器成为第一响应者[self becomeFirstResponder];3、实现以下方法// 开始摇动- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event// 取消摇动- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event// 摇动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 发起QQ聊天QQ开通推广服务以接收陌生消息12345678//是否安装QQif([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) &#123; //用来接收临时消息的客服QQ号码(注意此QQ号需开通QQ推广功能,否则陌生人向他发送消息会失败) NSString *QQ = @&quot;1099779883&quot;; //调用QQ客户端,发起QQ临时会话 NSString *url = [NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,QQ]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];&#125; MJRefresh webview去掉长按后的选择和复制菜单12345678910111213141516171819202122231. webview 执行 js- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); // 禁用选中效果 [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot; completionHandler:nil]; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot; completionHandler:nil];&#125;func webViewDidFinishLoad(webView: UIWebView) &#123; //禁用webview长按后文字选择框和放大框 webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot;) webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot;) &#125;2. 或者前端写css&lt;style type=&quot;text/css&quot;&gt;*:not(input,textarea) &#123; -webkit-touch-callout: none; -webkit-user-select: none; /* Disable selection/Copy of UIWebView */&#125;&lt;/style&gt; XIB 可见属性设置（eg: 圆角） OC: IB_DESIGNABLE 和 IBInspectable 12345678910111213// .h@property (nonatomic, assign) IBInspectable CGFloat cornerRadius;// .mIB_DESIGNABLE @implementation KLButton- (void)setCornerRadius:(CGFloat)cornerRadius &#123; self.layer.cornerRadius = cornerRadius; self.layer.masksToBounds = (cornerRadius &gt; 0);&#125;- (CGFloat)cornerRadius &#123; return self.layer.cornerRadius;&#125; Swift: IBInspectable 和 IBDesignable 方法不确定的参数 va_arg 宏的使用当我们方法需要传入多个不确定的参数时(如：[NSArray arrayWithObjects]), 我们可以使用 ,… 的形式表示,当要取传入的参数的值时就需要用到 va_arg 宏去取。例如：1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; [self testMethod:@&quot;123&quot;,@&quot;456&quot;,@&quot;789&quot;，nil];&#125;- (void)testMethod:(NSString *)test,.. NS_REQUIRES_NIL_TERMINATION &#123; va_list argList; va_start(argList, test); &#123; for (id params = test; params != nil; params = va_arg(argList, id))&#123; NSLog(@&quot;id = %@---class = %@&quot;,params,NSStringFromClass([params class])); &#125; &#125; va_end(argList);&#125; 去除数组中重复的对象1NSArray *newArr = [oldArr valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;];","text":"截屏12345678- (UIImage *)screenshot &#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; UIGraphicsBeginImageContextWithOptions(window.bounds.size, YES, [UIScreen mainScreen].scale); [window.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 设置pageControl单页不显示1self.pageControl.hidesForSinglePage = YES; 让数组中的所有对象都执行一下方法1[self.view.subViews makeObjectsPerformSelector:@selecter(removeFromSuperView)]; scrollsToTopscrollsToTop是UIScrollView的一个属性，主要用于点击设备的状态栏时，是scrollsToTop == YES的控件滚动返回至顶部。每一个默认的UIScrollView的实例，他的scrollsToTop属性默认为YES，所以要实现某一UIScrollView的实例点击设备状态栏返回顶部，则需要关闭其他的UIScrollView的实例的scrollsToTop属性为NO。 SB跳转12345678910// 跳转[self performSegueWithIdentifier:@&quot;login2Contact&quot; sender:nil];// 在执行跳转之前的时候调用- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; UIViewController *vc = segue.destinationViewController; vc.title = [NSString stringWithFormat:@&quot;%@的联系人列表&quot;, _accountField.text]; NSLog(@&quot;%@--%@&quot;,segue.sourceViewController,segue.destinationViewController);&#125; iOS 10拨打系统电话发现弹出框会延迟2s左右解决方案一：12345678910111213+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; NSComparisonResult compare = [[UIDevice currentDevice].systemVersion compare:@&quot;10.0&quot;]; if (compare == NSOrderedDescending || compare == NSOrderedSame) &#123; /// 大于等于10.0系统使用此openURL方法 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone] options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;&#125; 解决方案二：123456789+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;);&#125; 修改TableViewHeaderView字体大小123456- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section &#123; UITableViewHeaderFooterView *header = (UITableViewHeaderFooterView *)view; header.textLabel.textColor = [UIColor grayColor]; header.textLabel.font = [UIFont systemFontOfSize:15]; header.contentView.backgroundColor = [UIColor groupTableViewBackgroundColor];&#125; heightForHeaderInSection设置高度无效1234iOS11默认开启Self-Sizing，关闭Self-Sizing即可。self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0; 屏蔽一些无知的警告Xcode8里边 Edit Scheme-&gt; Run -&gt; Arguments, 在Environment Variables里边添加 OS_ACTIVITY_MODE ＝ Disable · 如果写了之后还是打印log,请重新勾选对勾，就可以解决了。 UITableView收起键盘1tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; tableviewcell置顶12345678//1.调整(iOS7以上)表格分隔线边距if ([leftTableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; leftTableView.separatorInset = UIEdgeInsetsZero;&#125;//2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效)if ([leftTableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; leftTableView.layoutMargins = UIEdgeInsetsZero;&#125; 长按复制功能123456789- (void)viewDidLoad &#123; [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];&#125;- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress &#123; if (longPress.state == UIGestureRecognizerStateBegan) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;需要复制的文本&quot;; &#125;&#125; 禁止手机睡眠1[UIApplication sharedApplication].idleTimerDisabled = YES; 禁用button高亮123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 控制屏幕旋转，在控制器中写1234567891011121314/** 是否支持自动转屏 */- (BOOL)shouldAutorotate &#123; return YES;&#125;/** 支持哪些屏幕方向 */- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;&#125;/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;&#125; 获取app缓存大小123456789101112131415161718- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; UITextView中打开或禁用复制，剪切，选择，全选等功能12345678910111213141516171819// 继承UITextView重写这个方法- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; // 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125; 禁止textField和textView的复制粘贴菜单123456- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if ([UIMenuController sharedMenuController]) &#123; [UIMenuController sharedMenuController].menuVisible = NO; &#125; return NO;&#125; 为一个view添加虚线边框1234567 CAShapeLayer *border = [CAShapeLayer layer];border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;border.fillColor = nil;border.lineDashPattern = @[@4, @2];border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;border.frame = view.bounds;[view.layer addSublayer:border]; 设置tableView分割线颜色1[self.tableView setSeparatorColor:[UIColor myColor]]; UIImage和base64互转12345678- (NSString *)encodeToBase64String:(UIImage *)image &#123; return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];&#125;- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData &#123; NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [UIImage imageWithData:data];&#125; 摇一摇功能12345678910111、打开摇一摇功能[UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;2、让需要摇动的控制器成为第一响应者[self becomeFirstResponder];3、实现以下方法// 开始摇动- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event// 取消摇动- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event// 摇动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 发起QQ聊天QQ开通推广服务以接收陌生消息12345678//是否安装QQif([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) &#123; //用来接收临时消息的客服QQ号码(注意此QQ号需开通QQ推广功能,否则陌生人向他发送消息会失败) NSString *QQ = @&quot;1099779883&quot;; //调用QQ客户端,发起QQ临时会话 NSString *url = [NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,QQ]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];&#125; MJRefresh webview去掉长按后的选择和复制菜单12345678910111213141516171819202122231. webview 执行 js- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); // 禁用选中效果 [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot; completionHandler:nil]; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot; completionHandler:nil];&#125;func webViewDidFinishLoad(webView: UIWebView) &#123; //禁用webview长按后文字选择框和放大框 webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot;) webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot;) &#125;2. 或者前端写css&lt;style type=&quot;text/css&quot;&gt;*:not(input,textarea) &#123; -webkit-touch-callout: none; -webkit-user-select: none; /* Disable selection/Copy of UIWebView */&#125;&lt;/style&gt; XIB 可见属性设置（eg: 圆角） OC: IB_DESIGNABLE 和 IBInspectable 12345678910111213// .h@property (nonatomic, assign) IBInspectable CGFloat cornerRadius;// .mIB_DESIGNABLE @implementation KLButton- (void)setCornerRadius:(CGFloat)cornerRadius &#123; self.layer.cornerRadius = cornerRadius; self.layer.masksToBounds = (cornerRadius &gt; 0);&#125;- (CGFloat)cornerRadius &#123; return self.layer.cornerRadius;&#125; Swift: IBInspectable 和 IBDesignable 方法不确定的参数 va_arg 宏的使用当我们方法需要传入多个不确定的参数时(如：[NSArray arrayWithObjects]), 我们可以使用 ,… 的形式表示,当要取传入的参数的值时就需要用到 va_arg 宏去取。例如：1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; [self testMethod:@&quot;123&quot;,@&quot;456&quot;,@&quot;789&quot;，nil];&#125;- (void)testMethod:(NSString *)test,.. NS_REQUIRES_NIL_TERMINATION &#123; va_list argList; va_start(argList, test); &#123; for (id params = test; params != nil; params = va_arg(argList, id))&#123; NSLog(@&quot;id = %@---class = %@&quot;,params,NSStringFromClass([params class])); &#125; &#125; va_end(argList);&#125; 去除数组中重复的对象1NSArray *newArr = [oldArr valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]; 删除NSUserDefaults所有记录1234567891011121314//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];//方法二- (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize]; &#125;// 方法三[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; UITableViewCell 分割线置顶12345678//1.调整(iOS7以上)表格分隔线边距if ([_tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; _tableView.separatorInset = UIEdgeInsetsZero;&#125;//2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效)if ([_tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; _tableView.layoutMargins = UIEdgeInsetsZero;&#125; 设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面12tabBarController.tabBar.translucent = NO;uiviewController.navigationController.navigationBar.translucent = NO; 禁用button高亮,点击变灰的效果123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 自定义cell选中背景颜色123UIView *bgColorView = [[UIView alloc] init];bgColorView.backgroundColor = [UIColor redColor];[cell setSelectedBackgroundView:bgColorView]; UILabel设置内边距123456子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect &#123; // 边距，上左下右 UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];&#125; UILabel设置文字描边12345678910111213141516子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect&#123; CGContextRef c = UIGraphicsGetCurrentContext(); // 设置描边宽度 CGContextSetLineWidth(c, 1); CGContextSetLineJoin(c, kCGLineJoinRound); CGContextSetTextDrawingMode(c, kCGTextStroke); // 描边颜色 self.textColor = [UIColor redColor]; [super drawTextInRect:rect]; // 文本颜色 self.textColor = [UIColor yellowColor]; CGContextSetTextDrawingMode(c, kCGTextFill); [super drawTextInRect:rect];&#125; 改变UISlider的进度条高度需要继承UISlider并t重载trackRectForBounds方法123- (CGRect)trackRectForBounds:(CGRect)bounds &#123; return CGRectMake(0, 0, CGRectGetWidth(self.frame), 5.0);&#125; iOS 11中隐藏section头尾的实现1234567891011121314- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 0.1f;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123; return 0.1f;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; return nil;&#125;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; return nil;&#125; 更改UITabBar &amp;&amp; UINavigationBar背景颜色12[[UITabBar appearance] setBarTintColor:[UIColor redColor]];[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]]; 更改UITabBar &amp;&amp; UINavigationBar字体颜色1234567//改变按钮navigationBar tintColor颜色self.navigationController.navigationBar.tintColor = [UIColor colorWithRed:102/255.0 green:102/255.0 blue:102/255.0 alpha:1.0];//改变tabbar 正常颜色，选中色NSDictionary *attributeNormal = @&#123;NSForegroundColorAttributeName:[UIColor grayColor]&#125;;[subVC.tabBarItem setTitleTextAttributes:attributeNormal forState:(UIControlStateNormal)];NSDictionary *attributeSelected = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;;[subVC.tabBarItem setTitleTextAttributes:attributeSelected forState: (UIControlStateSelected)];","categories":[],"tags":[]},{"title":"Playground 使用","slug":"Playground 使用","date":"2018-06-09T16:00:00.000Z","updated":"2018-08-30T03:25:43.444Z","comments":true,"path":"default/Playground 使用/","link":"","permalink":"https://kysonyangs.github.io/default/Playground 使用/","excerpt":"Playground 使用Sources 目录通常情况下，我们直接在 Playground 上面写代码，然后编译器会实时编译我们代码，并将结果显示出来。这很好，我们可以实时得到代码的反馈。 但是这也会产生一个问题，如果我们写了一个函数，或者自定义了一个 view，这部分代码一般情况下是不会变的，而编译器却会一次又一次地去编译这些代码，最终的结果就是导致效率的低下。 这时，Sources 目录就派上用场了，使用 Cmd + 1 打开项目导航栏(Project Navigator)，可以看到一个 Sources 目录。放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。 注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。","text":"Playground 使用Sources 目录通常情况下，我们直接在 Playground 上面写代码，然后编译器会实时编译我们代码，并将结果显示出来。这很好，我们可以实时得到代码的反馈。 但是这也会产生一个问题，如果我们写了一个函数，或者自定义了一个 view，这部分代码一般情况下是不会变的，而编译器却会一次又一次地去编译这些代码，最终的结果就是导致效率的低下。 这时，Sources 目录就派上用场了，使用 Cmd + 1 打开项目导航栏(Project Navigator)，可以看到一个 Sources 目录。放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。 注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。 资源由于 Playground 并没有使用沙盒机制，所以我们无法直接使用沙盒来存储资源文件。 但是，这并不意味着在 Playground 中没办法使用资源文件，Playground 提供了两个地方来存储资源，一个是每个 Playground 都独立的资源，而另一个是所有 Playground 都共享的资源。 独立资源在打开的项目导航栏中可以看到有一个 Resources 目录，放置到此目录下的资源是每个 Playground 独立的。 这个目录的资源是直接放到 mainBundle 中的，可以使用如下代码来获取资源路径：1234if let path = NSBundle.mainBundle().pathForResource(&quot;example&quot;, ofType: &quot;json&quot;) &#123; // do something with json // ...&#125; 如果是图片文件，也可以直接使用UIImage(named:)来获取。 共享资源共享资源的目录是放在用户目录的 Documents 目录下的。在代码中可以直接使用XCPlaygroundSharedDataDirectoryURL来获取共享资源目录的 URL(需要先导入 XCPlayground 模块)。123import XCPlaygroudlet sharedFileURL = XCPlaygroundSharedDataDirectoryURL.URLByAppendingPathComponent(&quot;example.json&quot;) 注意：你需要创建~/Documents/Shared Playground Data目录，并将资源放到此目录下，才能在 Playground 中获取到 异步执行Playground 中的代码是顶层代码(top-level code)，也就是它是在于全局作用域中的。这些代码将会从上到下执行，并在执行完毕之后立即停止。 我们的异步回调代码一般都无法在程序结束之前获得执行，因此如果我们在 Playground 执行网络，或者其它耗时的异步操作，都无法获得我们想要的结果(之前我在 Playgroud 中学习网络操作的时候，就被这个特性折磨到发狂，我一直以为是自己的网络代码写错了)。 为了让程序在代码执行结束后继续执行，我们可以使用如下代码：1XCPlaygroundPage.currentPage.needsIndefiniteExecution = true 这句代码会让 Playground 永远执行下去 ，当我们获取了需要的结果后，可以使用 XCPlaygroundPage.currentPage.finishExecution() 停止 Playground 的执行：123456789101112import XCPlaygroundXCPlaygroundPage.currentPage.needsIndefiniteExecution = truelet url = NSURL(string: &quot;http://httpbin.org/image/png&quot;)!let task = NSURLSession.sharedSession().dataTaskWithURL(url) &#123; data, _, _ in let image = UIImage(data: data!) XCPlaygroundPage.currentPage.finishExecution()&#125;task.resume() 支持 MarkdownPlayground 已经原生支持 markdown 注释渲染，只需要在单行或多行注释的后面添加冒号 :，标记这是一个 markdown 注释。1234567891011//: This line will have **bold** and *italic* text./*:## Headers of All Sizes### Lists of Links- [NSHipster](http://nshipster.com)- [ASCIIwwdc](http://asciiwwdc.com)- [SwiftDoc](http://swiftdoc.org)*/ 可以到菜单 Editor → Show Rendered Markup 下切换是否进行 markdown 渲染。 多页面Playground 支持多页面，这可以让我们将不同类别的代码分别写到不同的页面下，并可以在多个页面之间进行跳转。在项目导航栏中，选择 File &gt; New &gt; Playground Page， 就可以新建一个页面，或者选择项目导航栏左下角的 + 号选择 New Page。注意：如果本 Playground 是第一次新建 Page，则系统会产生两个 Page，一个代表你当前的页面，一个是新建的页面。 页面跳转Playground 支持三种方式的页面跳转： 上一页 下一页 跳转到指定页 页面顺序都是根据它们在项目文件中的排序来决定的。 上一页与下一页的语法：123//: [&quot;Go to Next Page&quot;](@next)//: [&quot;Go to Previous Page&quot;](@previous) 与 markdown 中的超链接类似，方括号中的代码要显示的文字，而小括号则代表跳转的目的地。 指定页跳转：1//: [&quot;Go to The End&quot;](PageName) PageName 代表目标页面的名称，如果页面名称中有空格，则需要使用%20来代替，这是 ASCII 中空格的符号。如下：1//: [&quot;Go to The End&quot;](Last%20Page) 官方文档","categories":[],"tags":[]},{"title":"iOS 设备信息获取","slug":"iOS 设备信息获取","date":"2018-06-09T16:00:00.000Z","updated":"2018-09-10T07:19:46.559Z","comments":true,"path":"default/iOS 设备信息获取/","link":"","permalink":"https://kysonyangs.github.io/default/iOS 设备信息获取/","excerpt":"iOS 设备信息获取为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，整理一下各种信息的获取方式：","text":"iOS 设备信息获取为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，整理一下各种信息的获取方式： 设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 获取设备型号然后手动转化为对应名称- (NSString *)getDeviceName&#123; // 需要#import &quot;sys/utsname.h&quot; #warning 题主呕心沥血总结！！最全面！亲测！全网独此一份！！ struct utsname systemInfo; uname(&amp;systemInfo); NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;; if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;; // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([deviceString isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;; if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;; if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;; if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;; if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;; if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;; if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;; if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;; if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;; if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;; if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;; if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;; if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;; if ([machineString isEqualToString:@&quot;iPad6,11&quot;]) return @&quot;iPad 5 (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5 (Cellular)&quot;; if ([machineString isEqualToString:@&quot;iPad7,1&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (Cellular)&quot;; if ([machineString isEqualToString:@&quot;iPad7,3&quot;]) return @&quot;iPad Pro 10.5 inch (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5 inch (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;AppleTV2,1&quot;]) return @&quot;Apple TV 2&quot;; if ([deviceString isEqualToString:@&quot;AppleTV3,1&quot;]) return @&quot;Apple TV 3&quot;; if ([deviceString isEqualToString:@&quot;AppleTV3,2&quot;]) return @&quot;Apple TV 3&quot;; if ([deviceString isEqualToString:@&quot;AppleTV5,3&quot;]) return @&quot;Apple TV 4&quot;; if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;; if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;; return deviceString;&#125; iPhone名称1[UIDevice currentDevice].name; app版本号1[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]; 电池电量1[[UIDevice currentDevice] batteryLevel]; localizedModel1[UIDevice currentDevice].localizedModel; 当前系统名称1[UIDevice currentDevice].systemName; 当前系统版本号1[UIDevice currentDevice].systemVersion; device_model123struct utsname systemInfo;uname(&amp;systemInfo);NSString *device_model = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; mac 地址12345678910111213141516171819202122232425262728293031323334353637383940414243- (NSString *)getMacAddress &#123; int mib[6]; size_t len; char *buf; unsigned char *ptr; struct if_msghdr *ifm; struct sockaddr_dl *sdl; mib[0] = CTL_NET; mib[1] = AF_ROUTE; mib[2] = 0; mib[3] = AF_LINK; mib[4] = NET_RT_IFLIST; if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123; printf(&quot;Error: if_nametoindex error/n&quot;); return NULL; &#125; if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 1/n&quot;); return NULL; &#125; if ((buf = malloc(len)) == NULL) &#123; printf(&quot;Could not allocate memory. error!/n&quot;); return NULL; &#125; if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 2&quot;); return NULL; &#125; ifm = (struct if_msghdr *)buf; sdl = (struct sockaddr_dl *)(ifm + 1); ptr = (unsigned char *)LLADDR(sdl); NSString *outstring = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)]; free(buf); return [outstring uppercaseString];&#125; IP 地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (NSString *)getDeviceIPAddresses &#123; int sockfd = socket(AF_INET, SOCK_DGRAM, 0); NSMutableArray *ips = [NSMutableArray array]; int BUFFERSIZE = 4096; struct ifconf ifc; char buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr; struct ifreq *ifr, ifrcopy; ifc.ifc_len = BUFFERSIZE; ifc.ifc_buf = buffer; if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= 0)&#123; for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )&#123; ifr = (struct ifreq *)ptr; int len = sizeof(struct sockaddr); if (ifr-&gt;ifr_addr.sa_len &gt; len) &#123; len = ifr-&gt;ifr_addr.sa_len; &#125; ptr += sizeof(ifr-&gt;ifr_name) + len; if (ifr-&gt;ifr_addr.sa_family != AF_INET) continue; if ((cptr = (char *)strchr(ifr-&gt;ifr_name, &apos;:&apos;)) != NULL) *cptr = 0; if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0) continue; memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ); ifrcopy = *ifr; ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy); if ((ifrcopy.ifr_flags &amp; IFF_UP) == 0) continue; NSString *ip = [NSString stringWithFormat:@&quot;%s&quot;, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)]; [ips addObject:ip]; &#125; &#125; close(sockfd); NSString *deviceIP = @&quot;&quot;; for (int i=0; i &lt; ips.count; i++) &#123; if (ips.count &gt; 0) &#123; deviceIP = [NSString stringWithFormat:@&quot;%@&quot;,ips.lastObject]; &#125; &#125; return deviceIP;&#125; 设备上次重启的时间12NSTimeInterval time = [[NSProcessInfo processInfo] systemUptime];NSDate *lastRestartDate = [[NSDate alloc] initWithTimeIntervalSinceNow:(0 - time)]; 广告位标识符在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置 | 隐私 | 广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了 1NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; UUID通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。12NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString];NSLog(@&quot;唯一识别码uuid--&gt;%@&quot;, uuid); CPU12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// CPU总数目- (NSUInteger)getCPUCount &#123; return [NSProcessInfo processInfo].activeProcessorCount;&#125;// 已使用的CPU比例- (float)getCPUUsage &#123; float cpu = 0; NSArray *cpus = [self getPerCPUUsage]; if (cpus.count == 0) return -1; for (NSNumber *n in cpus) &#123; cpu += n.floatValue; &#125; return cpu;&#125;// 获取每个cpu的使用比例- (NSArray *)getPerCPUUsage &#123; processor_info_array_t _cpuInfo, _prevCPUInfo = nil; mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0; unsigned _numCPUs; NSLock *_cpuUsageLock; int _mib[2U] = &#123; CTL_HW, HW_NCPU &#125;; size_t _sizeOfNumCPUs = sizeof(_numCPUs); int _status = sysctl(_mib, 2U, &amp;_numCPUs, &amp;_sizeOfNumCPUs, NULL, 0U); if (_status) _numCPUs = 1; _cpuUsageLock = [[NSLock alloc] init]; natural_t _numCPUsU = 0U; kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;_numCPUsU, &amp;_cpuInfo, &amp;_numCPUInfo); if (err == KERN_SUCCESS) &#123; [_cpuUsageLock lock]; NSMutableArray *cpus = [NSMutableArray new]; for (unsigned i = 0U; i &lt; _numCPUs; ++i) &#123; Float32 _inUse, _total; if (_prevCPUInfo) &#123; _inUse = ( (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER]) + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM]) + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]) ); _total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]); &#125; else &#123; _inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]; _total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]; &#125; [cpus addObject:@(_inUse / _total)]; &#125; [_cpuUsageLock unlock]; if (_prevCPUInfo) &#123; size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo; vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize); &#125; return cpus; &#125; else &#123; return nil; &#125;&#125; Disk 磁盘123456789101112131415161718192021222324252627// 获取磁盘总空间- (int64_t)getTotalDiskSpace &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;// 获取未使用的磁盘空间- (int64_t)getFreeDiskSpace &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;// 获取已使用的磁盘空间- (int64_t)getUsedDiskSpace &#123; int64_t totalDisk = [self getTotalDiskSpace]; int64_t freeDisk = [self getFreeDiskSpace]; if (totalDisk &lt; 0 || freeDisk &lt; 0) return -1; int64_t usedDisk = totalDisk - freeDisk; if (usedDisk &lt; 0) usedDisk = -1; return usedDisk;&#125; 内存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 系统总内存空间- (int64_t)getTotalMemory &#123; int64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory]; if (totalMemory &lt; -1) totalMemory = -1; return totalMemory;&#125;// 活跃的内存,正在使用或者很短时间内被使用过- (int64_t)getActiveMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.active_count * page_size;&#125;// 最近使用过,但是目前处于不活跃状态的内存- (int64_t)getInActiveMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.inactive_count * page_size;&#125;// 空闲的内存空间- (int64_t)getFreeMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.free_count * page_size;&#125;// 已使用的内存空间- (int64_t)getUsedMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);&#125;// 用来存放内核和数据结构的内存,framework、用户级别的应用无法分配- (int64_t)getWiredMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.wire_count * page_size;&#125;// 可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间- (int64_t)getPurgableMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.purgeable_count * page_size;&#125;","categories":[],"tags":[]},{"title":"Info.plist 属性介绍","slug":"Info.plist 属性介绍","date":"2018-06-02T16:00:00.000Z","updated":"2018-08-30T03:39:09.106Z","comments":true,"path":"default/Info.plist 属性介绍/","link":"","permalink":"https://kysonyangs.github.io/default/Info.plist 属性介绍/","excerpt":"","text":"Application does not run in background: 默认 NO， 自从iOS4.0之后，当你在应用程序执行的时候按下Home键，应用程序并不会中断目前的应用，而是放到后台去了。因此希望使用者在按下Home键之后就要退出当前应用的请勾选这个选项。 Localization native development region: 本地化相关 Bundle display name: 应用程序本地化的显示名称，预设值为${PRODUCT_NAME}。 Bundle name: 应用程序的短名称，通常就是你的应用程序名称。 Executable file: 程序安装包的名称, 一般不用改 Bundle identifier: 用来标示应用程序的唯一ID，通常是以反向的DNS方式命名的，例如：com.myCompany.myApp InfoDictionary version: info.plist格式的版本。一般来说，我们不会变动这个数值。 Bundle versions string, short: 应用程序的版本，通常是以三个数字來表示版本号，例如：1.0.1。 Bundle version: 标识编译版本(Bundle number)，你可以使用任何字串格式来表示这个版本。例如使用一个数字来表示编译次数。 Bundle OS Type code: 用用来标识整个封包的(bundle)的类型。在Mac裡面，一个封包可能是一个档案或目录，其目的在于将软体使用到的资源包在一起。例如应用程序应标识为APPL。 Bundle creator OS Type code: 开发者对应用程序的标识 Application requires iPhone environment: 如果应用程序不能在iPad、Touch上运行，设置此项为true; Application uses WIFI: 如果应用程序需要WiFi才能工作，应该将此属性设置为true。这么做会提示用户，如果没有代开WiFi的话，打开WiFi，为了节省电力，iPhone会在30分钟后自动关闭程序中的任何WiFi。设置这一属性可以防止这种情况发生，并且保持连接处于活动状态。 Icon already includes gloss and bevel effects: 应用程序设置玻璃效果，设置为true可以阻止这么做。 Main nib file base name: 应用程序首次启动载入的xib文件 Laumch image: 用以指定应用程序启动时的图片文件。 Initial interface orientation: 指定应用程序打开时的方向。 Localizations: 用以指定应用程序所支持的语言。 Localization native development region: 应用程序原始的语言版本。 Status bar is initially hidden: 设置是否隐藏状态栏 Status bar style: 选择三种不同格式中的一种 URL types: 应用程序支持的URL标识符的一个数组（用于程序回调） supported interface orientation: 程序的默认支持方向 View controller-based status bar appearance: YES/NO 123456// 设为 `YES`, 这时 view controller中对status bar的设置优先级高于application的设置，用下面的方式隐藏status bar:- (BOOL)prefersStatusBarHidden &#123; return YES;&#125;// 设为 `NO`, 这时application的设置优先级最高，用下面的方式隐藏status bar:[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:NO]; Required background modes: 设定当应用程序进入后台执行后，哪些动作要继续在背景执行。这个键值是一个阵列类型的设定，可设定动作包括：audio，locateon，voip。 App Transport Security Settings: https网络，这是个字典，如果需要请求 http 需要设置下列字典项 Allow Arbitrary Loads: YES Privacy ...: 一些权限123456789101112131415161718192021222324Privacy - Media Library Usage Description // 获取用户媒体库说明Privacy - Bluetooth Peripheral Usage Description // 蓝牙外设使用描述Privacy - Calendars Usage Description // 日历的使用说明Privacy - Camera Usage Description // 相机使用叙述说明Privacy - Contacts Usage Description // 联系人使用说明Privacy - Health Share Usage Description // 健康分享使用描述Privacy - Location Always Usage Description // 后台定位(在iOS设置中为&apos;永久&apos;)Privacy - Location Usage Description // 需要定位Privacy - Location When In Use Usage Description // 前台定位(在iOS设置中为&apos;使用期间&apos;)Privacy - Health Update Usage Description // 健康更新使用描述Privacy - HomeKit Usage Description // HomeKit使用描述Privacy - Microphone Usage Description // 麦克风的使用说明Privacy - Motion Usage Description // 运动使用的描述Privacy - Photo Library Usage Description // 照片库使用说明Privacy - Reminders Usage Description // 提醒使用描述Privacy - TV Provider Usage Description // 电视提供商使用的描述 (貌似国内用不到)Privacy - Speech Recognition Usage Description // 语音识别权限Privacy - Reminders Usage DescriptionPrivacy - Reminders Usage Description // 提醒事项权限Privacy - Motion Usage Description // 运动与健身// iOS11新增Privacy - NFC Reader Usage Description //NFC使用描述Privacy - Face ID Usage Descriptio //使用Face IDPrivacy - Photo Library Additions Usage Description // 保存图片到图库中 （重要）","categories":[],"tags":[]},{"title":"Alfred 神器使用","slug":"Alfred workflow","date":"2017-06-09T16:00:00.000Z","updated":"2018-08-30T03:26:17.853Z","comments":true,"path":"default/Alfred workflow/","link":"","permalink":"https://kysonyangs.github.io/default/Alfred workflow/","excerpt":"Alfred设置Alfred 启动后，点击帽子图标，选择 Preferences... 打开设置面板","text":"Alfred设置Alfred 启动后，点击帽子图标，选择 Preferences... 打开设置面板 General: 通用设置 Startup: 是否在系统启动时自启动Alfred。神器，默认勾上，不解释。 Alfred Hotkey: 调出Alfred操作界面的热键。默认为 Alt + 空格。 Where are you: 你在哪个国家。Alfred内置了常用网站搜索功能，在搜索时打开对应国家的网站。 Features: 特性界面 Alfred几乎所有搜索功能都在这个界面设置。免费用户(没有购买Powerpack开启Workflows)重点关注的地方了。 Features包含的所有功能，本文不打算讲解所有的功能，只讲解最常用的。如：Default Results、File Search、Web Search、Calculator等。 Default Results: 默认结果 Essentials: 可设置搜索“应用程序”、“联系人”、“设置”、“Safari书签”。 Extras: 可设置搜索“文件夹”、“文本文件”、“压缩文件”、“个人文档目录”、“图片”、“AppleScript”等其他文件。 Unintelligent: Search all file types 搜索所有文件类型。若勾选此项不但影响巡查速度，还混淆默认搜索结果。Alfred建议用户使用 Find+空格+文件名 来查询文件或文件夹；使用 Open+空格+文件名 也可以。 Search Scope: 设置Alfred查询时 会搜索的文件夹范围，可自己添加和删除。 Fallbacks: 若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。 默认反馈结果为 Google 、Amazon、Wikipedia 网页搜索。 可以自己添加搜索引擎。 Web Search: 网页搜索 Keyword 为 Alfred命令/关键字；DisplayText 为此搜索功能的标题；Custom 有图标表示这个为用户自定义；Enabled 为是否启用。 Alfred网站搜索的设置，这是本人使用最频繁的功能。在图中可看到Alfred默认设置了很多搜索网站，但几乎都是国外网站，因为天朝特色，很多都是我们用不上，因此需要添加自定义的搜索设置。 点击右下角的 Add Custom Search。 根据下面的示意图在弹出界面中输入对应信息，其中网站图标可忽略，然后保存即可。 比如我自定义的百度搜索，信息如下： Search URL: https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;ch=&amp;tn=baiduerr&amp;bar=&amp;wd={query} Title: baidu。 Keyword: bd。 Validation: 为热爱祖国，此项可随意。 Alfred 输入 bd+空格+查询内容, 回车即自动打开百度进行搜索。 只要在对应的网站上搜索一次，记下当时的网址，并把具体的搜索内容改为 {query} 就可以找到我们自定义搜索设置中所需要的 Search URL 信息了。 Calculator: 计算器 直接在Alfred 输入 1+1 可以立即得到结果 输入 = 来进行复杂运算，Alfred支持很多高级的数学函数。eg: =sin(1) Clipboard: 剪切板 开启Alfred的剪切板功能。 查看Alfred剪切板历史记录。默认热键为 Command + Alt + C。 清空Alfred剪切板。在Alfred操作界面中输入 clear。 Advanced: 高级设置 配置同步 点击 Set sync folder... 设置Alfred配置导出的目录。点击 Reveal in Finder 查看Alfred配置所在的目录。 只要将Alfred配置导出的目录设置为 Dropbox 同步目录，就可以实现云同步。 Workflow: 神器啊, 这里收藏自己使用的Workflow。Workflow ListWorkflow ListWorkflow packal Github: 更便捷地使用Github Github Search: 在Alfred上列出Github的搜索结果 使用：github 要搜索的库名 eg: github YYKit 对搜索结果按回车，打开Github网页。 对搜索结果按Cmd + c，复制链接。 按住Cmd再点击搜索结果，打开pull请求。 按住Alt再点击搜索结果，打开issues页面。 Stackoverflow: Stackoverflow 的查询结果 使用：.so 要查询的问题 eg: .so ios Hash: 哈希工具，对字符串和文件进行MD5、SHA1等常用哈希，另外支持Base64等。 对字符串进行SHA1：sha1 kyson Copy Path: 将Finder中文件的路径复制到剪切板中。(该网址下包含众多workflow) 点击 workflow -&gt; copy path -&gt; hotkey 修改此Workflow的热键为 Ctrl + Command + C。 在Finder中选中文件后执行此热键即可复制该文件的路径。 CodeVar: 生成可用的代码变量 小驼峰命名法: xt 大驼峰命名法: dt 下划线命名法: xh 常量命名法: cl 有道词典: 有道词典 并同步到单词本 改变默认终端为 iTerm 首先将 Terminal 的 Application 改变为 Custom： 然后在输入栏中输入：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657on write_to_file(this_data, target_file, append_data) try set the target_file to the target_file as string set the open_target_file to open for access file target_file with write permission if append_data is false then set eof of the open_target_file to 0 write this_data to the open_target_file starting at eof close access the open_target_file return true on error try close access file target_file end try return false end tryend write_to_fileon alfred_script(q) -- Write the command to run to a file. This is done because Applescript quoting is impossible to get right, esp. for backslashes. set tmp_dir to path to temporary items as string from user domain set applescript_alfred_file to tmp_dir &amp; &quot;alfredscript&quot; set alfred_file to POSIX path of applescript_alfred_file write_to_file(q &amp; return, applescript_alfred_file, false) -- Create this file, which prevents iTerm2 from restoring a saved window arrangement. do shell script &quot;touch ~/Library/Application&apos; Support/iTerm/quiet&apos;&quot; -- Test cases: -- 1. iTerm2 running, has windows open. Should open a new window for Alfred command. -- 2. iTerm2 running, no windows open. Should open a new window for Alfred command. -- 3. iTerm2 not running, set to restores arrangement. Should not restore arrangement but open a new window for the Afred command. -- 4. iTerm2 not running. No windows to restore. Should open a single window for the Alfred command. -- 5. iTerm2 not running. Has windows to restore. Restores windows and then opens a new window for the Alfred command. -- Compose a script. This is necessary because compiling in a &apos;tell application&apos; command causes the app to be launched, which would happen prior to the creation of the quiet file. set theScript to &quot;tell application \\&quot;iTerm2.app\\&quot; if (exists current window) then tell current window to create tab with default profile tell current session of current window write contents of file \\&quot;&quot; &amp; alfred_file &amp; &quot;\\&quot; end tell else create window with default profile tell current session of current window write contents of file \\&quot;&quot; &amp; alfred_file &amp; &quot;\\&quot; end tell end if activateend tell&quot; -- Invoke the script. run script theScript -- Clean up-- do shell script &quot;rm -f ~/Library/Application&apos; Support/iTerm/quiet&apos; /tmp/alfredscript&quot;end alfred_script","categories":[],"tags":[]},{"title":"iOS警告","slug":"iOS 警告","date":"2016-06-20T10:28:05.000Z","updated":"2018-09-10T08:58:13.066Z","comments":true,"path":"iOS/iOS 警告/","link":"","permalink":"https://kysonyangs.github.io/iOS/iOS 警告/","excerpt":"一、消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告）","text":"一、消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告）那么，如何得到类似 -Wdeprecated-declarations 的标识符呢？如果下图的 Reveal in log有效，那么点击即可无效的话也别急，你可以如下图操作查看，如果没有就先编译/运行一下然后在下图红框位置找到警告的标识符 如果要删除一个.m里面的所有弃用的警告，如下图操作： 如果要删除项目中所有弃用的警告，如下图操作：当然，你也可以填入别的标识符~ 有的警告编译器会教你如何消除，而你只需要点一下即可！！！ 二、添加警告 直接 #warning &lt;#message#&gt; 在自己写的三方库提供的接口下写上适用范围 1- (void)test NS_DEPRECATED_IOS(2_0, 4_0); 也可以加点信息提示该方法弃用了 123- (void)test __attribute((deprecated(&quot;这个接口已弃用，请使用xxx！&quot;));或者- (void)test NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, &quot;这个接口已弃用，请使用xxx！&quot;); 三、碰到过的警告 Unused variable &#39;xxx&#39; - 没有使用 Deprecated: Push segues are deprecated in iOS 8.0 and later - iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:. - 一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示 &#39;sizeWithFont:constrainedToSize:lineBreakMode:&#39; is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context: - 方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法 Undeclared selector &#39;historyAction&#39; - 使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了 Code will never be executed - 代码永远也不会执行，检查代码吧 &quot;Two-stage rotation animation is deprecated. This application should use the smoother single-stage animation.&quot;原因：不应该将UITabBarControllier嵌入到UINavigationController中作为rootViewController，但是，我们的确想要这样做，只需要在将tabbar作为rootviewcontroller之前先设置tabBarController.selectedIndex= 0。 Expected a type : 两个类相互包含, 在其中一个使用@class Presenting view controllers on detached view controllers is discouraged &lt;SetViewController: 0x7fedb94f0f60&gt;.: 因为present出来的模态窗口，禁止再使用present 来弹出其它的子窗口 解决方法: 123AppDelegate *delegate = (AppDelegate *)[UIApplication sharedApplication].delegate;ViewController *with=[[ViewController alloc]init];[delegate.window.rootViewController presentViewController:with animated:YES completion:^&#123;&#125;]; This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.: 在主线程做的事情却放在了子线程,比如发送通知,刷新UI等 xcodewarning :no rule to process file xxx: 在build phases—&gt;compile sources 里面将对应的文件移除即可。如果有些还不行的话,xcode里面哪儿包含了这个，删。 ld: warning: directory not found for option &#39;-L/Users/xxxx/Desktop/Mos: 123选择 Build Settings 菜单,之后找到Build Settings ,在Search Paths 中有个Deug和Release点击之后有会相对的路径删除该路径,清理一下工程即可.Library Search Paths &amp; Framework Search Paths，删掉编译报warning的路径 Check dependencies Warning: Multiple build commands for output file: 在copy…查找重复资源 删除一个 警告类型","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"警告","slug":"警告","permalink":"https://kysonyangs.github.io/tags/警告/"}]},{"title":"Git 操作","slug":"Git 命令","date":"2016-06-06T14:23:17.000Z","updated":"2018-09-27T06:04:02.833Z","comments":true,"path":"default/Git 命令/","link":"","permalink":"https://kysonyangs.github.io/default/Git 命令/","excerpt":"查看远程仓库地址1git remote -v 放弃修改，强制覆盖本地代码123git fetch --allgit reset --hard origin/mastergit pull Git常用命令 git init: 初始化一个Git仓库：把某个目录变成Git可以管理的仓库 git add test.h: 把文件test.h添加到仓库 git commit -m &quot;添加了test.h文件&quot;: 把文件提交到仓库。(git commit命令，-m后面输入的是本次提交的说明) git push (origin master(分支名称)): 推送到远程仓库,其中（）里面是可选的 git pull (origin master(分支名称)): 拉取远程仓库最新,其中（）里面是可选的 git status: 查看工作区的状态 git diff test.h: 查看test.h文件修改了什么（diff—&gt;difference） git log: 显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数 git remote add origin git@...: 关联一个远程库 git push -u origin master: 当远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git clone git@...: 克隆 git remote: 要查看远程库的名称 git remote -v: 显示更详细的远程库信息。显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址 git fetch: 个人粗浅的理解为将远程所有的分支信息拉取到本地1 回退与撤销 git reset --hard HEAD^: 回到上一个版本 git reset --hard HEAD^^: 回到上上个版本 git reset --hard HEAD~100: 回到上100个版本 git reset --hard 791c95aa44cc5540d93a146d6d341e5d38936762: 根据提交的版本号进行版本的回退 git reflog: 查看命令历史，以便确定要回到未来的哪个版本。 git checkout -- readme.txt: 让这个文件回到最近一次git commit或git add时的状态。这里是把readme.txt文件在工作区的修改全部撤销，这里有两种情况： a. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； b. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD 文件(readme.txt): a. 可以把暂存区的修改撤销掉（unstage），重新放回工作区。若要丢弃工作区的修改，还需要git checkout – readme.txt b. git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 分支与合并 git branch dev: 创建一个名称叫dev的分支 git checkout dev: 当前的分支切换为dev分支 git checkout -b dev: 创建一个dev分支，并且切换到dev分支（相当于是是前面两句命令的合并） git branch: 列出所有分支，当前分支前面会标一个*号 git merge dev: 把dev分支的工作成果合并到当前分支上, git merge命令用于合并指定分支到当前分支 git branch -d dev: 删除dev分支 git branch -D dev: 若dev分支还没合并到所切出来的分支，则git branch -d dev将不能删除dev分支，可以通过git branch -D dev强行删除dev分支 git log --graph: 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit git merge --no-ff -m &quot;备注的信息&quot; dev: 将dev分支合并到当前分支的时候强制禁用Fast forward模式 a. 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 b. 合并分支时，加上–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward 合并就看不出来曾经做过合并。 git branch -r: 查看远程分支 git branch -a: 查看所有分支（会显示本地分支和远程分支） git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2","text":"查看远程仓库地址1git remote -v 放弃修改，强制覆盖本地代码123git fetch --allgit reset --hard origin/mastergit pull Git常用命令 git init: 初始化一个Git仓库：把某个目录变成Git可以管理的仓库 git add test.h: 把文件test.h添加到仓库 git commit -m &quot;添加了test.h文件&quot;: 把文件提交到仓库。(git commit命令，-m后面输入的是本次提交的说明) git push (origin master(分支名称)): 推送到远程仓库,其中（）里面是可选的 git pull (origin master(分支名称)): 拉取远程仓库最新,其中（）里面是可选的 git status: 查看工作区的状态 git diff test.h: 查看test.h文件修改了什么（diff—&gt;difference） git log: 显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数 git remote add origin git@...: 关联一个远程库 git push -u origin master: 当远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git clone git@...: 克隆 git remote: 要查看远程库的名称 git remote -v: 显示更详细的远程库信息。显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址 git fetch: 个人粗浅的理解为将远程所有的分支信息拉取到本地1 回退与撤销 git reset --hard HEAD^: 回到上一个版本 git reset --hard HEAD^^: 回到上上个版本 git reset --hard HEAD~100: 回到上100个版本 git reset --hard 791c95aa44cc5540d93a146d6d341e5d38936762: 根据提交的版本号进行版本的回退 git reflog: 查看命令历史，以便确定要回到未来的哪个版本。 git checkout -- readme.txt: 让这个文件回到最近一次git commit或git add时的状态。这里是把readme.txt文件在工作区的修改全部撤销，这里有两种情况： a. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； b. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD 文件(readme.txt): a. 可以把暂存区的修改撤销掉（unstage），重新放回工作区。若要丢弃工作区的修改，还需要git checkout – readme.txt b. git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 分支与合并 git branch dev: 创建一个名称叫dev的分支 git checkout dev: 当前的分支切换为dev分支 git checkout -b dev: 创建一个dev分支，并且切换到dev分支（相当于是是前面两句命令的合并） git branch: 列出所有分支，当前分支前面会标一个*号 git merge dev: 把dev分支的工作成果合并到当前分支上, git merge命令用于合并指定分支到当前分支 git branch -d dev: 删除dev分支 git branch -D dev: 若dev分支还没合并到所切出来的分支，则git branch -d dev将不能删除dev分支，可以通过git branch -D dev强行删除dev分支 git log --graph: 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit git merge --no-ff -m &quot;备注的信息&quot; dev: 将dev分支合并到当前分支的时候强制禁用Fast forward模式 a. 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 b. 合并分支时，加上–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward 合并就看不出来曾经做过合并。 git branch -r: 查看远程分支 git branch -a: 查看所有分支（会显示本地分支和远程分支） git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2 配置.ssh/config 123456789101112131415161718192021vi .ssh/config# 加上以下内容# github# first.github (first@gmail.com)Host github.comHostName github.comIdentityFile ~/.ssh/id_rsa# second (second@gmail.com)Host secondHostName github.comIdentityFile ~/.ssh/id_rsa_second# gitOSc# default git@oscHost git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/id_rsaHost second HostName git.oschina.net IdentityFile ~/.ssh/id_rsa_work 将 id_rsa.pub id_rsa_2.pub添加到对应账号上 验证是否成功 123456//1. Github验证ssh -T git@github.comssh -T git@second//2. Git Osc验证ssh -T git@git.oschina.netssh -T git@git.second.net(貌似是这个吧，有点忘了) 使用账号2clone push 123456git clone... 下来后 修改// 方法1git remote rm origingit remote add origin git@onemaybe:OneMaybe/OneMaybe.github.io.git// 方法2vi .git/config","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2016-06-05T16:00:00.000Z","updated":"2018-09-10T08:12:22.202Z","comments":true,"path":"default/深拷贝与浅拷贝/","link":"","permalink":"https://kysonyangs.github.io/default/深拷贝与浅拷贝/","excerpt":"","text":"浅拷贝指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。 单层深拷贝 对于不可变的容器类对象(如 NSArray、NSSet、NSDictionary)进行 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化，属于单层深拷贝。 对于可变集合类对象(如 NSMutableArray、NSMutableSet、NSMutableDictionary)，不管是进行 copy 操作还是 mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。 深拷贝指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。 非集合类型的 copy 与 mutableCopy NSString copy 内存地址不变，浅拷贝 mutableCopy 内存地址改变，深拷贝 NSMutableString copy 内存地址改变，深拷贝 mutableCopy 内存地址改变，深拷贝 集合类型的 copy 与 mutableCopy NSArray copy 内存地址不变，内部元素地址不变，浅拷贝 mutableCopy 内存地址改变，但是内部元素地址不变，单层深拷贝 NSMutableArray copy 内存地址改变，但是内部元素地址不变，单层深拷贝 mutableCopy 内存地址改变，但是内部元素地址不变，单层深拷贝 实现集合类型的深拷贝 通过归解档生成两份完全独立的对象，但是前提是对象(子对象)必须全部支持 NSCoding 协议。推荐使用 YYModel + NSCopying 这样就不用自己写逻辑代码了 😁 自己实现一个深拷贝协议 123@protocol YSDeepCopy &lt;NSObject&gt;- (id)ys_deepCopy;@end @interface NSArray (YSDeepCopy) @end123456789101112131415161718192021222324- (instancetype)ys_deepCopy &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:self.count]; for (id subObject in self) &#123; id deepCopySubObject = nil; if ([subObject respondsToSelector:@selector(ys_deepCopy)]) &#123; deepCopySubObject = [subObject ys_deepCopy]; &#125; else if ([subObject conformsToProtocol:@protocol(NSCopying)]) &#123; deepCopySubObject = [subObject copy]; &#125; else &#123; NSAssert1(NO, @&quot;Class \\&quot;%s\\&quot; not support YSDeepCopy&quot;, object_getClassName(subObject)); deepCopySubObject = subObject; &#125; [mArray addObject:deepCopySubObject ?: subObject]; &#125; if ([self isKindOfClass:[NSMutableArray class]]) &#123; return mArray; &#125; else &#123; return [NSArray arrayWithArray:mArray]; &#125;&#125; 但是如果 数组里面 添加的是自己定义的Model， 则应该实现 Model 的 NSCopying 协议， 或者 YSDeepCopy 协议推荐使用 YYModel + NSCopying 这样就不用自己写逻辑代码了 😁","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"基础知识","slug":"基础知识","date":"2016-06-05T16:00:00.000Z","updated":"2018-09-10T09:08:58.636Z","comments":true,"path":"default/基础知识/","link":"","permalink":"https://kysonyangs.github.io/default/基础知识/","excerpt":"","text":"应用沙盒 Documents: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录. Library: Caches: 保存应用运行时生成的需要持久化的数据，一般存储体积大、不需要备份的非重要数据,缓存文件存储地. - Preferences: 保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息,iTunes同步设备时会备份该目录. tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除;应用没有运行时，系统也可能会清除该目录下的文件;iTunes同步设备时不会备份该目录. 路径获取：12345678910111213141516// 沙盒根目录NSLog(@&quot;%@&quot;, NSHomeDirectory());// DocumentsNSLog(@&quot;%@&quot;, [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;]);// ORNSLog(@&quot;%@&quot;, [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]);// Library - CachesNSLog(@&quot;%@&quot;, [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library&quot;] stringByAppendingPathComponent:@&quot;Caches&quot;]);// ORNSLog(@&quot;%@&quot;, [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]);Preference[NSUserDefaults standardUserDefaults] ...// tmpNSLog(@&quot;t - %@&quot;, NSTemporaryDirectory()); content Hugging ／ content Compression Resistance不想变大/不想变小约束 灰常有用哦 layoutSubviews方法调用 init方法不会调用 addSubview方法等时候会调用 bounds改变的时候调用 scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑) 旋转设备的时候调用 子视图被移除的时候调用 内存的几大区域栈区（Stack）由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点时有限制，数据不灵活。［先进后出］ 栈空间分 静态分配 和 动态分配两种。 静态分配是编译器完成的，比如自动变量（auto）的分配 动态变量是由 alloc 函数完成的 栈的动态分配无需释放（是自动的），也就没有释放函数。 为可移植的程序起见，栈的动态分配是不被鼓励的。 堆区（heap）由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在 ios 中 alloc 都是存放在堆中。 优点是灵活方便，数据适应面广泛，但是效率有一定降低。 堆是函数库内部数据结构，不一定唯一。 不同堆的分配的内存无法相互操作。 堆空间的分配总是动态的 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 全局区(静态区) (static)全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。 文字常量区存放常量字符串，程序结束后由系统释放； 代码区存放函数的二进制代码 CGRectInset 与 CGRectOffsetCGRectInset 与 CGRectOffset 都是通过参数改变 CGRect 并返回一个 CGRect 类型的数据。总结出两者的区别在于：CGRectInset 会进行平移和缩放两个操作。CGRectOffset 做的只是平移。 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)通过第二个参数 dx 和第三个参数 dy 重置第一个参数 rect 作为结果返回。重置的方式为，首先将 rect 的坐标（origin）按照(dx,dy) 进行平移，然后将 rect 的大小（size） 宽度缩小2倍的 dx，高度缩小2倍的 dy。注意: dx dy 正数 左右两边缩小，负数则是放大 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)rect 按照（dx,dy）进行平移。 断言 NSAssert() 和 NSParameterAssert 区别和用处NSAssert 和 assert 是断言,主要的差别是 assert 在断言失败的时候只是简单的终止程序, 而 NSAssert 会报告出错误信息并且打印出来. 所以尽管的使用 NSAssert,可以不去使用 assert. NSAssert/NSCAssert 两者的差别, 前者是适合于Objective-C的方法, 后者是适用于 C 的函数.NSParameterAssert/NSCparameterAssert 两者的区别也是前者适用于 Objective-C 的方法, 后者适用于 C 的函数.NSAssert/NSCAssert 和 NSParameterAssert/NSCparameterAssert 的区别是前者是所有断言, 后者只是针对参数是否存在的断言, 所以可以先进行参数的断言,确认参数是正确的,再进行所有的断言,确认其他原因.NSAssert的用法12int a = 4;NSAssert(a == 5, @&quot;a must equal to 5&quot;); //第一个参数是条件,如果第一个参数不满足条件,就会记录和打印第二个参数 NSParameterAssert的用法1NSParameterAssert(str); //只需要一个参数,如果参数存在程序继续运行,如果参数为空,则程序停止打印日志 注: Xcode 已经默认将release环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. iOS模拟器的Debug菜单iOS模拟器的Debug菜单中提供了几个菜单项来检测影响帧率的一些因素： Color Blended Layers: 高亮显示有混合操作的区域； Color Copied Images: 高亮显示被拷贝的图片。拷贝图片意味着Core Animation需要拷贝一份图片并发送给render server，这对内存和CPU的使用都是昂贵的； Color Misaligned Images: 高亮显示缩放或拉伸过的图片，或者没有正确对齐对到像素边界的图片； Color Offscreen-Rendered: 高亮显示离屏渲染的层对象。 nil、NIL、NULL、 NSNull 的区别 nil: 指向一个对象的空指针, 对 Objective-C id 对象赋空值. 1NSString *str = nil; Nil: 指向一个类的空指针, 表示对类进行赋空值. 1Class Class1 = Nil; NULL: 指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值. 123int *intA = NULL;char *charC = NULL;struct structStr = NULL; NSNull: 在集合对象中，表示空值的对象.NSNull在Objective-C中是一个类. NSNull有 + (NSNull *)null; 单例方法. 多用于集合(NSArray,NSDictionary)中值为空的对象. 1234567891011NSArray *array = [NSArray arrayWithObjects: [[NSObject alloc] init], [NSNull null], nil];NSMutableDictionary *mutableDictionary = [[NSMutableDictionary alloc] init];[mutableDictionary setObject:nil forKey:@&quot;Key-nil&quot;]; // 会引起Crash[mutableDictionary setObject:[NSNull null] forKey:@&quot;Key-nil&quot;]; // 不会引起Crash//所以在使用时，如下方法是比较安全的[mutableDictionary setObject:(nil == value ? [NSNull null] : value) forKey:@&quot;Key&quot;]; property 属性的关键字 表示原子性 atomic（默认）: 线程安全，但是线程开销大，影响性能注: atomic不一定是线程安全，因为其只保证 setter&amp;getter 是线程安全，但是如果 threadA 进行写，这时其他现线程的读或者写会因为该操作而等待。但是当 threadA 写操作完成后，threadB 进行写操作，threadA 需要读操作的时候，可能会获得 threadB 线程的值，这就破坏了线程安全。而且如果 threadC 在 threadA 线程读操作之前 release 了， 会导致崩溃。所以 atomic 所说的线程安全只是保证了 getter和setter 存取方法的线程安全，并不能保证整个对象是线程安全的。 nonatomic: 非线程安全 表示引用计数 assign: assign 用于非指针变量，一般用于基础类型和C数据类型，这些类型不是对象，统一由系统栈进行内存管理。 weak: 对对象的弱引用，不增加对象的引用计数，也不持有对象，当对象消失后指针自动指向nil，所以这里也就防止了野指针的存在。 strong: 对对象的强引用，会增加对象的引用计数，如果指向了一个空对象，会造成野指针，平常我们用得最多的应该也是strong了。 copy: 建立一个引用计数为1的新对象，赋值时对传入值进行一份拷贝，所以使用 copy 关键字的时候，你将一个对象复制给该属性，该属性并不会持有那个对象，而是会创建一个新对象，并将那个对象的值拷贝给它。而使用 copy 关键字的对象必须要实现 NSCopying 协议。 unsafe_unretained: 跟 weak 类似，声明一个弱引用，但是当引用计数为 0 时，变量不会自动设置为 nil，现在基本都用 weak 了。 表示权限 readwrite: 可读可写 readonly: 只读，当你希望暴露出来的属性不能被外界修改时就需要申明为 readonly 。 id 和 instanceType instancetype 和 id 都是万能指针，指向对象。 id 在编译的适合不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型 id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型 instancetype 只适用于初始化方法和便利构造器的返回值类型 @synthesize 和 @dynamic @property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic 都没写，那么默认的就是 @syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter方法和 getter方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器,属性的 setter与getter 方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和@getter 方法，编译的时候没问题，但是当程序运行到instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 UIView 和 CALayer UIView 和 CALayer 算是相互补充的关系。 UIView = CALayer.delegate UIView : 负责用户的交互事件。 CALayer: 负责图像和动画的渲染。 Bounds 和 Frame Bounds: 一般是相对于自身来说的，是控件的内部尺寸。如果你修改了 Bounds，那么子控件的相对位置也会发生改变。 Frame: 是相对于父控件来说的，是控件的外部尺寸。 UIViewController 生命周期","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"iOS中JavaScript和OC交互","slug":"16-05 iOS中JavaScript和OC交互","date":"2016-05-10T14:31:54.000Z","updated":"2018-06-20T02:19:58.827Z","comments":true,"path":"iOS/16-05 iOS中JavaScript和OC交互/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-05 iOS中JavaScript和OC交互/","excerpt":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","text":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Objective-C语言调用JavaScript语言 通过UIWebView的 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 方法实现，利用该方法执行一段JavaScript代码。（JavaScript: 以下使用JS代替） 获取当前网页的标题 1self.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title;&quot;]; 获取当前网页的网址URL 1NSLog(@&quot;%@&quot;, [webView stringByEvaluatingJavaScriptFromString:@&quot;document.location.href;&quot;]); 调用JS的方法 1[webView stringByEvaluatingJavaScriptFromString:@&quot;klevent();&quot;] 以上执行情况如下 如果是自己写的HTML5网页，你可以控制里面的元素删除或者添加之类的，当然你得先懂点HTML5-JS知识123NSString *str = @&quot;var p = document.getElementsByTagName(&apos;p&apos;)[0];&quot; &quot;p.remove();&quot;;[webView stringByEvaluatingJavaScriptFromString:str]; * JS调用OC的方法 先来个简单的不带参数1234567891011121314151617181920// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; // 判断是否包含 if ([url hasPrefix:scheme]) &#123; [self js1]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有一个参数12345678910111213141516171819202122232425262728// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://one=kellen&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js2?one=kellen NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js2 NSString *methodName = [[subpaths firstObject] stringByAppendingString:@&quot;:&quot;]; // 参数 kellen NSString *param = [subpaths lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:param]; // 当然，你也可以只获得参数，调用的方法名自己写 return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有两个或多个参数1234567891011121314151617181920212223242526272829303132333435// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://js3_two_?one=kellen&amp;two=Yangs&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js3_two_?one=kellen&amp;two=Yangs NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js3_two_ NSString *methodName = [[subpaths firstObject] stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;:&quot;]; // 参数 one=kellen&amp;two=Yangs NSString *param = [subpaths lastObject]; NSArray *subparams = nil; if (subpaths.count == 2 || [param containsString:@&quot;&amp;&quot;]) &#123; subparams = [param componentsSeparatedByString:@&quot;&amp;&quot;]; &#125; // 取出前面的2个参数 NSString *firstParam = [subparams firstObject]; NSString *secondParam = subparams.count &lt;= 1 ? nil : [subparams lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:firstParam withObject:secondParam]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有个三方库可以方便开发","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"JS交互","slug":"JS交互","permalink":"https://kysonyangs.github.io/tags/JS交互/"}]},{"title":"Swift-CoreData的使用","slug":"16-05 Swift-CoreData的使用","date":"2016-05-09T13:47:35.000Z","updated":"2018-06-20T02:20:47.483Z","comments":true,"path":"Swift/16-05 Swift-CoreData的使用/","link":"","permalink":"https://kysonyangs.github.io/Swift/16-05 Swift-CoreData的使用/","excerpt":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。","text":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。 创建一个新工程，在AppDelegate里面多了下面方法。 如果你已经创建好工程，但是没勾选上面选项，没关系，新建一个CoreData文件但是AppDelegate里面没东西，没关系，新建一个新项目，将里面的内容拷进你的项目，但是你得修改一个地方 新建一个实体双击修改名字 添加属性 新建NSManagedObject，通过Core Data从数据库取出的对象，默认情况下都是NSManagedObject对象next -&gt; next -&gt; next OK，多了两个文件 KL_Test+CoreDataProperties.swift 不需要变 KL_Test.swift 添加增删查改的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import Foundationimport CoreDataimport UIKit@objc(CollectGank)class KL_Test: NSManagedObject &#123; static let app = UIApplication.sharedApplication().delegate as! AppDelegate static let context = app.managedObjectContext // 插入 static func insert(model: KL_Test) &#123; let collectGank = NSEntityDescription.insertNewObjectForEntityForName(&quot;KL_Test&quot;,inManagedObjectContext: context) as! KL_Test collectGank.name = model.name collectGank.age = model.age do &#123; try context.save() print(&quot;成功&quot;) &#125;catch &#123; fatalError(&quot;不能保存\\(error)&quot;) &#125; &#125; // 查询所有的数据并返回 static func fetch() -&gt; [KL_Test] &#123; var array = [KL_Test]() //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) array = fetchedObjects as! [KL_Test] &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; return array &#125; // 修改 static func update(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() fetchRequest.fetchLimit = 1 //限定查询结果的数量 fetchRequest.fetchOffset = 0 //查询的偏移量 //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;kellen&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 是否存在（查找） static func exist(gank: KL_Test) -&gt; Bool &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 guard (fetchedObjects != nil &amp;&amp; fetchedObjects!.count &gt; 0) else &#123; return false &#125; return true &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 删除 static func deleted(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;CollectGank&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos;&quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) print(fetchedObjects) //遍历查询的结果 for info:KL_Test in fetchedObjects as! [KL_Test]&#123; //删除对象 context.deleteObject(info) &#125; //重新保存-更新到数据库 try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://kysonyangs.github.io/categories/Swift/"}],"tags":[{"name":"CoreData","slug":"CoreData","permalink":"https://kysonyangs.github.io/tags/CoreData/"}]},{"title":"Charles 使用","slug":"16-04 Charles使用","date":"2016-04-15T07:10:53.000Z","updated":"2018-09-10T07:31:08.629Z","comments":true,"path":"iOS/16-04 Charles使用/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 Charles使用/","excerpt":"Charles 主要的功能 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。","text":"Charles 主要的功能 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 将Charles 设置成系统代理选择菜单中的”Proxy” -&gt; “Mac OX Proxy” 将Charles设置成系统代理。这样就可以看到本机的网络强求了… 过滤网络请求 在Filter中填入你想过需要的关键字 选择菜单”Proxy” -&gt; “Recording Setting” -&gt; “Include”,添加一个项目，填入监控的协议，主机地址，端口号，就可以只截取目标网站的封包。 在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项 其中1、3是临时性的， 2是经常性的。 截取iPhone上的网络封包 Charles 设置将 Charles 的代理功能打开， 选择菜单”Proxy” -&gt; “Proxy Settings”, 在Port填入代理端口8080，并且勾上”Enable transparent HTTP proxying”，如图： iPhone设置2.1 获取电脑IP地址 // 192.168.0.127选择菜单”Help” -&gt; “Local IP Address”查看本机IP2.2 iPhone设置 -&gt; Wi-Fi -&gt; 当前连接的wifi -&gt; 点击右侧详情按钮 -&gt; 底部HTTP代理选择手动 -&gt; 服务器填上电脑的IP地址 -&gt; 端口号填 8080 电脑Chroles会弹出一个是否确认的菜单，选择Allow！！！ OK,完成！ HTTP抓包 打开Charles程序 查看Mac电脑的IP地址，如192.168.1.7 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888 iOS设备打开你要抓包的app进行网络操作 Charles弹出确认框，点击Allow按钮即可 HTTPS抓包 在 iOS 设备上打开这个网址 http://www.charlesproxy.com/getssl 安装 Charles SSL 证书 在Charles的工具栏上点击设置按钮，选择Proxy Settings…3 切换到SSL选项卡，选中Enable SSL Proxying，别急，选完先别关掉，还有下一步 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles则麻烦一些，需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"生成条形码和二维码","slug":"16-04 生成条形码和二维码","date":"2016-04-11T09:16:47.000Z","updated":"2018-09-10T07:46:24.676Z","comments":true,"path":"iOS/16-04 生成条形码和二维码/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 生成条形码和二维码/","excerpt":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","text":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 生成二维码123456789101112131415161718- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成二维码图片 CIImage *qrcodeImage; NSData *data = [_code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; [filter setValue:@&quot;H&quot; forKey:@&quot;inputCorrectionLevel&quot;]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"Bug集锦","slug":"Bug 集锦","date":"2016-04-11T07:10:53.000Z","updated":"2018-09-27T06:06:38.942Z","comments":true,"path":"iOS/Bug 集锦/","link":"","permalink":"https://kysonyangs.github.io/iOS/Bug 集锦/","excerpt":"Xcode Bug自定义的代码片段存放位置1~/Library/Developer/Xcode/UserData/CodeSnippets Xcode 10 Multiple commands produce 报错解决1target &gt; Build phase &gt; Copy Bundle Resource/Compile Sources，删掉第三方库中重复的 README.txt，LICENSE，Info.plist 文件 工程文件乱序选中要整理的文件夹右键，点一下“Sort by Name”或者“Sort by Type”即可排序。 项目打不开 Failed to load project at ‘’ “,incompatible project version打开 project.pbxproj 文件，修改 objectVersion = 48; 不知道填什么往低了填，或者在自己想买找 Xcode 不高亮123cd Library/Developer/Xcode/DerivedDatarm -rf ./*重新打开XCODE 打开Playground提示打开失败，找不到合适的devices1231. Quit Xcode2. Delete the folder /Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices. For example, in Terminal: rm -rf ~/Library/Developer/CoreSimulator/Devices3. In Terminal: killall -9 com.apple.CoreSimulator.CoreSimulatorService (or just reboot). OR Add a iOS8.0Device 碰到Xib加载不出来，什么什么工程文件找不到，请看看引用有没有，没有的话加上就好了！用Xcode 7.3打开一个Xcode 8创建的工程，编译时报错：xxx.storyboard(或者xxx.xib) The document “null” required Xcode 8.0 or later.点击xxx.storyboard(或者xxx.xib)时，弹出如图所示提示框。解决方法是以源码的方式打开xxx.storyboard(或者xxx.xib)，然后删除&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;这一行代码，就OK了。 程序报错pathForResource nil的情况，而项目命名有该资源可能没拷贝进bundle1Xcode -&gt; TARAGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 添加 ‘Could not instantiate class named xxx’比如 ‘Could not instantiate class named WKWebView’ 解决方法1Xcode -&gt; TARAGETS -&gt; General -&gt; Linked Frameworks and Librarier ，点击“+”号添加相应的系统库 webkit.framework 添加新字体， info.plist也配置好了，就是无效请检查 TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources 中是否添加此资源 其他添加资源后无效也可参考此条解决方案 ld: library not found for -lxxx:类似出现上面这种问题(我的问题出现在libWeChatSDK这个包) ld:library not found for -lXXX 的问题有可能是你的某个库的连接引用有问题, —–解决的办法就是在项目的target里,选中Link Binary With Libraries 里的.a或framework 取消再加入,就可以了 —–如果是拖拽进入工程的,那就删除,在拖一次. ld: symbol(s) not found for architecture x86_64依赖库未导入 tableview遇到这种报错failed to obtain a cell from its dataSource是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了 可能原因： xib的cell没有注册 内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识 UIView-Encapsulated-Layout-Width 错误修改约束优先级即可解决 Swift 创建控制器时自带xib加载在iOS8崩溃的问题项目中有部分跟随控制器一起创建出来的xib，在iOS8之外的系统运行正常，在iOS8下崩溃，找不到对应关系，一番网上搜索，终于找到解决办法1234567override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123; super.init(nibName: &quot;AddressViewController&quot;, bundle: nil)&#125;required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125; 原来在iOS8下，也需要给控制器的xib重写一下init 方法，只记得在自定义view的是时候用过，没想到这里也需要，特意加上，算是兼容手机系统 ios开发中，xib加载view，loadNibNamed方法奔溃原因之一xib中某一属性在代码中已删除，但在xib中没有解除关联 -[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject];","text":"Xcode Bug自定义的代码片段存放位置1~/Library/Developer/Xcode/UserData/CodeSnippets Xcode 10 Multiple commands produce 报错解决1target &gt; Build phase &gt; Copy Bundle Resource/Compile Sources，删掉第三方库中重复的 README.txt，LICENSE，Info.plist 文件 工程文件乱序选中要整理的文件夹右键，点一下“Sort by Name”或者“Sort by Type”即可排序。 项目打不开 Failed to load project at ‘’ “,incompatible project version打开 project.pbxproj 文件，修改 objectVersion = 48; 不知道填什么往低了填，或者在自己想买找 Xcode 不高亮123cd Library/Developer/Xcode/DerivedDatarm -rf ./*重新打开XCODE 打开Playground提示打开失败，找不到合适的devices1231. Quit Xcode2. Delete the folder /Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices. For example, in Terminal: rm -rf ~/Library/Developer/CoreSimulator/Devices3. In Terminal: killall -9 com.apple.CoreSimulator.CoreSimulatorService (or just reboot). OR Add a iOS8.0Device 碰到Xib加载不出来，什么什么工程文件找不到，请看看引用有没有，没有的话加上就好了！用Xcode 7.3打开一个Xcode 8创建的工程，编译时报错：xxx.storyboard(或者xxx.xib) The document “null” required Xcode 8.0 or later.点击xxx.storyboard(或者xxx.xib)时，弹出如图所示提示框。解决方法是以源码的方式打开xxx.storyboard(或者xxx.xib)，然后删除&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;这一行代码，就OK了。 程序报错pathForResource nil的情况，而项目命名有该资源可能没拷贝进bundle1Xcode -&gt; TARAGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 添加 ‘Could not instantiate class named xxx’比如 ‘Could not instantiate class named WKWebView’ 解决方法1Xcode -&gt; TARAGETS -&gt; General -&gt; Linked Frameworks and Librarier ，点击“+”号添加相应的系统库 webkit.framework 添加新字体， info.plist也配置好了，就是无效请检查 TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources 中是否添加此资源 其他添加资源后无效也可参考此条解决方案 ld: library not found for -lxxx:类似出现上面这种问题(我的问题出现在libWeChatSDK这个包) ld:library not found for -lXXX 的问题有可能是你的某个库的连接引用有问题, —–解决的办法就是在项目的target里,选中Link Binary With Libraries 里的.a或framework 取消再加入,就可以了 —–如果是拖拽进入工程的,那就删除,在拖一次. ld: symbol(s) not found for architecture x86_64依赖库未导入 tableview遇到这种报错failed to obtain a cell from its dataSource是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了 可能原因： xib的cell没有注册 内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识 UIView-Encapsulated-Layout-Width 错误修改约束优先级即可解决 Swift 创建控制器时自带xib加载在iOS8崩溃的问题项目中有部分跟随控制器一起创建出来的xib，在iOS8之外的系统运行正常，在iOS8下崩溃，找不到对应关系，一番网上搜索，终于找到解决办法1234567override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123; super.init(nibName: &quot;AddressViewController&quot;, bundle: nil)&#125;required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125; 原来在iOS8下，也需要给控制器的xib重写一下init 方法，只记得在自定义view的是时候用过，没想到这里也需要，特意加上，算是兼容手机系统 ios开发中，xib加载view，loadNibNamed方法奔溃原因之一xib中某一属性在代码中已删除，但在xib中没有解除关联 -[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject]; 添加了一个All Exceptions 出现停在线程队列的情况，点继续运行仍然可以运行，将该断点删除或者将里面的All改成Object-C也可以！ios7下面用autolayout报错类似 *** Assertion failure in -[XXX layoutSublayersOfLayer:], /SourceCache/UIKit/UIKit-2935.138/UIView.解决方案：在布局之后 加上 [super layoutsubviews] [self lauoutifneed] 这两个方法。 there was an internal api error “—- xcode7，解决: bulid settings -&gt; packaging -&gt; product name 不要写中文。。。。 linker command failed with exit code 1 (use -v to see invocation) 检查是否重复引用，或者依赖引用.h 检查某个属性是否重复定义 检查是否 import 错误，把 .m 引入了 555 查看报错信息详情，一般都会提示，观察一下重复引用的两个文件名，分析即可","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://kysonyangs.github.io/tags/Bug/"}]},{"title":"iOS国际化","slug":"16-04 iOS国际化","date":"2016-04-11T06:55:52.000Z","updated":"2018-09-10T07:30:26.659Z","comments":true,"path":"iOS/16-04 iOS国际化/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 iOS国际化/","excerpt":"一、应用名称国际化 1.ctrl+n 创建一个.strings文件，如图","text":"一、应用名称国际化 1.ctrl+n 创建一个.strings文件，如图 2.选中InfoPlist.strings， 点击Localization中的Localized…按钮，选则English 3.选择Project -&gt; Localization，添加Chinese,如图 最后，在InfoPlist.strings(English)添加：CFBundleDisplayName = “Internationlization”; 在InfoPlist.strings(Chineses)添加：CFBundleDisplayName = “国际化”; 即可，你可以在模拟器切换English和中文设置查看效果 二、应用名称国际化 在InfoPlist.strings(English)添加：”key” = “test”; 在InfoPlist.strings(Chineses)添加：”key” = “测试”; 在代码添加1self.title = NSLocalizedStringFromTable(@&quot;key&quot;, @&quot;InfoPlist&quot;, @&quot;&quot;); 三、Xib/StoryBoard 1.选中Main.storyboard,打开文件选择器，勾选Localization下面的base\\chinese\\english 2.在storyboard拖一个Label,在如图所示的地方了看到他的ID","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"Xcode插件备忘","slug":"16-04 Xcode插件备忘","date":"2016-04-11T06:44:00.000Z","updated":"2018-09-10T07:38:09.906Z","comments":true,"path":"Xcode/16-04 Xcode插件备忘/","link":"","permalink":"https://kysonyangs.github.io/Xcode/16-04 Xcode插件备忘/","excerpt":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter）","text":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter） 常用插件以及用法：1.Alcatraz: 插件管理123456// 安装(mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins)curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh// 删除rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz 2.XcodeColors：给 Xcode 控制台添加颜色 用法见我以前写的一篇简书Xcode带颜色Log 当然这个插件与CocoaLumberjack是一对好基友，有兴趣的可以自行了解… 3.XToDo：这个插件可以给注释加书签类的功能，你可以随时跳转到你加此类注释的地方 添加 TODO 书签 – ⌃⇧T 添加 FIXME 书签 – ⌃⇧X 添加 ？？？ 书签 – ⌃⇧1 添加 ！！！ 书签 – ⌃⇧Q 书签窗口 – ⌃T 4.KSImageNamed：自动补全图片名5.Peckham：导入头文件 ⌘ + ctrl + P 然后选择你要导入的头文件即可 6.FuzzyAutocomplete：自动补全，提升编写效率7.CodePilot: 便捷查找你所需要的文件，代码… ⌘ + shift + X 输入你需要查找的内容即可 8.HOStringSense：很方便的编写大段文本9.XcodeBoost: 功能十分强大也十分方便，具体请进github自行观看10.SCXcodeMiniMap: 给Xcode创建一个迷你地图11.XAlign：对齐代码 选中你需要对齐的代码 – ⌘ + shift + Z 12.VVDocumenter: 规范化注释插件 -&gt; /// – 快捷键13.BBUDebuggerTuckAway: 自动隐藏底部的调试栏14.Backlight：高亮当前正在编辑的那一行15.xcode语法高亮插件16.ColorSense: 可视化颜色17.[SCXcodeSwitchExpander(https://github.com/stefanceriu/SCXcodeSwitchExpander):switch枚举的时候会自动生成代码 补充一点很实用的东东1.插件目录： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/2.当Xcode升级版本，然后插件失效后：12341.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID2.然后输入如下命令 【最后一项是获取到的DVTPlugInCompatibilityUUID】 find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add 9F75337B-21B4-4ADC-B558-F9CADF7073A7 3.playground无效，可能是误删模拟器的类型，重置12rm -rf ~/Library/Developer/CoreSimulator/Devices killall -9 com.apple.CoreSimulator.CoreSimulatorService 神一般的插件 injectionforxcode 安装插件使用Alcatraz插件管理器直接安装injectionforxcode-Github地址当你看到红框里面的东西有了之后说明，插件安装成功了！ 使用在Controller添加以下方法 123456789// OC- (void)injected&#123; NSLog(@&quot;I&apos;ve been injected: %@&quot;, self);&#125;// Swiftfunc injected() &#123; print(&quot;I&apos;ve been injected: \\(self)&quot;)&#125; ctrl + = 看一下你的控制台有没有输出 I’ve been injected 有了说明成功了 在 injected 方法中加入你要修改的UI代码，按下 ctrl + = 你可以看到模拟器界面的变化 或者按下 ctrl + shift + = 这个可以不用将代码写在injected 方法中，他会重新运行一遍你的程序，而不是单个Controller","categories":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/categories/Xcode/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://kysonyangs.github.io/tags/插件/"}]},{"title":"终端操作","slug":"终端操作","date":"2016-04-11T06:13:48.000Z","updated":"2018-09-10T08:06:51.741Z","comments":true,"path":"default/终端操作/","link":"","permalink":"https://kysonyangs.github.io/default/终端操作/","excerpt":"","text":"Mac复制粘贴无效解决1234launchctl list | grep com.apple.pboardlaunchctl stop com.apple.pboardlaunchctl start com.apple.pboard 解决Alfred每次开机后，都会提示“是否允许访问通讯录”1sudo codesign -f -d -s - /Applications/Alfred\\ 3.app/Contents/Frameworks/Alfred\\ Framework.framework/Versions/A/Alfred\\ Framework 终端设置别名 首先，你的别名得不存在，在终端输入你想要设置的别名，提示不能找到命令，则别名不存在，我们可以放心使用。 alias可以查看当前已设置的所有的别名 永久化的别名设置123456vim ~/.bash_profile// 在最下面添加你想要设置的别名，比如alias cdg=&quot;cd ~/Desktop/GG&quot;// 然后 wq保存退出，在终端输入source ~/.bash_profile// 现在，你可以使用你设置的别名了 修改终端前面的显示 修改终端的显示成 省略前面的电脑名 终端输入open /etc 找到bashrc-&gt;显示简介-&gt;将只读改成读与写，配置完成后改回去 终端输入sudo vim /etc/bashrc 找到PS1=’\\h:\\W \\u\\$ ‘，将其注释掉（为了备份） 换行添加PS1=’ \\W \\u\\$’，OK！！！","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"iOS数据库操作的常用SQL语句","slug":"16-04 iOS数据库操作的常用SQL语句","date":"2016-04-09T13:48:07.000Z","updated":"2018-06-20T02:20:08.822Z","comments":true,"path":"iOS/16-04 iOS数据库操作的常用SQL语句/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 iOS数据库操作的常用SQL语句/","excerpt":"前提：之前项目中使用SQLite数据库进行数据的储存，所以用到的SQL语句还是蛮多的，在此，记录一下常用的吧。 创建表","text":"前提：之前项目中使用SQLite数据库进行数据的储存，所以用到的SQL语句还是蛮多的，在此，记录一下常用的吧。 创建表 12345CREATE TABLE IF NOT EXISTS KL_Test (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,name TEXT,age INTEGER); 删除表 1DROP TABLE KL_Test; 增 1INSERT INTO KL_Test (name, age) VALUES (&apos;kellen&apos;, 22); 删 12DELETE FROM KL_Test WHERE id = 1;DELETE FROM KL_Test WHERE name = &apos;kellen&apos;; 改 12UPDATE KL_Test SET name = &apos;yangs&apos;, age = 30 WHERE id = 1;UPDATE KL_Test SET age = 60 WHERE name = &apos;yangs&apos;; 查 123456789101112131415// 1. 查询所有的字段SELECT * FROM KL_Test;// 2. 查询指定的字段SELECT name FROM KL_Test;// 3. 根据查询条件进行查询（一般用来判断是否存在）SELECT name FROM KL_Test WHERE age = 22;// 4. &lt; / &gt;SELECT name FROM KL_Test WHERE age &lt; 22;// 5. 查询所有记录的所有字段，根据 age 升序排序SELECT * FROM KL_Test ORDER BY age;// 6. 查询所有记录的所有字段， 根据 age 降序排序SELECT * FROM KL_Test ORDER BY age DESC;// 7. 使用多个字段排序，先按age降序排序，当age相同再根据name降序排序SELECT * FROM KL_Test ORDER BY age DESC,name DESC;... 贴一下当年写的使用FMDB的类吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &quot;DBManager.h&quot;#import &quot;FMDatabase.h&quot;@interface DBManager ()&#123; FMDatabase *_fmdb;&#125;+(id)sharedManager;@implementation DBManager- (instancetype)init&#123; self = [super init]; if (self) &#123; NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;]stringByAppendingPathComponent:@&quot;myapp.db&quot;]; _fmdb = [[FMDatabase alloc]initWithPath:path]; if ([_fmdb open]) &#123; NSString *sql = @&quot;create table if not exists myapp(id integer primary key autoincrement,appid varchar(64),appname varchar(128),iconurl varchar(1024))&quot;; [_fmdb executeUpdate:sql]; &#125; &#125; return self;&#125;+(id)sharedManager&#123; static DBManager *_m = nil; if (!_m) &#123; _m = [[DBManager alloc]init]; &#125; return _m;&#125;// 判断是否存在，根据appid来判断-(BOOL)isExists:(NSString *)appid&#123; NSString *sql = @&quot;select appid from myapp where appid = ?&quot;; FMResultSet *set = [_fmdb executeQuery:sql,appid]; if ([set next]) &#123; return YES; &#125; return NO;&#125;// 查询所有的数据，并返回-(NSMutableArray *)fetchAll&#123; NSMutableArray *array = [NSMutableArray array]; NSString *sql = @&quot;select * from myapp&quot;; FMResultSet *set = [_fmdb executeQuery:sql]; while ([set next]) &#123; DetailModel *model = [[DetailModel alloc]init]; model.applicationId = [set stringForColumn:@&quot;appid&quot;]; model.name = [set stringForColumn:@&quot;appname&quot;]; model.iconUrl = [set stringForColumn:@&quot;iconurl&quot;]; [array addObject:model]; &#125; return array;&#125;// 插入一个模型-(void)insertModel:(DetailModel *)model&#123; NSString *sql = @&quot;insert into myapp(appid,appname,iconurl) values(?,?,?)&quot;; [_fmdb executeUpdate:sql,model.applicationId,model.name,model.iconUrl];&#125;// 删除一个模型-(void)deleteModel:(DetailModel *)model&#123; NSString *sql = @&quot;delete from myapp where appid = ?&quot;; [_fmdb executeUpdate:sql,model.applicationId];&#125;// 开启事务-(void)beginTransactionY&#123; if (![_fmdb inTransaction]) &#123; [_fmdb beginTransaction]; &#125;&#125;// 处理完成，提交-(void)commitY&#123; if ([_fmdb inTransaction]) &#123; [_fmdb commit]; &#125;&#125;// 因某些操作退出，未完成提交， 回滚-(void)rollbackY&#123; if ([_fmdb inTransaction]) &#123; [_fmdb rollback]; &#125;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"FMDB数据库","slug":"FMDB数据库","permalink":"https://kysonyangs.github.io/tags/FMDB数据库/"}]},{"title":"GCD理解-二","slug":"16-03 GCD理解-二","date":"2016-03-22T10:10:53.000Z","updated":"2018-08-30T03:12:07.401Z","comments":true,"path":"iOS/16-03 GCD理解-二/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 GCD理解-二/","excerpt":"GCD理解（一）GCD理解（二） 代码下载 dispatch_group dispatch_group_notify监听dispatch_queue中所有的任务执行完成，执行某些操作","text":"GCD理解（一）GCD理解（二） 代码下载 dispatch_group dispatch_group_notify监听dispatch_queue中所有的任务执行完成，执行某些操作 1234567891011121314151617dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, self.concurrentQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;1 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 1111&quot;);dispatch_group_async(group, self.serialQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;2 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 2222&quot;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 任务全部完成处理 NSLog(@&quot;组内任务全部完成，请检验...&quot;);&#125;); enter &amp;&amp; levep dispatch_group_enter(group); 进入组 dispatch_group_leave(group); 离开组 dispatch_group_wait(group, DISPATCH_TIME_FOREVER);(等待组内任务完成)12345678910111213141516171819dispatch_group_t group = dispatch_group_create();for (int i = 0; i &lt; 3; i++) &#123; dispatch_group_enter(group); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;进入第%zd个异步 sleep 3秒&quot;, i); sleep(3); NSLog(@&quot;离开第%zd个异步 sleep 完成&quot;, i); dispatch_group_leave(group); &#125;);&#125;// 1 -----dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);&#125;);// // 2 ------ 1/2 任选1// dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);// &#125;); GCD-信号量 dispatch_semaphore dispatch_semaphore_create() dispatch_semaphore_signal() dispatch_semaphore_wait() dispatch_semaphore_create(long value)传入的参数为 long 类型，输出一个 dispatch_semaphore_t 类型且值为 value 的信号量。值得注意的是，这里的传入的参数 value 必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。 dispatch_semaphore_signal(dispatch_semaphore_t dsema)这个函数会使传入的信号量 dsema 的值加1, 返回值为 long 类型 当返回值为 0 时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加 1 即可。 当返回值 不为0 时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。 dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)这个函数会使传入的信号量 dsema 的值减 1； 如果 dsema 信号量的值大于 0，该函数所处线程就继续执行下面的语句，并且将信号量的值减 1 如果 desema 的值为 0，那么这个函数就阻塞当前线程等待 timeout（注意 timeout 的类型为 dispatch_time_t，不能直接传入整形或 float 型数），如果等待的期间 desema 的值被 dispatch_semaphore_signal 函数加 1 了，且该函数（即 dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为 0，那么等到 timeout 时，其所处线程自动执行其后语句。 在设置 timeout 时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。 DISPATCH_TIME_NOW表示当前； DISPATCH_TIME_FOREVER表示遥远的未来；一般可以直接设置 timeout 为这两个宏其中的一个， 创建一个 dispatch_time_t类型的变量。创建 dispatch_time_t 类型的变量有两种方法，dispatch_time 和 dispatch_walltime。利用创建 dispatch_time 创建 dispatch_time_t 类型变量的时候一般也会用到这两个变量 dispatch_time 的声明如下：dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)；其参数 when 需传入一个 dispatch_time_t 类型的变量，和一个 delta 值。表示 when加delta 时间就是 timeout 的时间。例如：dispatch_time_t t = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); 表示当前时间向后延时一秒为 timeout 的时间。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://kysonyangs.github.io/tags/GCD/"}]},{"title":"GCD理解-一","slug":"16-03 GCD理解-一","date":"2016-03-22T07:10:53.000Z","updated":"2018-06-20T02:19:21.940Z","comments":true,"path":"iOS/16-03 GCD理解-一/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 GCD理解-一/","excerpt":"GCD理解（一）GCD理解（二）代码下载 ####Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。*","text":"GCD理解（一）GCD理解（二）代码下载 ####Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。* 123456789// 一般用法dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i = 0; i &lt; 100000; i++) &#123; NSLog(@&quot;%zd&quot;, i); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新UI&quot;); &#125;); &#125;); 自定义队列 串行队列 同步运行 123456789101112dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现在for循环之后即dispatch_sync任务执行完之后，因为串行队列同步运行，阻塞主线程。// 在这里发现创建的线程和主线程地址相同，说明串行队列同步运行是直接在主线程中运行的！ 异步运行 1234567891011dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 并行队列 同步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 线程地址相同，且与主线程队列地址相同，// 结合串行队列同步运行与串行队列异步运行结果来看，同步运行时线程都是在主线程上运行，不开辟新的线程。// 运行结果与串行队列同步运行相同 异步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 输出结构乱序，因为是并行的异步执行，// 不能决定谁先谁后，且发现线程地址不同，说明开了多条线程执行队列，// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 总结: dispatch_sync 并不会开辟新的线程执行任务，所以不管是串行队列还是并行队列其实都在一个线程(mainQueue也在主线程)中运行，且它是同步的，所以阻塞主线程，一定得队列任务完成之后才会执行之后的任务！ dispatch_async 会异步的运行队列任务，但是串行队列只在一个线程中，所以只是不阻塞主线程，但是还是遵行串行队列FIFO(先进先出)执行任务， 而并行队列会开多条线程进行异步执行任务，效率更高！ dispatch_barrier在 dispatch_barrier 之后的任务总是会在 dispatch_barrier 之前的任务执行完之后在执行 dispatch_barrier_sync 1234567891011121314151617181920212223for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_1_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_sync(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_sync %zd&quot;,[NSThread currentThread], i); if (i == 4) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;);&#125;NSLog(@&quot;dispatch_barrier_sync_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_2_main&quot;);// 结果分析 先并发异步执行 dispatch_async_1, // 在执行 dispatch_barrier_sync ,最后并发异步执行 dispatch_async_2, dispatch_barrier_sync 会阻塞主线程 dispatch_barrier_async 12345678910111213141516171819202122232425for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_1_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_async %zd&quot;,[NSThread currentThread], i); if (i == 2) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;); &#125; NSLog(@&quot;dispatch_barrier_sync_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_2_main&quot;); // 结果分析: 首先它仍然会阻拦 dispatch_barrier_async 之后的任务等之前任务执行完之后再执行， // 其次他由于是异步的所以不阻塞主线程， // 但是我发现 `dispatch_barrier_async`里面执行的认为在一条线程中执行，且按顺序执行的！ // 所以我们做耗时操作的时候尽量不要放在`dispatch_barrier_async`中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列啊！ 注意： dispatch_barrier 不要用在global queue 中，因为 dispatch_barrier 只使用在一条并行队列中，而global queue 是每次系统分配一个并行队列(可能是不同的)，所以没有意义！ dispatch_barrier_async里面执行的认为在一条线程中执行，且按顺序执行的！所以我们做耗时操作的时候尽量不要放在dispatch_barrier_async中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列！ NSDictionary: 线程安全, 但是NSMutableDictionary: 不是线程安全的，所以我们可以使用 dispatch_barrier_async 来保证 NSMutableDictionary 线程安全!(Get&amp;&amp;Set) dispatch_semaphone: 信号量(用于并发控制) dispatch_semaphore_create(3) 创建信号量，传入一个大于等于0的long型整数(比作停车位，有了停车位才能停车) dispatch_semaphore_signal(semaphone) 传入一个信号量，执行一次，增加一次semaphone计数(可以这么理解: 一辆车开走了，然后这个停车位就空出来了，算作增加一个停车位); 返回值为0时表示当前并没有线程等待其处理的信号量; 返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程(优先级高的先被唤醒，否则随机) dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 5)); 每运行一次，semaphone计数-1，如果semaphone计数为0，那么根据传入的等待时间等待，如果等待时间设置为DISPATCH_TIME_FOREVER,那么就永远等待，永远不会执行之后的了， 除非信号量计数&gt;1了! (可以这么理解: 在这里判断是否有停车位剩余，如果有就停车，没有的话就等待车位空出再停车，如果超出等待时间，这个人就等不下去了，开车走了); 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句 1234567891011121314// sample1:dispatch_semaphore_t semaphone = dispatch_semaphore_create(2); for (int i = 0; i &lt; 10; i++) &#123; if(dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 2 *NSEC_PER_SEC)) == 0) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;i will sleep 3 second %zd&quot;, i); sleep(3); NSLog(@&quot;i am wake up %zd&quot;, i); NSLog(@&quot;%zd signal %ld&quot;,i, dispatch_semaphore_signal(semaphone)); &#125;); &#125;else&#123; NSLog(@&quot;等不下去了，走人&quot;); &#125; &#125; 123456789101112// sample2:dispatch_semaphore_t semaphone = dispatch_semaphore_create(0);NSLog(@&quot;Boss: Kellen, wake up! working&quot;);dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;Kellen: I am sleep!&quot;); sleep(5); NSLog(@&quot;Kellen: I am wake up!&quot;); dispatch_semaphore_signal(semaphone);&#125;); dispatch_semaphore_wait(semaphone, DISPATCH_TIME_FOREVER);NSLog(@&quot;Kellen: I am working...&quot;);// 等待执行 NSLog(@&quot;Kellen: I am working...&quot;); 以上两种方案的话 看你情况使用！(信号量设为0 ,!0) 貌似写的有点多了，另起一篇吧！！！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://kysonyangs.github.io/tags/GCD/"}]},{"title":"CoreAniamtion学习四","slug":"16-03 CoreAnimation四","date":"2016-03-09T07:10:53.000Z","updated":"2018-06-20T02:18:58.898Z","comments":true,"path":"iOS/16-03 CoreAnimation四/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation四/","excerpt":"显式动画 CABasicAnimation(基本动画)123456789101112CABasicAnimation *basicA = [CABasicAnimation animation];basicA.keyPath = @&quot;backgroundColor&quot;;basicA.toValue = (__bridge id _Nullable)(color.CGColor);basicA.delegate = self;basicA.duration = 1.0;[self.layerView.layer addAnimation:basicA forKey:nil];// 代理，监听动画完成，还有个动画开始的监听- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag &#123; NSLog(@&quot;animation end&quot;); self.layerView.layer.backgroundColor = (__bridge CGColorRef _Nullable)(anim.toValue);&#125;","text":"显式动画 CABasicAnimation(基本动画)123456789101112CABasicAnimation *basicA = [CABasicAnimation animation];basicA.keyPath = @&quot;backgroundColor&quot;;basicA.toValue = (__bridge id _Nullable)(color.CGColor);basicA.delegate = self;basicA.duration = 1.0;[self.layerView.layer addAnimation:basicA forKey:nil];// 代理，监听动画完成，还有个动画开始的监听- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag &#123; NSLog(@&quot;animation end&quot;); self.layerView.layer.backgroundColor = (__bridge CGColorRef _Nullable)(anim.toValue);&#125; CAKeyframeAnimation (关键帧动画)不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。123456789CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;backgroundColor&quot;;animation.duration = 2.0;animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];[self.layerView.layer addAnimation:animation forKey:nil]; 123456789UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;position&quot;;animation.duration = 4.0;animation.path = bezierPath.CGPath;animation.rotationMode = kCAAnimationRotateAuto;[shipLayer addAnimation:animation forKey:nil]; 动画组CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起。 12345678910111213141516171819202122232425262728293031UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];//draw the path using a CAShapeLayerCAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.path = bezierPath.CGPath;pathLayer.fillColor = [UIColor clearColor].CGColor;pathLayer.strokeColor = [UIColor redColor].CGColor;pathLayer.lineWidth = 3.0f;[self.view.layer addSublayer:pathLayer];//add a colored layerCALayer *colorLayer = [CALayer layer];colorLayer.frame = CGRectMake(0, 0, 64, 64);colorLayer.position = CGPointMake(0, 150);colorLayer.backgroundColor = [UIColor greenColor].CGColor;[self.view.layer addSublayer:colorLayer];//create the position animationCAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];animation1.keyPath = @&quot;position&quot;;animation1.path = bezierPath.CGPath;animation1.rotationMode = kCAAnimationRotateAuto;//create the color animationCABasicAnimation *animation2 = [CABasicAnimation animation];animation2.keyPath = @&quot;backgroundColor&quot;;animation2.toValue = (__bridge id)[UIColor redColor].CGColor;//create group animationCAAnimationGroup *groupAnimation = [CAAnimationGroup animation];groupAnimation.animations = @[animation1, animation2];groupAnimation.duration = 4.0;//add the animation to the color layer[colorLayer addAnimation:groupAnimation forKey:nil]; 过度动画属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。 1234567891011121314151617181920212223type值:kCATransitionFade, // 平滑过渡kCATransitionMoveIn,kCATransitionMoveIn,kCATransitionReveal,subtype值: 控制方向kCATransitionFromRight，kCATransitionFromLeft，kCATransitionFromTop,kCATransitionFromBottomCATransition *transition = [CATransition animation];transition.type = kCATransitionFade;[self.imgv.layer addAnimation:transition forKey:nil];UIImage *currentImage = self.imgv.image;NSUInteger index = [arr indexOfObject:currentImage];index = (index + 1) % [arr count];self.imgv.image = arr[index];// 过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。// 但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，// 因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习三","slug":"16-03 CoreAnimation三","date":"2016-03-09T03:10:53.000Z","updated":"2018-08-30T05:40:12.083Z","comments":true,"path":"iOS/16-03 CoreAnimation三/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation三/","excerpt":"隐式动画就是当你改变某个属性是时，他会自动平滑的过渡到新的值。而你不需要去开启动画。比如： CALayer的backgroundColor 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。","text":"隐式动画就是当你改变某个属性是时，他会自动平滑的过渡到新的值。而你不需要去开启动画。比如： CALayer的backgroundColor 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。 123456789101112131415161718// 使用事务改变执行时间（默认 0.25s）[CATransaction begin];(入栈)[CATransaction setAnimationDuration:1.0];// 完成之后在旋转90度(0.25s完成)[CATransaction setCompletionBlock:^&#123; NSLog(@&quot;改变颜色完成，开始旋转&quot;); 在颜色改变之后(入栈) CGAffineTransform transform = self.colorLayer.affineTransform; self.colorLayer.affineTransform = CGAffineTransformRotate(transform, M_PI_2); (出栈)&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;[CATransaction commit];(出栈) 你也可以改变隐式动画的行为（如何渐变）12345 // 行为CATransition *transition = [CATransition animation];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;self.colorLayer.actions = @&#123;@&quot;backgroundColor&quot;: transition&#125;; 但是你把上述的self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;改成self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;你会发现它是瞬间改变的，而不是平滑的动画。因为隐式动画被UIView关联图层给禁了！因为处理UIView动画用UIView的动画函数，而不依赖CATransaction。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习二","slug":"16-03 CoreAnimation二","date":"2016-03-08T13:10:53.000Z","updated":"2018-06-20T02:18:50.714Z","comments":true,"path":"iOS/16-03 CoreAnimation二/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation二/","excerpt":"CAShapeLayer 渲染快，高效实用内存，不会被图层边界剪裁掉，不会出现像素化 一般用CGPath来绘制形状12345678910111213141516171819202122UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(200, 100)]; // 绘制圆[path addArcWithCenter:CGPointMake(170, 100) radius:30 startAngle:0 endAngle:2*M_PI clockwise:YES];// 绘制线条[path moveToPoint:CGPointMake(150, 125)];[path addLineToPoint:CGPointMake(150, 175)];// 绘制，展示CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor clearColor].CGColor;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinRound;shapeLayer.lineCap = kCALineCapRound;shapeLayer.path = path.CGPath;[self.view.layer addSublayer:shapeLayer];// 再提一个 绘制圆角(可选4角)CGRect rect = CGRectMake(50, 50, 100, 100);CGSize radii = CGSizeMake(20, 20);UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];","text":"CAShapeLayer 渲染快，高效实用内存，不会被图层边界剪裁掉，不会出现像素化 一般用CGPath来绘制形状12345678910111213141516171819202122UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(200, 100)]; // 绘制圆[path addArcWithCenter:CGPointMake(170, 100) radius:30 startAngle:0 endAngle:2*M_PI clockwise:YES];// 绘制线条[path moveToPoint:CGPointMake(150, 125)];[path addLineToPoint:CGPointMake(150, 175)];// 绘制，展示CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor clearColor].CGColor;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinRound;shapeLayer.lineCap = kCALineCapRound;shapeLayer.path = path.CGPath;[self.view.layer addSublayer:shapeLayer];// 再提一个 绘制圆角(可选4角)CGRect rect = CGRectMake(50, 50, 100, 100);CGSize radii = CGSizeMake(20, 20);UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii]; CATextLabel: 图层的形式包含了UILabel几乎所有的绘制特性，而且比UILabel渲染的更快哦！(如果你有需求做一个自定制的Label,不防试试这个) 1234567891011121314151617181920212223242526272829303132333435363738CATextLayer *textLayel = [CATextLayer layer]; textLayel.frame = CGRectMake(100, 100, 200, 300); [self.view.layer addSublayer:textLayel]; textLayel.foregroundColor = [UIColor blackColor].CGColor; textLayel.backgroundColor = [UIColor orangeColor].CGColor; textLayel.alignmentMode = @&quot;justified&quot;; textLayel.wrapped = YES; UIFont *font = [UIFont systemFontOfSize:17]; CFStringRef fontName = (__bridge CFStringRef)(font.fontName); CGFontRef fontRef = CGFontCreateWithFontName(fontName); textLayel.font = fontRef; textLayel.fontSize = font.pointSize; /** * 分辨率 */ textLayel.contentsScale = [UIScreen mainScreen].scale; CGFontRelease(fontRef); NSString *text = @&quot;Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy!&quot;; NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:text]; //set text attributes NSDictionary *attribs = @&#123; NSForegroundColorAttributeName : [UIColor blackColor], NSFontAttributeName : font &#125;; [string setAttributes:attribs range:NSMakeRange(0, [text length])]; attribs = @&#123;NSForegroundColorAttributeName : [UIColor redColor]&#125;; [string setAttributes:attribs range:NSMakeRange(6, 5)]; textLayel.string = string; CAGradientLayer : 处理颜色渐变 1234567CAGradientLayer *gradientLayer = [CAGradientLayer layer];gradientLayer.frame = CGRectMake(100, 100, 100, 100);[self.view.layer addSublayer:gradientLayer];gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor blackColor].CGColor];gradientLayer.locations = @[@0,@0.5,@1];gradientLayer.startPoint = CGPointMake(0, 0);gradientLayer.endPoint = CGPointMake(1, 1); CAEmitterLayer : 粒子引擎(直播那些❤️动画之类的) 123456789101112131415161718192021222324252627282930313233343536373839404142CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];// 发射器在xy平面的中心位置emitterLayer.emitterPosition = CGPointMake(self.view.frame.size.width-50,self.view.frame.size.height-50);// 发射器的尺寸大小emitterLayer.emitterSize = CGSizeMake(20, 20);// 渲染模式emitterLayer.renderMode = kCAEmitterLayerUnordered;// 开启三维效果// _emitterLayer.preservesDepth = YES;NSMutableArray *array = [NSMutableArray array];// 创建粒子for (int i = 0; i&lt;10; i++) &#123; // 发射单元 CAEmitterCell *stepCell = [CAEmitterCell emitterCell]; // 粒子的创建速率，默认为1/s stepCell.birthRate = 1; // 粒子存活时间 stepCell.lifetime = arc4random_uniform(4) + 1; // 粒子的生存时间容差 stepCell.lifetimeRange = 1.5; // 颜色 // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]]; // 粒子显示的内容 stepCell.contents = (id)[image CGImage]; // 粒子的名字 // [fire setName:@&quot;step%d&quot;, i]; // 粒子的运动速度 stepCell.velocity = arc4random_uniform(100) + 100; // 粒子速度的容差 stepCell.velocityRange = 80; // 粒子在xy平面的发射角度 stepCell.emissionLongitude = M_PI+M_PI_2;; // 粒子发射角度的容差 stepCell.emissionRange = M_PI_2/6; // 缩放比例 stepCell.scale = 0.3; [array addObject:stepCell];&#125;emitterLayer.emitterCells = array;[self.view.layer addSublayer:emitterLayer];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习一","slug":"16-03 CoreAnimation一","date":"2016-03-08T11:10:53.000Z","updated":"2018-08-30T05:39:33.522Z","comments":true,"path":"iOS/16-03 CoreAnimation一/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation一/","excerpt":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);","text":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage); @property(copy) NSString *contentsGravity; : 类似于UIView的contentMode 123456789101112kCAGravityCenterkCAGravityTopkCAGravityBottomkCAGravityLeftkCAGravityRightkCAGravityTopLeftkCAGravityTopRightkCAGravityBottomLeftkCAGravityBottomRightkCAGravityResizekCAGravityResizeAspectkCAGravityResizeAspectFill @property BOOL masksToBounds; : 超出位置是否裁切 @property CGRect contentsRect;这个属性决定图片的显示位置，默认是{0，0，1，1}从左上角到左下角显示，你也可以设为其他的,前两个是起点比例，后两个分别对应宽度和高度比例(该属性一般用于给你一张有许多小图的大图，然后你根据自己的需要去拿你需要的图片) @property CGRect contentsCenter; : 类似于UIImage resizableImageWithCapInsets 属性！ @property CGPoint position; : 类似于UIView的Center， 但是它作用的也是UIView的Center而不是Layer的Center哦 @property CGPoint anchorPoint; : 我的理解是layer中心点的位置，默认为{0.5，0.5}，所以居中显示，但是将它设置为{0，0}，那么layer会以{0，0}为中心点显示哦！这时position没变哦！ @property CGFloat zPosition; @property CGFloat anchorPointZ;由于CALayer是存在于3维空间中的，所以我们可以改变他的z轴(你可以理解为Z轴就是垂直严你的屏幕的轴) @property CGFloat cornerRadius; : 圆角半径(我们一般给视图做圆角的时候，如果界面不是太多，可以使用该方法，但是如果是对Cell里面的视图进行圆角设置或者太多视图需要进行圆角设置，就别用这个属性了，因为layer的渲染会耗资源) @property CGFloat borderWidth; @property(nullable) CGColorRef borderColor;边框的Width和颜色，不必多说 @property CGFloat shadowRadius; 阴影模糊度关于阴影的一些属性，建议如cornerRadius一样，使用阴影的时候别用maskToBounds哦！因为阴影在范围外，使用了会被裁剪掉哦！shadowPath @property(nullable) CGColorRef shadowColor; 阴影颜色 @property float shadowOpacity; 阴影透明度 @property CGSize shadowOffset; 阴影偏移量 @property(nullable) CGPathRef shadowPath; 感觉该属性就是为了解决使用上述属性设置阴影好资源诞生的，推荐使用这个属性设置阴影哦！123456layerView.layer.shadowOpacity = 0.5;layerView.layer.shadowColor = [UIColor redColor].CGColor;layerView.layer.shadowOffset = CGSizeMake(10, 10);// layerView.layer.shadowPath = CGPathCreateWithRect(layerView.layer.bounds, NULL);// layerView.layer.shadowPath = CGPathCreateWithRoundedRect(layerView.layer.bounds, layerView.layer.bounds.size.width * 0.5, layerView.layer.bounds.size.width * 0.5, NULL); (void)setAffineTransform:(CGAffineTransform)m; 这个就是UIView的transform实现1234567891011CGAffineTransform 方法CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 移动CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 放缩CGAffineTransformMakeRotation(CGFloat angle) // 旋转CGAffineTransformIdentity // 复位，初始状态混合变换CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) // 在t的基础上移动CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) // 在t的基础上放缩CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) // 在t的基础上旋转注意： 旋转时使用的是弧度而不是角度，你可以利用下列公式转换角度到弧度#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) @property CATransform3D transform; 仿射变换 3D动画 12345CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz)CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)CATransform3D的 m34 元素, 用来做透视,m34用于按比例缩放X和Y的值来计算到底要离视角多远。 现在我想我们可以用他们来做一些动画了…","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"利用pod trunk发布程序","slug":"16-01 利用pod-trunk发布程序","date":"2016-01-20T07:07:56.000Z","updated":"2018-09-28T03:11:33.160Z","comments":true,"path":"iOS/16-01 利用pod-trunk发布程序/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-01 利用pod-trunk发布程序/","excerpt":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose","text":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: xxx- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec cretae 文件名 比如pod spec cretae KLTest 就会生成一个KLTest.podspec 填写podspec内容123456789101112Pod::Spec.new do |s| s.name = &quot;KLTest&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/xxx/KLTest&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;KL&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/xxx/KLTest.git&quot;, :tag =&gt; s.version &#125; s.source_files = &quot;KLTestExample/KLTestExample/KLTest&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint KLTest.podspec pod spec lint KLTest.podspec —allow-warnings 忽略所有警告 发布podspec pod trunk push KLTest.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.git","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"iOS数组排序","slug":"15-10 iOS数组排序","date":"2015-10-25T02:28:05.000Z","updated":"2018-08-30T05:36:04.509Z","comments":true,"path":"iOS/15-10 iOS数组排序/","link":"","permalink":"https://kysonyangs.github.io/iOS/15-10 iOS数组排序/","excerpt":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图","text":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图 在这里我们要注意的时，它排序的时候如果对于arrayString 来说，它是按字母书序排列的，而不是按照数字大小，这个要注意， arrayNumber 这个数组则没问题，如果你想要按照自己的规则来排序，可以自己写个方法，传到@selector() 里面就行 2、sortedArrayUsingComparator使用这个方法，我们可以在block里面写入自己定义的规则，实现起来也听方便的 123[arrayString sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; return [obj1 integerValue] &gt; [obj2 integerValue];&#125;] 现在就是正确的按照数字大小排序了，嘿嘿嘿~ 3、sortedArrayUsingDescriptors &amp; sortUsingDescriptors前者返回一个排好序的数组，后者则是对自身进行排序，无返回值~哲理我们讲一下前者的方法，不多说，上代码— 12345678910111213141516171819202122232425262728293031323334353637//首先我们定义一个类Person@interface Person : NSObject@property NSString *name;@property NSNumber *age;@end@implementation Person- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;name = %@, age = %@&quot;, self.name, self.age];&#125;@end//然后实例化一个Person数组NSArray *name = @[ @&quot;Allen&quot;, @&quot;Kellem&quot;, @&quot;God&quot;, @&quot;Queen&quot;, @&quot;King&quot;, @&quot;Bob&quot;];NSArray *ages = @[@8, @20, @9, @88, @70, @20];NSMutableArray *people = [NSMutableArray array];//这里是一个数组的遍历方法，建议大家使用这种方法进行数组的遍历[name enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; Person *person = [[Person alloc] init]; person.name = [name objectAtIndex:idx]; person.age = [ages objectAtIndex:idx]; [people addObject:person];&#125;];// 名字进行排序，降序规则，key可以传nil,或者&quot;self&quot;，在对如下数组排序时可用 NSArray *ages = @[@8, @20, @9, @88, @70, @20];//再多说一句，key 这里用到的类似KVC，其中理念自己体会 =-=NSSortDescriptor *nameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES];// 年龄进行排序，升序规则NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:NO];//然后使用规则进行排序，执行，打印// 这里规则是一个数组，你可以传入多个规则，例如3NSLog(@&quot;By age: %@&quot;, [people sortedArrayUsingDescriptors:@[ageSortDescriptor]]); NSLog(@&quot;By name name: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor]]);NSLog(@&quot;By name, age: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor, ageSortDescriptor]]); 结果如下图： 最后再体验一下其中的KVC奥妙，我们用字典来体验一下 123456789NSArray *dict =@[ @&#123;@&quot;age&quot;:@20&#125;, @&#123;@&quot;age&quot;:@5&#125;, @&#123;@&quot;age&quot;:@70&#125;, @&#123;@&quot;age&quot;:@33&#125;];NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:YES];NSArray *arr = [dict sortedArrayUsingDescriptors:@[sort]];NSLog(@&quot;%@&quot;,arr);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://kysonyangs.github.io/tags/数组/"}]},{"title":"三方库整理","slug":"- 三方库","date":"2015-03-02T16:00:00.000Z","updated":"2018-09-27T03:05:05.838Z","comments":true,"path":"整理/- 三方库/","link":"","permalink":"https://kysonyangs.github.io/整理/- 三方库/","excerpt":"","text":"OC&amp;Swift LSAnimator 用少量的代码实现复杂而又易于维护的动画。 JTCalendar 日历控件JTCalendar lottie-ios 动画库 PNChart 使用的简单而美观的图表库 简单的图表库-FSChartView CoreText OC KVOController facebook 开源的 KVOController，替代系统 KVO ASDK Texture Table高度自动适配 LBXScan 二维码、扫码、扫一扫、ZXing、ZBar、iOS系统AVFoundation扫码封装，扫码界面效果封装 DKNightVersion 更换主题 BabyBluetooth 一个非常容易使用的蓝牙库,适用于ios和os VKVideoPlayer 视频播放器 FLAnimatedImage iOS的高性能动画GIF引擎 TYAttributedLabel 属性文本控件，图文混排显示 CYLTabBarController【中国特色 TabBar】最低只需传两个数组即可完成主流App框架搭建 TZImagePickerController 支持多选、选原图和视频的图片选择器 GYDataCenter SQLite 替代方案 LunarCore 全功能农历日历库 XJYChart 图表 支持动画，点击，滚动，区域高亮 AAChartKit 极其精美而又强大的 iOS 图表组件库 ZFPlayer 支持定制任何播放器SDK和控制层 WMPlayer AVPlayer的封装，继承UIView MMDrawerController 侧拉菜单，封装十分完善！ Swift SwifterSwift Swift 扩展 ExSwift Swift 扩展 EZSwiftExtensions 标准类型和类扩展 SwiftString 全面轻量级字符串扩展 SwiftDate 管理日期和时区的最佳方法 DateTools 轻松实现日期和时间 Timepiece 日期扩展 KeychainAccess 钥匙串 SwiftyUserDefaults NSUserDefaults 扩展 DynamicColor 颜色扩展 XCGLogger Swift Log swiftScan 二维码 各种码识别，生成，界面效果 MonkeyKing 不用第三方分享微信/微博 Kanna HTML/XML解析 Fuzi HTML/XML解析 Ji HTML/XML解析 SwiftyJSON 处理JSON数据 handyjson alibaba 开源的模型解析库 SwiftyTimer NSTimer 易用扩展 ESTabBarController 高度自定制的Tabbar animated-tab-bar Tabbar 可动画 Then 初始化器的超甜语法糖 CVCalendar 自定义可视化日历 FSPagerView 轮播图 很多效果 SkyFloatingLabelTextField 浮标模式的TextField Localize-Swift 国际化 Disk 磁盘存储 FAPanels 左右侧边栏 NVActivityIndicatorView 多种 loading 动画 波纹动画","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"Mac工具整理","slug":"15-03 Mac工具","date":"2015-03-02T16:00:00.000Z","updated":"2018-09-26T05:24:15.881Z","comments":true,"path":"整理/15-03 Mac工具/","link":"","permalink":"https://kysonyangs.github.io/整理/15-03 Mac工具/","excerpt":"","text":"ss免费账号 效率工具 iTerm2 og-my-zsh Go2Shell: 在当前目录打开iTerm2 autojump Alfred 使用工具 Homebrew：Mac OS 的包管理工具，可以快速安装各种工具 Cakebrew：Homebrew的界面管理工具 LaunchRocket: 管理Homebrew安装的服务的软件,启动等。安装方法： 1brew cask install launchrocket libimobiledevice： 提供了很多与iOS交互的工具，例如端口映射查看日志 tree: 查看当前目录结构树的命令行工具，brew install tree 安装 010 Editor: 二进制分析工具 其他百度云盘文件下载 Aria2GUI dmg下载传送门 https://github.com/yangshun1029/aria2gui/releases （下载页面中的 zip 包） 安装浏览器百度网盘chrome插件，插件源码下载 iVideo: 一个可以观看国内主流视频平台所有视频的客户端IDEA工具激活 IDEA 注册码: http://idea.lanyus.com/ 社区分享: http://blog.csdn.net/xx1710/article/details/51725012 macOS Mojave 升级之后 oh-my-zsh 在终端下打开缓慢，清理终端 log 就会变快哦sudo rm -rf /private/var/log/asl/*.asl ​​​​","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"博客整理","slug":"15-03 博客&Git","date":"2015-03-02T16:00:00.000Z","updated":"2018-08-30T03:29:07.819Z","comments":true,"path":"整理/15-03 博客&Git/","link":"","permalink":"https://kysonyangs.github.io/整理/15-03 博客&Git/","excerpt":"","text":"GitHub Author GitHub iOS-Tips SwiftTips iOS沙龙 dev-blog LefexWork Halfrost-Field 冰霜之地 iOS 开发进阶之路 Blog OneV 戴铭 mrpeak 苹果核加入 WeRead isaced bestswifter RW 包含图文混排 Draveness’s Blog 玉令天下的博客 矢倉 臧成威 雷纯锋 南峰子 叶孤城 叶孤城, 优秀 iOS 开发工程师, 发表的文章都有很多干货, 对源码解析类文章写得浅显易懂, 并时常总结一些 iOS 开发技巧, 值得一读 100mango iOS, Swift, Objective-C 心得 new Kerwin 逆行云 网站 Swifter","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"开发工具","slug":"15-03 开发工具","date":"2015-03-02T16:00:00.000Z","updated":"2018-09-11T08:06:29.730Z","comments":true,"path":"整理/15-03 开发工具/","link":"","permalink":"https://kysonyangs.github.io/整理/15-03 开发工具/","excerpt":"","text":"软件包相关 LinkMap解析工具：检查项目中每个类或者库占用大小 LSUnusedResources工具：查找项目中没有使用的文件资源 Xcode 优化 FengNiao 猫神开源的 用于清理Xcode中未使用的资源的命令行工具。 SwiftGen 自动生成 Asset 的 image enum 的 Extension","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"性能监控与优化","slug":"- 性能监控与优化","date":"2015-03-02T16:00:00.000Z","updated":"2018-09-27T02:47:32.278Z","comments":true,"path":"整理/- 性能监控与优化/","link":"","permalink":"https://kysonyangs.github.io/整理/- 性能监控与优化/","excerpt":"","text":"1. 资源 GGTinypng 批量压缩png和jpg图片python脚本 tinypng网站 压缩单张 ImageOptim 无损压缩图片 检查项目中无用的图片 WHC_ScanUnreferenceImageTool python扫描没使用到的图片 LSUnusedResources 查找无用的图片文件 2. 代码 AppCode代码静态检查 Fui 查找发现无用文件, 清除无用的Import 删除无用的方法 查找相似代码 3. 性能 FLEX Flipboard团队开发的一款应用内Debug工具，可以很方便的查看和调整UI的层级关系。 OOMDetector 腾讯开源的 iOS的内存监视组件，它为您提供OOM监视，内存分配监视，内存泄漏检测和其他功能。 MLeaksFinder Tencent 开源的 iOS 平台的自动内存泄漏检测工具 iOS-Monitor-Platform iOS 性能监控 SDK —— Wedjat（华狄特）","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"开源项目整理","slug":"- 开源项目","date":"2015-03-02T16:00:00.000Z","updated":"2018-09-18T05:54:04.810Z","comments":true,"path":"整理/- 开源项目/","link":"","permalink":"https://kysonyangs.github.io/整理/- 开源项目/","excerpt":"","text":"GitHub 资源GitHubMac WWDC WWDC app for Mac OC kickstarter 开源的idle 正能量壁纸 MITO ZHNCosmos 别具一格的微博客户端 MONO 高仿MONO(猫弄) 斗鱼弹幕分析工具 Monkey GitHub 客户端 Coding-iOS Coding iOS 客户端 GitBucket GitBucket iOS App 仿面包旅行 仿面包旅行，ReactiveCocoa+MVVM YSRun 易瘦跑步 iOS客户端 服务器不可用 MiaowShow iOS视频直播项目 bilibili-fake 仿Bilibili iOS客户端 今日头条 二次元网易GACHA 高仿国美商城 Yuncai 一个 少数派 YReader 小说阅读 Dash-iOS Dash iOS客户端 Monkey Github客户端 Coding-iOS Coding iOS 客户端源代码 豆瓣妹子图iOS客户端 高仿微信 无接口只界面 音乐播放器 音乐播放器 天天动听 短视频 iOS新闻客户端 漫画阅读APP 百思不得姐 仿映客 BOSS 天气YoCelsius 仿Bilibili客户端 仿百度糯米 美团 蘑菇街 一个 Coding客户端 Git@OSC SegmentFault官方 猿已阅 微博客户端 IT江湖 Monkey Swift 喵播 OFO 喜马拉雅 TodayNews 高仿今日头条 Gank Gank客户端 Yep Yep 是一款非常小巧而轻量化的社交 App zhnbilibili swift精仿bilibili Gank TSWeChat WeChat高仿 BliBli Kickstarter 众筹App Yep社交App 日历 动画 Uber V2ex SwiftGG 跑步App 照片贴图PixPic youtube FOUR记忆 照片 知乎日报 知乎日报 CocoaChina swift版本拼图游戏 Dunk 斗鱼 最美应用 逗视 WeChat 豆瓣美女 HotGirls 随遇App 眼科行医手记 半糖 react-native 资讯头条 APP 一简(微博客户端) ReactApp explorer 嘎嘎商城 elements GitHub最受欢迎与最热项目 react-native-Gank","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]}]}