{"meta":{"title":"kysonyangs","subtitle":"Stay Hungry, Stay Foolish","description":"kysonyangs个人站，备忘","author":"kysonyangs","url":"https://kysonyangs.github.io"},"pages":[{"title":"","date":"2018-06-19T02:40:54.000Z","updated":"2018-06-20T02:06:23.137Z","comments":false,"path":"about/index.html","permalink":"https://kysonyangs.github.io/about/index.html","excerpt":"","text":"个人简介： KysonYangs iOSer 来自江西 现居上海 Email: kysonyangs@gmail.com"},{"title":"categories","date":"2018-06-19T02:34:25.000Z","updated":"2018-06-19T02:34:35.000Z","comments":false,"path":"categories/index.html","permalink":"https://kysonyangs.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-19T02:33:55.000Z","updated":"2018-06-19T02:34:15.000Z","comments":false,"path":"tags/index.html","permalink":"https://kysonyangs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"神一般的插件 injectionforxcode","slug":"16-07 插件-injectionforxcode","date":"2016-07-29T11:10:53.000Z","updated":"2018-06-20T02:21:26.560Z","comments":true,"path":"iOS/16-07 插件-injectionforxcode/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-07 插件-injectionforxcode/","excerpt":"虽然好几个月前就知道这款插件了，可是当时使用的时候报错，也搞不定为什么，所以无极而终！但是最近UI界面修改比较频繁，且前段时间刚好了解了一下React-Native,感觉实时刷新模拟器界面而不用重新Run项目是Realy爽啊，所以为了工作轻松一点，就又使用起来，这次成功了，而且使用起来十分方便，并且 太强大了啊！支持OC与Swift","text":"虽然好几个月前就知道这款插件了，可是当时使用的时候报错，也搞不定为什么，所以无极而终！但是最近UI界面修改比较频繁，且前段时间刚好了解了一下React-Native,感觉实时刷新模拟器界面而不用重新Run项目是Realy爽啊，所以为了工作轻松一点，就又使用起来，这次成功了，而且使用起来十分方便，并且 太强大了啊！支持OC与Swift 安装插件使用Alcatraz插件管理器直接安装injectionforxcode-Github地址当你看到红框里面的东西有了之后说明，插件安装成功了！ 使用在Controller添加以下方法 123456789// OC- (void)injected&#123; NSLog(@&quot;I&apos;ve been injected: %@&quot;, self);&#125;// Swiftfunc injected() &#123; print(&quot;I&apos;ve been injected: \\(self)&quot;)&#125; ctrl + = 看一下你的控制台有没有输出 I’ve been injected 有了说明成功了 在 injected 方法中加入你要修改的UI代码，按下 ctrl + = 你可以看到模拟器界面的变化 或者按下 ctrl + shift + = 这个可以不用将代码写在injected 方法中，他会重新运行一遍你的程序，而不是单个Controller","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://kysonyangs.github.io/tags/插件/"}]},{"title":"iOS警告","slug":"16-06 iOS警告","date":"2016-06-20T10:28:05.000Z","updated":"2018-06-20T02:20:24.704Z","comments":true,"path":"iOS/16-06 iOS警告/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-06 iOS警告/","excerpt":"一、消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告）","text":"一、消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告）那么，如何得到类似 -Wdeprecated-declarations 的标识符呢？如果下图的 Reveal in log有效，那么点击即可无效的话也别急，你可以如下图操作查看，如果没有就先编译/运行一下然后在下图红框位置找到警告的标识符 如果要删除一个.m里面的所有弃用的警告，如下图操作： 如果要删除项目中所有弃用的警告，如下图操作：当然，你也可以填入别的标识符~ 有的警告编译器会教你如何消除，而你只需要点一下即可！！！ 二、添加警告 直接 #warning &lt;#message#&gt; 在自己写的三方库提供的接口下写上适用范围 1- (void)test NS_DEPRECATED_IOS(2_0, 4_0); 也可以加点信息提示该方法弃用了 123- (void)test __attribute((deprecated(&quot;这个接口已弃用，请使用xxx！&quot;)); 或者- (void)test NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, &quot;这个接口已弃用，请使用xxx！&quot;); 三、碰到过的警告 Unused variable &#39;xxx&#39; - 没有使用 Deprecated: Push segues are deprecated in iOS 8.0 and later - iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:. - 一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示 &#39;sizeWithFont:constrainedToSize:lineBreakMode:&#39; is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context: - 方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法 Undeclared selector &#39;historyAction&#39; - 使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了 Code will never be executed - 代码永远也不会执行，检查代码吧","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"警告","slug":"警告","permalink":"https://kysonyangs.github.io/tags/警告/"}]},{"title":"open-souce整理","slug":"16-06 open-souce整理","date":"2016-06-20T03:40:02.000Z","updated":"2018-06-20T02:20:42.449Z","comments":true,"path":"iOS/16-06 open-souce整理/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-06 open-souce整理/","excerpt":"","text":"MMDrawerController: 侧拉菜单，封装十分完善！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"三方","slug":"三方","permalink":"https://kysonyangs.github.io/tags/三方/"}]},{"title":"Git操作(二)","slug":"16-06 Git操作-二","date":"2016-06-06T14:23:17.000Z","updated":"2018-06-20T02:19:17.804Z","comments":true,"path":"default/16-06 Git操作-二/","link":"","permalink":"https://kysonyangs.github.io/default/16-06 Git操作-二/","excerpt":"git 拉分支 未 checkout 123git branch test_branch// 查看当前分支git branch 拉分支并且checkout 1git checkout -b test_branch 切换tag 1git checkout tags/v1.2","text":"git 拉分支 未 checkout 123git branch test_branch// 查看当前分支git branch 拉分支并且checkout 1git checkout -b test_branch 切换tag 1git checkout tags/v1.2 拉分支从某一次提交前 1git branch test_branch HEAD~1(1-&gt;前一次) 删除分支 1git branch -d test_branch 提交分支 1git push origin test_branch 合并分支 1git merge feature 修改commit信息 123git log --onelinegit rebase -i HEAD~2// 将vim中pick改为r wq 修改你想要修改成为的commit 合并commit 12git rebase -i HEAD~4 // 第一个commit为pick， 后几个改为s，意思是使用commit,但是合并到1 合并分支后将分支所有commit合并为一个 12git merge test_nranch --squashgit commit -m &quot;add&quot; 交换commit顺序 12git rebase -i HEAD~2// 修改两个pick位置 查看之前工作的分支 1git reflog 终端命令设置别名： 首先，你的别名得不存在，在终端输入你想要设置的别名，提示不能找到命令，则别名不存在，我们可以放心使用。 alias可以查看当前已设置的所有的别名 永久化的别名设置123456vim ~/.bash_profile// 在最下面添加你想要设置的别名，比如alias cdg=&quot;cd ~/Desktop/GG&quot; // 然后 wq保存退出，在终端输入source ~/.bash_profile // 现在，你可以使用你设置的别名了","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"利用GithubORCoding管理hexo博客源码","slug":"16-05 利用GithubORCoding管理博客","date":"2016-05-11T14:59:52.000Z","updated":"2018-06-20T02:21:08.432Z","comments":true,"path":"iOS/16-05 利用GithubORCoding管理博客/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-05 利用GithubORCoding管理博客/","excerpt":"上传Blog到Git 在git上创建一个仓库和你的hexo文件夹名字相同 删除文件夹原有的.git缓存文件并编辑.gitignore文件123/.deploy_git/public /_config.yml","text":"上传Blog到Git 在git上创建一个仓库和你的hexo文件夹名字相同 删除文件夹原有的.git缓存文件并编辑.gitignore文件123/.deploy_git/public /_config.yml 删除你的themes下主题内的.git文件 初始化你的hexo文件夹 1234git initgit remote add origin &lt;server&gt;已存在的话就更换git源vi .git/config OK，以后只要执行hexo g、s、d后，别忘了将代码提交到git 123git add . #添加blog目录下所有文件，注意有个`.`（`.gitignore`声明过的文件不包含在内)git commit -m &quot;commit&quot; #添加更新说明git push -u origin master #推送更新到云端服务器 同步git内容到本地 1234git fetch --allgit reset --hard origin/master// orgit pull","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://kysonyangs.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"iOS中JavaScript和OC交互","slug":"16-05 iOS中JavaScript和OC交互","date":"2016-05-10T14:31:54.000Z","updated":"2018-06-20T02:19:58.827Z","comments":true,"path":"iOS/16-05 iOS中JavaScript和OC交互/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-05 iOS中JavaScript和OC交互/","excerpt":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","text":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Objective-C语言调用JavaScript语言 通过UIWebView的 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 方法实现，利用该方法执行一段JavaScript代码。（JavaScript: 以下使用JS代替） 获取当前网页的标题 1self.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title;&quot;]; 获取当前网页的网址URL 1NSLog(@&quot;%@&quot;, [webView stringByEvaluatingJavaScriptFromString:@&quot;document.location.href;&quot;]); 调用JS的方法 1[webView stringByEvaluatingJavaScriptFromString:@&quot;klevent();&quot;] 以上执行情况如下 如果是自己写的HTML5网页，你可以控制里面的元素删除或者添加之类的，当然你得先懂点HTML5-JS知识123NSString *str = @&quot;var p = document.getElementsByTagName(&apos;p&apos;)[0];&quot; &quot;p.remove();&quot;;[webView stringByEvaluatingJavaScriptFromString:str]; * JS调用OC的方法 先来个简单的不带参数1234567891011121314151617181920// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; // 判断是否包含 if ([url hasPrefix:scheme]) &#123; [self js1]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有一个参数12345678910111213141516171819202122232425262728// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://one=kellen&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js2?one=kellen NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js2 NSString *methodName = [[subpaths firstObject] stringByAppendingString:@&quot;:&quot;]; // 参数 kellen NSString *param = [subpaths lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:param]; // 当然，你也可以只获得参数，调用的方法名自己写 return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有两个或多个参数1234567891011121314151617181920212223242526272829303132333435// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://js3_two_?one=kellen&amp;two=Yangs&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js3_two_?one=kellen&amp;two=Yangs NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js3_two_ NSString *methodName = [[subpaths firstObject] stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;:&quot;]; // 参数 one=kellen&amp;two=Yangs NSString *param = [subpaths lastObject]; NSArray *subparams = nil; if (subpaths.count == 2 || [param containsString:@&quot;&amp;&quot;]) &#123; subparams = [param componentsSeparatedByString:@&quot;&amp;&quot;]; &#125; // 取出前面的2个参数 NSString *firstParam = [subparams firstObject]; NSString *secondParam = subparams.count &lt;= 1 ? nil : [subparams lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:firstParam withObject:secondParam]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有个三方库可以方便开发","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"JS交互","slug":"JS交互","permalink":"https://kysonyangs.github.io/tags/JS交互/"}]},{"title":"iOS9新特性","slug":"16-05 iOS9新特性","date":"2016-05-09T13:47:54.000Z","updated":"2018-06-20T02:19:50.064Z","comments":true,"path":"iOS/16-05 iOS9新特性/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-05 iOS9新特性/","excerpt":"前提：最近公司准备招个iOS， 面试过程下来发现有些面试者对于iOS9的新特性不是很了解，在此，根据我遇到的情况归类整理一下。再说一句：这里只针对iPhone开发，至于iOS8、7新特性以后有时间再说吧。 iOS9新特性 网络适配 iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。即HTTPS,但是如果公司没有升级服务器，仍然是HTTP请求的话，在Xcode请求的时候会报以下警告。 要解决也简单,在info.plist添加： Xcode7.0 在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean，值设为YES。 7.1后苹果改了这项设定的名称，但是主要内容还是差不多，只是名字变了，而且增加了提示功能 NSAppTransportSecurity改为了App Transport Security Settings。(输入App可以找到的) NSAllowsArbitraryLoads改为了Allows Arbitrary Loads。(这个也有提示。)","text":"前提：最近公司准备招个iOS， 面试过程下来发现有些面试者对于iOS9的新特性不是很了解，在此，根据我遇到的情况归类整理一下。再说一句：这里只针对iPhone开发，至于iOS8、7新特性以后有时间再说吧。 iOS9新特性 网络适配 iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。即HTTPS,但是如果公司没有升级服务器，仍然是HTTP请求的话，在Xcode请求的时候会报以下警告。 要解决也简单,在info.plist添加： Xcode7.0 在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean，值设为YES。 7.1后苹果改了这项设定的名称，但是主要内容还是差不多，只是名字变了，而且增加了提示功能 NSAppTransportSecurity改为了App Transport Security Settings。(输入App可以找到的) NSAllowsArbitraryLoads改为了Allows Arbitrary Loads。(这个也有提示。) 使用定位功能，地图功能,在info.plist添加： NSLocationWhenInUseUsageDescription ，允许在前台使用时获取GPS的描述(使用期间允许) NSLocationAlwaysUsageDescription ，允许永久使用GPS的描述(一直允许) 现在百度地图，高德地图集成都有教程… Bitcode bitcode的理解应该是把程序编译成的一种过渡代码，然后苹果再把这个过渡代码编译成可执行的程序。bitcode也允许苹果在后期重新优化我们程序的二进制文件，有类似于App瘦身的思想。未来Watch应用须包含Bitcode，iOS不强制，但Xcode7默认会开启Bitcode,所以可能会报错： 1XXXX’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode forthistarget. forarchitecture arm64 解决也简单： 企业级开发 iOS9之前，企业级分发十分方便：点击App出现“信任按钮”。 iOS9以后，企业级分发ipa包将遭到与Mac上dmg安装包一样的待遇。默认不能安装，也不再出现“信任按钮”，所以需要打开 设置 -&gt; 通用 -&gt; 描述文件 -&gt; 信任 (由于没使用过企业开发者账号，所以现在不知道有没有变化) 个人开发者也可能遇到点击APP弹出说什么没权限，没信任什么之类的，不太记得了，抱歉，那么你可以打开 设置 -&gt; 通用 -&gt; 设备管理 -&gt; 信任开发者 OK,搞定！ URL scheme URL scheme一般使用的场景是打开手机安装的其他APP，比如分享给QQ、微信之类的，打开百度地图之类的。 在iOS8并没有做过多限制， 但是在iOS9中，如果使用URL scheme必须在”info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用。如下图： 新的字体 iOS8中，字体是Helvetica，中文的字体有点类似于“华文细黑”。只是苹果手机自带渲染，所以看上去可能比普通的华文细黑要美观。 iOS9中，中文系统字体变为了专为中国设计的“苹方”，字体有轻微的加粗效果，而且字体间隙变大了。所以很多原本写死了width的label可能会出现显示不下，”…”的情况。这里要注意。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"iOS9","slug":"iOS9","permalink":"https://kysonyangs.github.io/tags/iOS9/"}]},{"title":"Swift-CoreData的使用","slug":"16-05 Swift-CoreData的使用","date":"2016-05-09T13:47:35.000Z","updated":"2018-06-20T02:20:47.483Z","comments":true,"path":"Swift/16-05 Swift-CoreData的使用/","link":"","permalink":"https://kysonyangs.github.io/Swift/16-05 Swift-CoreData的使用/","excerpt":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。","text":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。 创建一个新工程，在AppDelegate里面多了下面方法。 如果你已经创建好工程，但是没勾选上面选项，没关系，新建一个CoreData文件但是AppDelegate里面没东西，没关系，新建一个新项目，将里面的内容拷进你的项目，但是你得修改一个地方 新建一个实体双击修改名字 添加属性 新建NSManagedObject，通过Core Data从数据库取出的对象，默认情况下都是NSManagedObject对象next -&gt; next -&gt; next OK，多了两个文件 KL_Test+CoreDataProperties.swift 不需要变 KL_Test.swift 添加增删查改的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import Foundationimport CoreDataimport UIKit@objc(CollectGank)class KL_Test: NSManagedObject &#123; static let app = UIApplication.sharedApplication().delegate as! AppDelegate static let context = app.managedObjectContext // 插入 static func insert(model: KL_Test) &#123; let collectGank = NSEntityDescription.insertNewObjectForEntityForName(&quot;KL_Test&quot;,inManagedObjectContext: context) as! KL_Test collectGank.name = model.name collectGank.age = model.age do &#123; try context.save() print(&quot;成功&quot;) &#125;catch &#123; fatalError(&quot;不能保存\\(error)&quot;) &#125; &#125; // 查询所有的数据并返回 static func fetch() -&gt; [KL_Test] &#123; var array = [KL_Test]() //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) array = fetchedObjects as! [KL_Test] &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; return array &#125; // 修改 static func update(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() fetchRequest.fetchLimit = 1 //限定查询结果的数量 fetchRequest.fetchOffset = 0 //查询的偏移量 //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;kellen&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 是否存在（查找） static func exist(gank: KL_Test) -&gt; Bool &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 guard (fetchedObjects != nil &amp;&amp; fetchedObjects!.count &gt; 0) else &#123; return false &#125; return true &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 删除 static func deleted(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;CollectGank&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos;&quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) print(fetchedObjects) //遍历查询的结果 for info:KL_Test in fetchedObjects as! [KL_Test]&#123; //删除对象 context.deleteObject(info) &#125; //重新保存-更新到数据库 try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://kysonyangs.github.io/categories/Swift/"}],"tags":[{"name":"CoreData","slug":"CoreData","permalink":"https://kysonyangs.github.io/tags/CoreData/"}]},{"title":"Charles 使用","slug":"16-04 Charles使用","date":"2016-04-15T07:10:53.000Z","updated":"2018-06-20T02:18:30.331Z","comments":true,"path":"iOS/16-04 Charles使用/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 Charles使用/","excerpt":"Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。","text":"Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 将Charles 设置成系统代理选择菜单中的”Proxy” -&gt; “Mac OX Proxy” 将Charles设置成系统代理。这样就可以看到本机的网络强求了… 过滤网络请求 在Filter中填入你想过需要的关键字 选择菜单”Proxy” -&gt; “Recording Setting” -&gt; “Include”,添加一个项目，填入监控的协议，主机地址，端口号，就可以只截取目标网站的封包。 在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项 其中1、3是临时性的， 2是经常性的。 截取iPhone上的网络封包 Charles 设置将 Charles 的代理功能打开， 选择菜单”Proxy” -&gt; “Proxy Settings”, 在Port填入代理端口8080，并且勾上”Enable transparent HTTP proxying”，如图： iPhone设置2.1 获取电脑IP地址 // 192.168.0.127选择菜单”Help” -&gt; “Local IP Address”查看本机IP2.2 iPhone设置 -&gt; Wi-Fi -&gt; 当前连接的wifi -&gt; 点击右侧详情按钮 -&gt; 底部HTTP代理选择手动 -&gt; 服务器填上电脑的IP地址 -&gt; 端口号填 8080 电脑Chroles会弹出一个是否确认的菜单，选择Allow！！！ OK,完成！ HTTP抓包 打开Charles程序 查看Mac电脑的IP地址，如192.168.1.7 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888 iOS设备打开你要抓包的app进行网络操作 Charles弹出确认框，点击Allow按钮即可 HTTPS抓包 在 iOS 设备上打开这个网址 http://www.charlesproxy.com/getssl 安装 Charles SSL 证书 在Charles的工具栏上点击设置按钮，选择Proxy Settings…3 切换到SSL选项卡，选中Enable SSL Proxying，别急，选完先别关掉，还有下一步 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles则麻烦一些，需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"Swift单例","slug":"16-04 Swift单例","date":"2016-04-12T07:08:48.000Z","updated":"2018-06-20T02:20:55.615Z","comments":true,"path":"Swift/16-04 Swift单例/","link":"","permalink":"https://kysonyangs.github.io/Swift/16-04 Swift单例/","excerpt":"在Swift中实现单例有好几种方式：如下 最简单的一句话搞定123456class SingleOne &#123; // 实现单例 static let shareSingleOne = SingleOne() // 防止外界初始化 private override init() &#123;&#125;&#125;","text":"在Swift中实现单例有好几种方式：如下 最简单的一句话搞定123456class SingleOne &#123; // 实现单例 static let shareSingleOne = SingleOne() // 防止外界初始化 private override init() &#123;&#125;&#125; 使用dispatch_once123456789101112131415class SingleTwo &#123; //单例 static func shareSingleTwo() -&gt; SingleTwo &#123; struct Singleton&#123; static var onceToken : dispatch_once_t = 0 static var single:SingleTwo? &#125; dispatch_once(&amp;Singleton.onceToken,&#123; Singleton.single = SingleTwo() &#125; ) return Singleton.single! &#125; private override init() &#123;&#125;&#125; 一般就使用以上两种即可，下面的了解即可，不赞成使用 利用全局常量 123456789// 全局的常量private let single = SingleThree()final class SingleThree &#123; static var sharedInstance : SingleThree &#123; return single &#125; private override init() &#123;&#125;&#125; 在方法内定义静态常量 12345678910final class SingleFour &#123; static var sharedInstance : SingleFour &#123; struct Static &#123; static let instance : SingleFour = SingleFour() &#125; return Static.instance &#125; private override init() &#123;&#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://kysonyangs.github.io/categories/Swift/"}],"tags":[]},{"title":"生成条形码和二维码","slug":"16-04 生成条形码和二维码","date":"2016-04-11T09:16:47.000Z","updated":"2018-06-20T02:21:32.736Z","comments":true,"path":"iOS/16-04 生成条形码和二维码/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 生成条形码和二维码/","excerpt":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","text":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 生成二维码123456789101112131415161718- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成二维码图片 CIImage *qrcodeImage; NSData *data = [_code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; [filter setValue:@&quot;H&quot; forKey:@&quot;inputCorrectionLevel&quot;]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"mac Apache服务器","slug":"16-04 mac-Apache服务器","date":"2016-04-11T08:28:48.000Z","updated":"2018-06-20T02:20:35.711Z","comments":true,"path":"default/16-04 mac-Apache服务器/","link":"","permalink":"https://kysonyangs.github.io/default/16-04 mac-Apache服务器/","excerpt":"当自己需要测试发送请求时，可以配置本地的Apache，Mac电脑自带的服务器！ 在/User/…/ 下 创建一个文件夹 sites 随便放点东西进去","text":"当自己需要测试发送请求时，可以配置本地的Apache，Mac电脑自带的服务器！ 在/User/…/ 下 创建一个文件夹 sites 随便放点东西进去 修改配置文件，当然原来文件需要备份12345// 备份 (提示没权限就在前面加上sudo)cd /etc/apache2sudo cp httpd.conf httpd.conf.bak// 修改vim httpd.conf ：/DocumentRoot 查找DocumentRoot：/php 查找php：/Options 查找Options n-&gt;查找下一个 启动apache服务器apachectl -k start 启动apachectl -k restart 重启apachectl -k stop 关闭 成果图一张","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://kysonyangs.github.io/tags/服务器/"}]},{"title":"Bug集锦","slug":"16-04 Bug集锦","date":"2016-04-11T07:10:53.000Z","updated":"2018-06-20T02:25:04.382Z","comments":true,"path":"iOS/16-04 Bug集锦/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 Bug集锦/","excerpt":"-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject];","text":"-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject]; 添加了一个All Exceptions 出现停在线程队列的情况，点继续运行仍然可以运行，将该断点删除或者将里面的All改成Object-C也可以！ 解决“Two-stage rotation animation is deprecated. This application should use the smoother single-stage animation.”警告。原因：不应该将UITabBarControllier嵌入到UINavigationController中作为rootViewController，但是，我们的确想要这样做，只需要在将tabbar作为rootviewcontroller之前先设置tabBarController.selectedIndex= 0。 ios7下面用autolayout报错类似 *** Assertion failure in -[XXX layoutSublayersOfLayer:], /SourceCache/UIKit/UIKit-2935.138/UIView. 这样的错误解决方案是 在布局之后 加上【super layoutsubviews】【self lauoutifneed】 这两个方法。 友盟如果碰到一堆Bug，可以试试添加SystemConfig.framework，也许可以帮助解决一下问题哟，碰运气。。。 当我使用UITableView+FDTemplateLayoutCell.h进行cell动态布局时，总是报错，提示我应该给cell一个服用标志，可是已经给了！你可以尝试把footView给干掉！ 有的时候在Mac上经常复制粘贴无效，你可是使用以下方法看看是否解决问题： 1234launchctl list | grep com.apple.pboardlaunchctl stop com.apple.pboard launchctl start com.apple.pboard there was an internal api error “—- xcode7，然后解决办法：bulid settings -&gt; packaging -&gt; product name 不要写中文。。。。 打开Playground提示打开失败，找不到合适的devices 123451. Quit Xcode2. Delete the folder /Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices. For example, in Terminal: rm -rf ~/Library/Developer/CoreSimulator/Devices3. In Terminal: killall -9 com.apple.CoreSimulator.CoreSimulatorService (or just reboot).ORAdd a iOS8.0Device","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://kysonyangs.github.io/tags/Bug/"}]},{"title":"iOS国际化","slug":"16-04 iOS国际化","date":"2016-04-11T06:55:52.000Z","updated":"2018-06-20T02:20:03.945Z","comments":true,"path":"iOS/16-04 iOS国际化/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 iOS国际化/","excerpt":"一、应用名称国际化 1.ctrl+n 创建一个.strings文件，如图","text":"一、应用名称国际化 1.ctrl+n 创建一个.strings文件，如图 2.选中InfoPlist.strings， 点击Localization中的Localized…按钮，选则English 3.选择Project -&gt; Localization，添加Chinese,如图 最后，在InfoPlist.strings(English)添加：CFBundleDisplayName = “Internationlization”; 在InfoPlist.strings(Chineses)添加：CFBundleDisplayName = “国际化”; 即可，你可以在模拟器切换English和中文设置查看效果二、应用名称国际化 在InfoPlist.strings(English)添加：”key” = “test”; 在InfoPlist.strings(Chineses)添加：”key” = “测试”; 在代码添加1self.title = NSLocalizedStringFromTable(@&quot;key&quot;, @&quot;InfoPlist&quot;, @&quot;&quot;); 三、Xib/StoryBoard 1.选中Main.storyboard,打开文件选择器，勾选Localization下面的base\\chinese\\english 2.在storyboard拖一个Label,在如图所示的地方了看到他的ID","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"Xcode插件备忘","slug":"16-04 Xcode插件备忘","date":"2016-04-11T06:44:00.000Z","updated":"2018-06-20T02:21:00.331Z","comments":true,"path":"default/16-04 Xcode插件备忘/","link":"","permalink":"https://kysonyangs.github.io/default/16-04 Xcode插件备忘/","excerpt":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter）","text":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter） 常用插件以及用法：1.Alcatraz: 插件管理123456// 安装 (mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins)curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh// 删除rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz 2.XcodeColors：给 Xcode 控制台添加颜色 用法见我以前写的一篇简书Xcode带颜色Log 当然这个插件与CocoaLumberjack是一对好基友，有兴趣的可以自行了解… 3.XToDo：这个插件可以给注释加书签类的功能，你可以随时跳转到你加此类注释的地方 添加 TODO 书签 – ⌃⇧T 添加 FIXME 书签 – ⌃⇧X 添加 ？？？ 书签 – ⌃⇧1 添加 ！！！ 书签 – ⌃⇧Q 书签窗口 – ⌃T 4.KSImageNamed：自动补全图片名5.Peckham：导入头文件 ⌘ + ctrl + P 然后选择你要导入的头文件即可 6.FuzzyAutocomplete：自动补全，提升编写效率7.CodePilot: 便捷查找你所需要的文件，代码… ⌘ + shift + X 输入你需要查找的内容即可 8.HOStringSense：很方便的编写大段文本9.XcodeBoost: 功能十分强大也十分方便，具体请进github自行观看10.SCXcodeMiniMap: 给Xcode创建一个迷你地图11.XAlign：对齐代码 选中你需要对齐的代码 – ⌘ + shift + Z 12.VVDocumenter: 规范化注释插件 -&gt; /// – 快捷键13.BBUDebuggerTuckAway: 自动隐藏底部的调试栏14.Backlight：高亮当前正在编辑的那一行15.xcode语法高亮插件16.ColorSense: 可视化颜色17.[SCXcodeSwitchExpander(https://github.com/stefanceriu/SCXcodeSwitchExpander):switch枚举的时候会自动生成代码 补充一点很实用的东东1.插件目录： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/2.当Xcode升级版本，然后插件失效后：12341.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID2.然后输入如下命令 【最后一项是获取到的DVTPlugInCompatibilityUUID】 find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add 9F75337B-21B4-4ADC-B558-F9CADF7073A7 3.playground无效，可能是误删模拟器的类型，重置12rm -rf ~/Library/Developer/CoreSimulator/Devices killall -9 com.apple.CoreSimulator.CoreSimulatorService 先这样吧，以后有好玩的会继续补充—有啥好玩的插件推荐呢 ^^ | ^^","categories":[],"tags":[{"name":"插件","slug":"插件","permalink":"https://kysonyangs.github.io/tags/插件/"}]},{"title":"终端/git一些配置(一)","slug":"16-04 终端-git一些配置","date":"2016-04-11T06:13:48.000Z","updated":"2018-06-20T02:21:41.626Z","comments":true,"path":"default/16-04 终端-git一些配置/","link":"","permalink":"https://kysonyangs.github.io/default/16-04 终端-git一些配置/","excerpt":"git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2","text":"git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2 配置.ssh/config 123456789101112131415161718192021vi .ssh/config# 加上以下内容#github# first.github (first@gmail.com)Host github.comHostName github.comIdentityFile ~/.ssh/id_rsa# second (second@gmail.com)Host secondHostName github.comIdentityFile ~/.ssh/id_rsa_second#gitOSc#default git@oscHost git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/id_rsaHost second HostName git.oschina.net IdentityFile ~/.ssh/id_rsa_work 将 id_rsa.pub id_rsa_2.pub添加到对应账号上 验证是否成功 123456//1. Github验证ssh -T git@github.comssh -T git@second//2. Git Osc验证ssh -T git@git.oschina.netssh -T git@git.second.net(貌似是这个吧，有点忘了) 使用账号2clone push 123456git clone... 下来后 修改// 方法1git remote rm origingit remote add origin git@onemaybe:OneMaybe/OneMaybe.github.io.git// 方法2vi .git/config Git 分支操作 git checkout -b test 添加并切换到该分支 git checkout test 切换分支 git push origin test 提交分支 从github clone 所有分支4.1. git clone https://github.com/KellenYangs/TestFenzhi.git4.2. 列出所有分支 cd TestFenzhi git branch -a4.3. checkout 远程的分支并在本地起名为test 并切换到testgit checkout -b test origin/test git pull 下载更新 git pull origin master 合并分支 git push origin master 提交代码 修改终端前面的显示（太长不好看） 修改终端的显示成 省略前面的电脑名 终端输入open /etc 找到bashrc-&gt;显示简介-&gt;将只读改成读与写，配置完成后改回去 终端输入sudo vim /etc/bashrc 找到PS1=’\\h:\\W \\u\\$ ‘，将其注释掉（为了备份） 换行添加PS1=’ \\W \\u\\$’，OK！！！","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"iOS数据库操作的常用SQL语句","slug":"16-04 iOS数据库操作的常用SQL语句","date":"2016-04-09T13:48:07.000Z","updated":"2018-06-20T02:20:08.822Z","comments":true,"path":"iOS/16-04 iOS数据库操作的常用SQL语句/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-04 iOS数据库操作的常用SQL语句/","excerpt":"前提：之前项目中使用SQLite数据库进行数据的储存，所以用到的SQL语句还是蛮多的，在此，记录一下常用的吧。 创建表","text":"前提：之前项目中使用SQLite数据库进行数据的储存，所以用到的SQL语句还是蛮多的，在此，记录一下常用的吧。 创建表 12345CREATE TABLE IF NOT EXISTS KL_Test (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,name TEXT,age INTEGER); 删除表 1DROP TABLE KL_Test; 增 1INSERT INTO KL_Test (name, age) VALUES (&apos;kellen&apos;, 22); 删 12DELETE FROM KL_Test WHERE id = 1;DELETE FROM KL_Test WHERE name = &apos;kellen&apos;; 改 12UPDATE KL_Test SET name = &apos;yangs&apos;, age = 30 WHERE id = 1;UPDATE KL_Test SET age = 60 WHERE name = &apos;yangs&apos;; 查 123456789101112131415// 1. 查询所有的字段SELECT * FROM KL_Test;// 2. 查询指定的字段SELECT name FROM KL_Test;// 3. 根据查询条件进行查询（一般用来判断是否存在）SELECT name FROM KL_Test WHERE age = 22;// 4. &lt; / &gt;SELECT name FROM KL_Test WHERE age &lt; 22;// 5. 查询所有记录的所有字段，根据 age 升序排序SELECT * FROM KL_Test ORDER BY age;// 6. 查询所有记录的所有字段， 根据 age 降序排序SELECT * FROM KL_Test ORDER BY age DESC;// 7. 使用多个字段排序，先按age降序排序，当age相同再根据name降序排序SELECT * FROM KL_Test ORDER BY age DESC,name DESC;... 贴一下当年写的使用FMDB的类吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &quot;DBManager.h&quot;#import &quot;FMDatabase.h&quot;@interface DBManager ()&#123; FMDatabase *_fmdb;&#125;+(id)sharedManager;@implementation DBManager- (instancetype)init&#123; self = [super init]; if (self) &#123; NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;]stringByAppendingPathComponent:@&quot;myapp.db&quot;]; _fmdb = [[FMDatabase alloc]initWithPath:path]; if ([_fmdb open]) &#123; NSString *sql = @&quot;create table if not exists myapp(id integer primary key autoincrement,appid varchar(64),appname varchar(128),iconurl varchar(1024))&quot;; [_fmdb executeUpdate:sql]; &#125; &#125; return self;&#125;+(id)sharedManager&#123; static DBManager *_m = nil; if (!_m) &#123; _m = [[DBManager alloc]init]; &#125; return _m;&#125;// 判断是否存在，根据appid来判断-(BOOL)isExists:(NSString *)appid&#123; NSString *sql = @&quot;select appid from myapp where appid = ?&quot;; FMResultSet *set = [_fmdb executeQuery:sql,appid]; if ([set next]) &#123; return YES; &#125; return NO;&#125;// 查询所有的数据，并返回-(NSMutableArray *)fetchAll&#123; NSMutableArray *array = [NSMutableArray array]; NSString *sql = @&quot;select * from myapp&quot;; FMResultSet *set = [_fmdb executeQuery:sql]; while ([set next]) &#123; DetailModel *model = [[DetailModel alloc]init]; model.applicationId = [set stringForColumn:@&quot;appid&quot;]; model.name = [set stringForColumn:@&quot;appname&quot;]; model.iconUrl = [set stringForColumn:@&quot;iconurl&quot;]; [array addObject:model]; &#125; return array;&#125;// 插入一个模型-(void)insertModel:(DetailModel *)model&#123; NSString *sql = @&quot;insert into myapp(appid,appname,iconurl) values(?,?,?)&quot;; [_fmdb executeUpdate:sql,model.applicationId,model.name,model.iconUrl];&#125;// 删除一个模型-(void)deleteModel:(DetailModel *)model&#123; NSString *sql = @&quot;delete from myapp where appid = ?&quot;; [_fmdb executeUpdate:sql,model.applicationId];&#125;// 开启事务-(void)beginTransactionY&#123; if (![_fmdb inTransaction]) &#123; [_fmdb beginTransaction]; &#125;&#125;// 处理完成，提交-(void)commitY&#123; if ([_fmdb inTransaction]) &#123; [_fmdb commit]; &#125;&#125;// 因某些操作退出，未完成提交， 回滚-(void)rollbackY&#123; if ([_fmdb inTransaction]) &#123; [_fmdb rollback]; &#125;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"FMDB数据库","slug":"FMDB数据库","permalink":"https://kysonyangs.github.io/tags/FMDB数据库/"}]},{"title":"GCD理解-二","slug":"16-03 GCD理解-二","date":"2016-03-22T10:10:53.000Z","updated":"2018-06-20T02:19:26.228Z","comments":true,"path":"iOS/16-03 GCD理解-二/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 GCD理解-二/","excerpt":"GCD理解（一）GCD理解（二） 代码下载 dispatch_group dispatch_group_notify监听dispatch_queue中所有的任务执行完成，执行某些操作","text":"GCD理解（一）GCD理解（二） 代码下载 dispatch_group dispatch_group_notify监听dispatch_queue中所有的任务执行完成，执行某些操作 1234567891011121314151617dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, self.concurrentQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;1 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 1111&quot;);dispatch_group_async(group, self.serialQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;2 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 2222&quot;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 任务全部完成处理 NSLog(@&quot;组内任务全部完成，请检验...&quot;);&#125;); enter &amp;&amp; levep dispatch_group_enter(group); 进入组 dispatch_group_leave(group); 离开组 dispatch_group_wait(group, DISPATCH_TIME_FOREVER);(等待组内任务完成)12345678910111213141516171819dispatch_group_t group = dispatch_group_create();for (int i = 0; i &lt; 3; i++) &#123; dispatch_group_enter(group); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;进入第%zd个异步 sleep 3秒&quot;, i); sleep(3); NSLog(@&quot;离开第%zd个异步 sleep 完成&quot;, i); dispatch_group_leave(group); &#125;);&#125;// 1 -----dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);&#125;);// // 2 ------ 1/2 任选1// dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);// &#125;);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://kysonyangs.github.io/tags/GCD/"}]},{"title":"GCD理解-一","slug":"16-03 GCD理解-一","date":"2016-03-22T07:10:53.000Z","updated":"2018-06-20T02:19:21.940Z","comments":true,"path":"iOS/16-03 GCD理解-一/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 GCD理解-一/","excerpt":"GCD理解（一）GCD理解（二）代码下载 ####Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。*","text":"GCD理解（一）GCD理解（二）代码下载 ####Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。* 123456789// 一般用法dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i = 0; i &lt; 100000; i++) &#123; NSLog(@&quot;%zd&quot;, i); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新UI&quot;); &#125;); &#125;); 自定义队列 串行队列 同步运行 123456789101112dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现在for循环之后即dispatch_sync任务执行完之后，因为串行队列同步运行，阻塞主线程。// 在这里发现创建的线程和主线程地址相同，说明串行队列同步运行是直接在主线程中运行的！ 异步运行 1234567891011dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 并行队列 同步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 线程地址相同，且与主线程队列地址相同，// 结合串行队列同步运行与串行队列异步运行结果来看，同步运行时线程都是在主线程上运行，不开辟新的线程。// 运行结果与串行队列同步运行相同 异步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 输出结构乱序，因为是并行的异步执行，// 不能决定谁先谁后，且发现线程地址不同，说明开了多条线程执行队列，// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 总结: dispatch_sync 并不会开辟新的线程执行任务，所以不管是串行队列还是并行队列其实都在一个线程(mainQueue也在主线程)中运行，且它是同步的，所以阻塞主线程，一定得队列任务完成之后才会执行之后的任务！ dispatch_async 会异步的运行队列任务，但是串行队列只在一个线程中，所以只是不阻塞主线程，但是还是遵行串行队列FIFO(先进先出)执行任务， 而并行队列会开多条线程进行异步执行任务，效率更高！ dispatch_barrier在 dispatch_barrier 之后的任务总是会在 dispatch_barrier 之前的任务执行完之后在执行 dispatch_barrier_sync 1234567891011121314151617181920212223for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_1_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_sync(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_sync %zd&quot;,[NSThread currentThread], i); if (i == 4) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;);&#125;NSLog(@&quot;dispatch_barrier_sync_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_2_main&quot;);// 结果分析 先并发异步执行 dispatch_async_1, // 在执行 dispatch_barrier_sync ,最后并发异步执行 dispatch_async_2, dispatch_barrier_sync 会阻塞主线程 dispatch_barrier_async 12345678910111213141516171819202122232425for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_1_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_async %zd&quot;,[NSThread currentThread], i); if (i == 2) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;); &#125; NSLog(@&quot;dispatch_barrier_sync_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_2_main&quot;); // 结果分析: 首先它仍然会阻拦 dispatch_barrier_async 之后的任务等之前任务执行完之后再执行， // 其次他由于是异步的所以不阻塞主线程， // 但是我发现 `dispatch_barrier_async`里面执行的认为在一条线程中执行，且按顺序执行的！ // 所以我们做耗时操作的时候尽量不要放在`dispatch_barrier_async`中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列啊！ 注意： dispatch_barrier 不要用在global queue 中，因为 dispatch_barrier 只使用在一条并行队列中，而global queue 是每次系统分配一个并行队列(可能是不同的)，所以没有意义！ dispatch_barrier_async里面执行的认为在一条线程中执行，且按顺序执行的！所以我们做耗时操作的时候尽量不要放在dispatch_barrier_async中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列！ NSDictionary: 线程安全, 但是NSMutableDictionary: 不是线程安全的，所以我们可以使用 dispatch_barrier_async 来保证 NSMutableDictionary 线程安全!(Get&amp;&amp;Set) dispatch_semaphone: 信号量(用于并发控制) dispatch_semaphore_create(3) 创建信号量，传入一个大于等于0的long型整数(比作停车位，有了停车位才能停车) dispatch_semaphore_signal(semaphone) 传入一个信号量，执行一次，增加一次semaphone计数(可以这么理解: 一辆车开走了，然后这个停车位就空出来了，算作增加一个停车位); 返回值为0时表示当前并没有线程等待其处理的信号量; 返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程(优先级高的先被唤醒，否则随机) dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 5)); 每运行一次，semaphone计数-1，如果semaphone计数为0，那么根据传入的等待时间等待，如果等待时间设置为DISPATCH_TIME_FOREVER,那么就永远等待，永远不会执行之后的了， 除非信号量计数&gt;1了! (可以这么理解: 在这里判断是否有停车位剩余，如果有就停车，没有的话就等待车位空出再停车，如果超出等待时间，这个人就等不下去了，开车走了); 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句 1234567891011121314// sample1:dispatch_semaphore_t semaphone = dispatch_semaphore_create(2); for (int i = 0; i &lt; 10; i++) &#123; if(dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 2 *NSEC_PER_SEC)) == 0) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;i will sleep 3 second %zd&quot;, i); sleep(3); NSLog(@&quot;i am wake up %zd&quot;, i); NSLog(@&quot;%zd signal %ld&quot;,i, dispatch_semaphore_signal(semaphone)); &#125;); &#125;else&#123; NSLog(@&quot;等不下去了，走人&quot;); &#125; &#125; 123456789101112// sample2:dispatch_semaphore_t semaphone = dispatch_semaphore_create(0);NSLog(@&quot;Boss: Kellen, wake up! working&quot;);dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;Kellen: I am sleep!&quot;); sleep(5); NSLog(@&quot;Kellen: I am wake up!&quot;); dispatch_semaphore_signal(semaphone);&#125;); dispatch_semaphore_wait(semaphone, DISPATCH_TIME_FOREVER);NSLog(@&quot;Kellen: I am working...&quot;);// 等待执行 NSLog(@&quot;Kellen: I am working...&quot;); 以上两种方案的话 看你情况使用！(信号量设为0 ,!0) 貌似写的有点多了，另起一篇吧！！！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://kysonyangs.github.io/tags/GCD/"}]},{"title":"CoreAniamtion学习四","slug":"16-03 CoreAnimation四","date":"2016-03-09T07:10:53.000Z","updated":"2018-06-20T02:18:58.898Z","comments":true,"path":"iOS/16-03 CoreAnimation四/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation四/","excerpt":"显式动画 CABasicAnimation(基本动画)123456789101112CABasicAnimation *basicA = [CABasicAnimation animation];basicA.keyPath = @&quot;backgroundColor&quot;;basicA.toValue = (__bridge id _Nullable)(color.CGColor);basicA.delegate = self;basicA.duration = 1.0;[self.layerView.layer addAnimation:basicA forKey:nil];// 代理，监听动画完成，还有个动画开始的监听- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag &#123; NSLog(@&quot;animation end&quot;); self.layerView.layer.backgroundColor = (__bridge CGColorRef _Nullable)(anim.toValue);&#125;","text":"显式动画 CABasicAnimation(基本动画)123456789101112CABasicAnimation *basicA = [CABasicAnimation animation];basicA.keyPath = @&quot;backgroundColor&quot;;basicA.toValue = (__bridge id _Nullable)(color.CGColor);basicA.delegate = self;basicA.duration = 1.0;[self.layerView.layer addAnimation:basicA forKey:nil];// 代理，监听动画完成，还有个动画开始的监听- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag &#123; NSLog(@&quot;animation end&quot;); self.layerView.layer.backgroundColor = (__bridge CGColorRef _Nullable)(anim.toValue);&#125; CAKeyframeAnimation (关键帧动画)不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。123456789CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;backgroundColor&quot;;animation.duration = 2.0;animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];[self.layerView.layer addAnimation:animation forKey:nil]; 123456789UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;position&quot;;animation.duration = 4.0;animation.path = bezierPath.CGPath;animation.rotationMode = kCAAnimationRotateAuto;[shipLayer addAnimation:animation forKey:nil]; 动画组CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起。 12345678910111213141516171819202122232425262728293031UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];//draw the path using a CAShapeLayerCAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.path = bezierPath.CGPath;pathLayer.fillColor = [UIColor clearColor].CGColor;pathLayer.strokeColor = [UIColor redColor].CGColor;pathLayer.lineWidth = 3.0f;[self.view.layer addSublayer:pathLayer];//add a colored layerCALayer *colorLayer = [CALayer layer];colorLayer.frame = CGRectMake(0, 0, 64, 64);colorLayer.position = CGPointMake(0, 150);colorLayer.backgroundColor = [UIColor greenColor].CGColor;[self.view.layer addSublayer:colorLayer];//create the position animationCAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];animation1.keyPath = @&quot;position&quot;;animation1.path = bezierPath.CGPath;animation1.rotationMode = kCAAnimationRotateAuto;//create the color animationCABasicAnimation *animation2 = [CABasicAnimation animation];animation2.keyPath = @&quot;backgroundColor&quot;;animation2.toValue = (__bridge id)[UIColor redColor].CGColor;//create group animationCAAnimationGroup *groupAnimation = [CAAnimationGroup animation];groupAnimation.animations = @[animation1, animation2];groupAnimation.duration = 4.0;//add the animation to the color layer[colorLayer addAnimation:groupAnimation forKey:nil]; 过度动画属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。 1234567891011121314151617181920212223type值:kCATransitionFade, // 平滑过渡kCATransitionMoveIn,kCATransitionMoveIn,kCATransitionReveal,subtype值: 控制方向kCATransitionFromRight，kCATransitionFromLeft，kCATransitionFromTop,kCATransitionFromBottomCATransition *transition = [CATransition animation];transition.type = kCATransitionFade;[self.imgv.layer addAnimation:transition forKey:nil];UIImage *currentImage = self.imgv.image;NSUInteger index = [arr indexOfObject:currentImage];index = (index + 1) % [arr count];self.imgv.image = arr[index];// 过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。// 但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，// 因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习三","slug":"16-03 CoreAnimation三","date":"2016-03-09T03:10:53.000Z","updated":"2018-06-20T02:18:45.891Z","comments":true,"path":"iOS/16-03 CoreAnimation三/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation三/","excerpt":"隐式动画就是当你改变某个属性是时，他会自动平滑的过渡到新的值。而你不需要去开启动画。比如： CALayer的backgroundColor 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。","text":"隐式动画就是当你改变某个属性是时，他会自动平滑的过渡到新的值。而你不需要去开启动画。比如： CALayer的backgroundColor 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。123456789101112131415161718// 使用事务改变执行时间（默认 0.25s）[CATransaction begin];(入栈)[CATransaction setAnimationDuration:1.0];// 完成之后在旋转90度(0.25s完成)[CATransaction setCompletionBlock:^&#123; NSLog(@&quot;改变颜色完成，开始旋转&quot;); 在颜色改变之后(入栈) CGAffineTransform transform = self.colorLayer.affineTransform; self.colorLayer.affineTransform = CGAffineTransformRotate(transform, M_PI_2); (出栈)&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;[CATransaction commit];(出栈) 你也可以改变隐式动画的行为（如何渐变）12345 // 行为CATransition *transition = [CATransition animation];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;self.colorLayer.actions = @&#123;@&quot;backgroundColor&quot;: transition&#125;; 但是你把上述的self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;改成self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;你会发现它是瞬间改变的，而不是平滑的动画。因为隐式动画被UIView关联图层给禁了！因为处理UIView动画用UIView的动画函数，而不依赖CATransaction。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习二","slug":"16-03 CoreAnimation二","date":"2016-03-08T13:10:53.000Z","updated":"2018-06-20T02:18:50.714Z","comments":true,"path":"iOS/16-03 CoreAnimation二/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation二/","excerpt":"CAShapeLayer 渲染快，高效实用内存，不会被图层边界剪裁掉，不会出现像素化 一般用CGPath来绘制形状12345678910111213141516171819202122UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(200, 100)]; // 绘制圆[path addArcWithCenter:CGPointMake(170, 100) radius:30 startAngle:0 endAngle:2*M_PI clockwise:YES];// 绘制线条[path moveToPoint:CGPointMake(150, 125)];[path addLineToPoint:CGPointMake(150, 175)];// 绘制，展示CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor clearColor].CGColor;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinRound;shapeLayer.lineCap = kCALineCapRound;shapeLayer.path = path.CGPath;[self.view.layer addSublayer:shapeLayer];// 再提一个 绘制圆角(可选4角)CGRect rect = CGRectMake(50, 50, 100, 100);CGSize radii = CGSizeMake(20, 20);UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];","text":"CAShapeLayer 渲染快，高效实用内存，不会被图层边界剪裁掉，不会出现像素化 一般用CGPath来绘制形状12345678910111213141516171819202122UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(200, 100)]; // 绘制圆[path addArcWithCenter:CGPointMake(170, 100) radius:30 startAngle:0 endAngle:2*M_PI clockwise:YES];// 绘制线条[path moveToPoint:CGPointMake(150, 125)];[path addLineToPoint:CGPointMake(150, 175)];// 绘制，展示CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor clearColor].CGColor;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinRound;shapeLayer.lineCap = kCALineCapRound;shapeLayer.path = path.CGPath;[self.view.layer addSublayer:shapeLayer];// 再提一个 绘制圆角(可选4角)CGRect rect = CGRectMake(50, 50, 100, 100);CGSize radii = CGSizeMake(20, 20);UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii]; CATextLabel: 图层的形式包含了UILabel几乎所有的绘制特性，而且比UILabel渲染的更快哦！(如果你有需求做一个自定制的Label,不防试试这个) 1234567891011121314151617181920212223242526272829303132333435363738CATextLayer *textLayel = [CATextLayer layer]; textLayel.frame = CGRectMake(100, 100, 200, 300); [self.view.layer addSublayer:textLayel]; textLayel.foregroundColor = [UIColor blackColor].CGColor; textLayel.backgroundColor = [UIColor orangeColor].CGColor; textLayel.alignmentMode = @&quot;justified&quot;; textLayel.wrapped = YES; UIFont *font = [UIFont systemFontOfSize:17]; CFStringRef fontName = (__bridge CFStringRef)(font.fontName); CGFontRef fontRef = CGFontCreateWithFontName(fontName); textLayel.font = fontRef; textLayel.fontSize = font.pointSize; /** * 分辨率 */ textLayel.contentsScale = [UIScreen mainScreen].scale; CGFontRelease(fontRef); NSString *text = @&quot;Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy!&quot;; NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:text]; //set text attributes NSDictionary *attribs = @&#123; NSForegroundColorAttributeName : [UIColor blackColor], NSFontAttributeName : font &#125;; [string setAttributes:attribs range:NSMakeRange(0, [text length])]; attribs = @&#123;NSForegroundColorAttributeName : [UIColor redColor]&#125;; [string setAttributes:attribs range:NSMakeRange(6, 5)]; textLayel.string = string; CAGradientLayer : 处理颜色渐变 1234567CAGradientLayer *gradientLayer = [CAGradientLayer layer];gradientLayer.frame = CGRectMake(100, 100, 100, 100);[self.view.layer addSublayer:gradientLayer];gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor blackColor].CGColor];gradientLayer.locations = @[@0,@0.5,@1];gradientLayer.startPoint = CGPointMake(0, 0);gradientLayer.endPoint = CGPointMake(1, 1); CAEmitterLayer : 粒子引擎(直播那些❤️动画之类的) 123456789101112131415161718192021222324252627282930313233343536373839404142CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];// 发射器在xy平面的中心位置emitterLayer.emitterPosition = CGPointMake(self.view.frame.size.width-50,self.view.frame.size.height-50);// 发射器的尺寸大小emitterLayer.emitterSize = CGSizeMake(20, 20);// 渲染模式emitterLayer.renderMode = kCAEmitterLayerUnordered;// 开启三维效果// _emitterLayer.preservesDepth = YES;NSMutableArray *array = [NSMutableArray array];// 创建粒子for (int i = 0; i&lt;10; i++) &#123; // 发射单元 CAEmitterCell *stepCell = [CAEmitterCell emitterCell]; // 粒子的创建速率，默认为1/s stepCell.birthRate = 1; // 粒子存活时间 stepCell.lifetime = arc4random_uniform(4) + 1; // 粒子的生存时间容差 stepCell.lifetimeRange = 1.5; // 颜色 // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]]; // 粒子显示的内容 stepCell.contents = (id)[image CGImage]; // 粒子的名字 // [fire setName:@&quot;step%d&quot;, i]; // 粒子的运动速度 stepCell.velocity = arc4random_uniform(100) + 100; // 粒子速度的容差 stepCell.velocityRange = 80; // 粒子在xy平面的发射角度 stepCell.emissionLongitude = M_PI+M_PI_2;; // 粒子发射角度的容差 stepCell.emissionRange = M_PI_2/6; // 缩放比例 stepCell.scale = 0.3; [array addObject:stepCell];&#125;emitterLayer.emitterCells = array;[self.view.layer addSublayer:emitterLayer];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"CoreAniamtion学习一","slug":"16-03 CoreAnimation一","date":"2016-03-08T11:10:53.000Z","updated":"2018-06-20T02:18:38.458Z","comments":true,"path":"iOS/16-03 CoreAnimation一/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-03 CoreAnimation一/","excerpt":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);","text":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage); @property(copy) NSString *contentsGravity; : 类似于UIView的contentMode 123456789101112kCAGravityCenterkCAGravityTopkCAGravityBottomkCAGravityLeftkCAGravityRightkCAGravityTopLeftkCAGravityTopRightkCAGravityBottomLeftkCAGravityBottomRightkCAGravityResizekCAGravityResizeAspectkCAGravityResizeAspectFill @property BOOL masksToBounds; : 超出位置是否裁切 @property CGRect contentsRect;这个属性决定图片的显示位置，默认是{0，0，1，1}从左上角到左下角显示，你也可以设为其他的,前两个是起点比例，后两个分别对应宽度和高度比例(该属性一般用于给你一张有许多小图的大图，然后你根据自己的需要去拿你需要的图片) @property CGRect contentsCenter; : 类似于UIImage resizableImageWithCapInsets 属性！ @property CGPoint position; : 类似于UIView的Center， 但是它作用的也是UIView的Center而不是Layer的Center哦 @property CGPoint anchorPoint; : 我的理解是layer中心点的位置，默认为{0.5，0.5}，所以居中显示，但是将它设置为{0，0}，那么layer会以{0，0}为中心点显示哦！这时position没变哦！ @property CGFloat zPosition; @property CGFloat anchorPointZ;由于CALayer是存在于3维空间中的，所以我们可以改变他的z轴(你可以理解为Z轴就是垂直严你的屏幕的轴) @property CGFloat cornerRadius; : 圆角半径(我们一般给视图做圆角的时候，如果界面不是太多，可以使用该方法，但是如果是对Cell里面的视图进行圆角设置或者太多视图需要进行圆角设置，就别用这个属性了，因为layer的渲染会耗资源) @property CGFloat borderWidth; @property(nullable) CGColorRef borderColor;边框的Width和颜色，不必多说 @property CGFloat shadowRadius; 阴影模糊度关于阴影的一些属性，建议如cornerRadius一样，使用阴影的时候别用maskToBounds哦！因为阴影在范围外，使用了会被裁剪掉哦！shadowPath @property(nullable) CGColorRef shadowColor; 阴影颜色 @property float shadowOpacity; 阴影透明度 @property CGSize shadowOffset; 阴影偏移量 @property(nullable) CGPathRef shadowPath; 感觉该属性就是为了解决使用上述属性设置阴影好资源诞生的，推荐使用这个属性设置阴影哦！123456layerView.layer.shadowOpacity = 0.5;layerView.layer.shadowColor = [UIColor redColor].CGColor;layerView.layer.shadowOffset = CGSizeMake(10, 10);// layerView.layer.shadowPath = CGPathCreateWithRect(layerView.layer.bounds, NULL);// layerView.layer.shadowPath = CGPathCreateWithRoundedRect(layerView.layer.bounds, layerView.layer.bounds.size.width * 0.5, layerView.layer.bounds.size.width * 0.5, NULL); (void)setAffineTransform:(CGAffineTransform)m; 这个就是UIView的transform实现1234567891011CGAffineTransform 方法CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 移动CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 放缩CGAffineTransformMakeRotation(CGFloat angle) // 旋转CGAffineTransformIdentity // 复位，初始状态混合变换CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) // 在t的基础上移动CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) // 在t的基础上放缩CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) // 在t的基础上旋转注意： 旋转时使用的是弧度而不是角度，你可以利用下列公式转换角度到弧度#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) @property CATransform3D transform; 仿射变换 3D动画 12345CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)CATransform3D的 m34 元素, 用来做透视,m34用于按比例缩放X和Y的值来计算到底要离视角多远。 现在我想我们可以用他们来做一些动画了…","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"Aniamtion","slug":"Aniamtion","permalink":"https://kysonyangs.github.io/tags/Aniamtion/"}]},{"title":"利用pod trunk发布程序","slug":"16-01 利用pod-trunk发布程序","date":"2016-01-20T07:07:56.000Z","updated":"2018-06-20T02:21:13.288Z","comments":true,"path":"iOS/16-01 利用pod-trunk发布程序/","link":"","permalink":"https://kysonyangs.github.io/iOS/16-01 利用pod-trunk发布程序/","excerpt":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose","text":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: xxx- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec cretae 文件名 比如pod spec cretae KLTest 就会生成一个KLTest.podspec 填写podspec内容123456789101112Pod::Spec.new do |s| s.name = &quot;KLTest&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/xxx/KLTest&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;KL&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/xxx/KLTest.git&quot;, :tag =&gt; s.version &#125; s.source_files = &quot;KLTestExample/KLTestExample/KLTest&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint KLTest.podspec 发布podspec pod trunk push KLTest.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.git 参考：https://github.com/Damonvvong/DWCategoryMJ","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"扩展圆角可见调试","slug":"15-11 扩展圆角可见调试","date":"2015-11-20T03:29:44.000Z","updated":"2018-06-20T02:25:34.292Z","comments":true,"path":"iOS/15-11 扩展圆角可见调试/","link":"","permalink":"https://kysonyangs.github.io/iOS/15-11 扩展圆角可见调试/","excerpt":"ios 属性扩展 在IB中可以设置Layer并且看到效果当我们拖控件设置layer的属性时，我们可以不需要在代码里面设置，而是直接了当在IB界面属性中设置，并且直观的看到，是不是很方便呢！！！嘻嘻嘻~~~","text":"ios 属性扩展 在IB中可以设置Layer并且看到效果当我们拖控件设置layer的属性时，我们可以不需要在代码里面设置，而是直接了当在IB界面属性中设置，并且直观的看到，是不是很方便呢！！！嘻嘻嘻~~~一、不用在代码设置 self.view.layer.borderWidth = ... 我们可以添加 User Defined Runtime Attribute 属性也可以设置如此，即可实现，但是不能在IB界面直观的看到，上图Button1，好了，下面说第二种方法….二、IB_DESIGNABLE 和 IBInspectable ，其中IB_DESIGNABLE 修饰 @implementation ， IBInspectable 修饰变量信息，上代码吧 .h @property (nonatomic, assign) IBInspectable CGFloat cornerRadius; .m12345678910IB_DESIGNABLE @implementation KLButton- (void)setCornerRadius:(CGFloat)cornerRadius &#123; self.layer.cornerRadius = cornerRadius; self.layer.masksToBounds = (cornerRadius &gt; 0);&#125;- (CGFloat)cornerRadius &#123; return self.layer.cornerRadius;&#125; 好了，准备完成，设置完成，其他的属性，如borderColor 和 borderWidth 你们自己试试哦~ 在此就不贴代码啦 对了，最后再说一句，在Swift里面使用IBInspectable 和 IBDesignable","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"iOS-Cell1","slug":"15-10 iOS-Cell1","date":"2015-10-25T02:58:10.000Z","updated":"2018-06-20T02:19:43.917Z","comments":true,"path":"iOS/15-10 iOS-Cell1/","link":"","permalink":"https://kysonyangs.github.io/iOS/15-10 iOS-Cell1/","excerpt":"iOS TableViewCell 显示不全的问题一、在使用TableViewCell的时候，发现如下图的问题：","text":"iOS TableViewCell 显示不全的问题一、在使用TableViewCell的时候，发现如下图的问题： 代码实现 好吧，你会发现cell内容显示不全，代码如下： 123456789101112- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; UIImageView *imgv = [[UIImageView alloc] initWithFrame:self.bounds]; imgv.image = [UIImage imageNamed:@&quot;2.jpg&quot;]; [self.contentView addSubview:imgv]; &#125; return self; &#125; 发现这里设置self.bounds 根本无用啊，它还是只显示{320，44},好吧，这是因为在init时，他先加载的是默认的cell.size 也就是{320,44}，所以在此设置的size无效果，那该如何是好呢，其实也很简单，只需重写layoutSubviews ，如下： 1234- (void)layoutSubviews &#123; [super layoutSubviews]; _imgv.frame = self.bounds;&#125; 现在显示完全没问题了 ^_^ xibxib实现cell的时候如果你不加约束的话也会出现显示问题，但是当你加勒约束后就完全没问题了","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"TableView","slug":"TableView","permalink":"https://kysonyangs.github.io/tags/TableView/"}]},{"title":"iOS数组排序","slug":"15-10 iOS数组排序","date":"2015-10-25T02:28:05.000Z","updated":"2018-06-20T02:20:12.817Z","comments":true,"path":"iOS/15-10 iOS数组排序/","link":"","permalink":"https://kysonyangs.github.io/iOS/15-10 iOS数组排序/","excerpt":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图","text":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图 在这里我们要注意的时，它排序的时候如果对于arrayString 来说，它是按字母书序排列的，而不是按照数字大小，这个要注意， arrayNumber 这个数组则没问题，如果你想要按照自己的规则来排序，可以自己写个方法，传到@selector() 里面就行 2、sortedArrayUsingComparator使用这个方法，我们可以在block里面写入自己定义的规则，实现起来也听方便的 123[arrayString sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; return [obj1 integerValue] &gt; [obj2 integerValue];&#125;] 现在就是正确的按照数字大小排序了，嘿嘿嘿~ 3、sortedArrayUsingDescriptors &amp; sortUsingDescriptors前者返回一个排好序的数组，后者则是对自身进行排序，无返回值~哲理我们讲一下前者的方法，不多说，上代码— 12345678910111213141516171819202122232425262728293031323334353637//首先我们定义一个类Person@interface Person : NSObject@property NSString *name;@property NSNumber *age;@end@implementation Person- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;name = %@, age = %@&quot;, self.name, self.age];&#125;@end//然后实例化一个Person数组NSArray *name = @[ @&quot;Allen&quot;, @&quot;Kellem&quot;, @&quot;God&quot;, @&quot;Queen&quot;, @&quot;King&quot;, @&quot;Bob&quot;];NSArray *ages = @[@8, @20, @9, @88, @70, @20]; NSMutableArray *people = [NSMutableArray array];//这里是一个数组的遍历方法，建议大家使用这种方法进行数组的遍历[name enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; Person *person = [[Person alloc] init]; person.name = [name objectAtIndex:idx]; person.age = [ages objectAtIndex:idx]; [people addObject:person];&#125;];// 名字进行排序，降序规则，key可以传nil,或者&quot;self&quot;，在对如下数组排序时可用 NSArray *ages = @[@8, @20, @9, @88, @70, @20];//再多说一句，key 这里用到的类似KVC，其中理念自己体会 =-=NSSortDescriptor *nameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES];// 年龄进行排序，升序规则NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:NO];//然后使用规则进行排序，执行，打印// 这里规则是一个数组，你可以传入多个规则，例如3NSLog(@&quot;By age: %@&quot;, [people sortedArrayUsingDescriptors:@[ageSortDescriptor]]); NSLog(@&quot;By name name: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor]]); NSLog(@&quot;By name, age: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor, ageSortDescriptor]]); 结果如下图： 最后再体验一下其中的KVC奥妙，我们用字典来体验一下 123456789NSArray *dict =@[ @&#123;@&quot;age&quot;:@20&#125;, @&#123;@&quot;age&quot;:@5&#125;, @&#123;@&quot;age&quot;:@70&#125;, @&#123;@&quot;age&quot;:@33&#125;]; NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:YES]; NSArray *arr = [dict sortedArrayUsingDescriptors:@[sort]];NSLog(@&quot;%@&quot;,arr); OK，大功告成~本篇博客到这就结束了，如若后续有神马更新，会继续贴于此处，谢谢大家 I –转载请注明出处–By KellenYangs~","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://kysonyangs.github.io/tags/数组/"}]},{"title":"iOS静态库开发","slug":"15-10 iOS静态库开发","date":"2015-10-21T15:39:35.000Z","updated":"2018-06-20T02:20:29.172Z","comments":true,"path":"iOS/15-10 iOS静态库开发/","link":"","permalink":"https://kysonyangs.github.io/iOS/15-10 iOS静态库开发/","excerpt":"GitHUb多账号使用当使用Github的时候，碰到两个或者多个账号都需要使用的时候，就需要配置一下，使得可以两个账号都很方便的使用。 1.新建user和user2的ssh key #user1 ssh-keygen -t rsa -C &quot;mywork@email.com&quot; #user1的email # 设置名称为id_rsa_user1 Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_user1 #user2 ssh-keygen -t rsa -C &quot;mywork@email.com&quot; #user2的email # 设置名称为id_rsa_user2 Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_user2","text":"GitHUb多账号使用当使用Github的时候，碰到两个或者多个账号都需要使用的时候，就需要配置一下，使得可以两个账号都很方便的使用。 1.新建user和user2的ssh key #user1 ssh-keygen -t rsa -C &quot;mywork@email.com&quot; #user1的email # 设置名称为id_rsa_user1 Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_user1 #user2 ssh-keygen -t rsa -C &quot;mywork@email.com&quot; #user2的email # 设置名称为id_rsa_user2 Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_user2 2.将密钥添加到SSH agent 注意，这里需要将两个密钥都执行加入命令，否则有个会读取不了 ssh-add ~/.ssh/id_rsa_user1 ssh-add ~/.ssh/id_rsa_user2 #如果出现Could not open a connection to your authentication agent的错误，就试着用下面命令： ssh-agent bash ssh-add ~/.ssh/id_rsa_work 3.修改config文件 #如果在~/.ssh目录下找不到config文件，就创建 touch config 然后修改配置如下 # 该文件用于配置私钥对应的服务器 # Default github user(first@mail.com) Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_user1 # second user(second@mail.com) # 建一个github别名，新建的帐号使用这个别名做克隆和更新 Host github2 HostName github.com User git IdentityFile ~/.ssh/id_rsa_user2 4.然后在你的两个github上配置 ssh key 5.测试 #测试user1 ssh -T git@github.com #测试user2 ssh -T github2 本文结束，谢谢大家~ ===-转载请注明出处 -","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/categories/iOS/"}],"tags":[]},{"title":"hexo搭建Github博客","slug":"15-10 hexo搭建Github博客","date":"2015-10-20T16:46:12.000Z","updated":"2018-06-20T02:19:36.082Z","comments":true,"path":"default/15-10 hexo搭建Github博客/","link":"","permalink":"https://kysonyangs.github.io/default/15-10 hexo搭建Github博客/","excerpt":"蛋疼的弄了一晚上，终于将hexo搭建好了，期间碰到许多的问题，记录与此，你我共勉。 环境准备 安装Node到Node.js官网下载最新版本，安装-&gt;直接下一步下一步，傻瓜式安装 安装Git","text":"蛋疼的弄了一晚上，终于将hexo搭建好了，期间碰到许多的问题，记录与此，你我共勉。 环境准备 安装Node到Node.js官网下载最新版本，安装-&gt;直接下一步下一步，傻瓜式安装 安装Git 1.设置你的用户名和密码 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youemail@example.com&quot; 2.生成密钥,一直回车 1ssh -keygen -t rsa -C &quot;youemail&quot; 3.进入~/.ssh目录, 将id_rsa.pub文件里面的内容（查看方法 [cat id_rsa.pub] ）复制到github-&gt;Setting-&gt;ssh-&gt;ADD ssh中 4.最后验证一下： 1ssh -T git@github.com 安装hexo磨人的小妖精来了，这个看自己的电脑配置以及npm node.js 版本的不同，碰到的问题也各不相同，在这，我只是将我遇到的一些问题写在这，以供你可以更好更迅速的配置好hexo 好了，话不多说，进入正题 1.安装hexo，执行如下命令 1234npm install -g hexo#当然，你在这就可能会遇到问题了，不要慌#只是可能没有权限而已，下面这行代码可以帮助你sudo npm install -g hexo 2.初始化，然后执行init命令初始化hexo到指定目录 12345#坑爹的是当前并没有hexo目录，所以，当务之急，你得先创建一个 hexo 文件夹 mkdir hexo #然后，你就可以初始化了，这应该没问题cd hexohexo init 3.生成静态页面 12345#执行下面命令，生成静态页面hexo generate#当然你可能会有错，应为从这里开始你就可能会感觉飘ri飘le欲gou仙le了,不过，终端还是提示你了，请先运行如下代码npm install hexo --save#然后，应该木有神马问题了 4.本地启动 启动本地服务，进行文章预览调试 12345hexo server #当你输入上面代码的时候，如果正常运行还好，如果提示命令不存在，那你真的会感觉一大群草泥马飞过，这尼玛正常的命令，竟然说没有，坑啊#由于在Hexo 3.0 后server被单独出来了，需要安装server，安装命令如下：npm install hexo-server --save#建议再运行一遍 npm install 以防还有错误 5.将本地的内容同步到github 先将_config.yml文件中的信息配置下 12345678910111213141516171819202122# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/#站点信息# Sitetitle: #你的名字咯subtitle: #二级titledescription: #描述author: email: #邮箱language: zh-CN。。。。。。#当然最重要的是下面，这个一定得配好## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/yougithubname/yougithubname.github.io.git branch: master --- #至此，config已经配好，你以为可以 上传同步到github了，可是往往现实是残酷的，当你键入 hexo deploy 的时候，MD ，他竟然提示ERROR Deployer not found: github,哭都哭不出来啊，哎 #npm install hexo-deployer-git --save 更换主题找到需要的主题的githubgit clone theme.git themes/themenameeg: git clone https://github.com/iissnan/hexo-theme-next themes/next__config.yml 修改theme为themename即可 至此，本篇教程结束，这也是博主第一篇博客，请多多支持，写的不好的地方请见谅，博主也处在摸索阶段，后续可能会有新的内容，请多多关注！ ~ 转载请注明出处 ~","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://kysonyangs.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://kysonyangs.github.io/tags/git/"}]},{"title":"Mac工具整理","slug":"15-06 Mac工具","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:07:15.470Z","comments":true,"path":"整理/15-06 Mac工具/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 Mac工具/","excerpt":"","text":"ss免费账号","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"性能监控与优化","slug":"15-06 性能监控与优化","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:07:10.301Z","comments":true,"path":"整理/15-06 性能监控与优化/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 性能监控与优化/","excerpt":"","text":"FLEX Flipboard团队开发的一款应用内Debug工具，可以很方便的查看和调整UI的层级关系。 MLeaksFinder Tencent 开源的 iOS 平台的自动内存泄漏检测工具 iOS-Monitor-Platform iOS 性能监控 SDK —— Wedjat（华狄特）","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"开源项目整理","slug":"15-06 开源项目","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:07:12.822Z","comments":true,"path":"整理/15-06 开源项目/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 开源项目/","excerpt":"","text":"Mac WWDC WWDC app for Mac OC MONO 高仿MONO(猫弄) 斗鱼弹幕分析工具 Monkey GitHub 客户端 Coding-iOS Coding iOS 客户端 GitBucket GitBucket iOS App 仿面包旅行 仿面包旅行，ReactiveCocoa+MVVM YSRun 易瘦跑步 iOS客户端 服务器不可用 MiaowShow iOS视频直播项目 bilibili-fake 仿Bilibili iOS客户端 Swift ZHNCosmos 别具一格的微博客户端 TodayNews 高仿今日头条 Gank Gank客户端 Yep Yep 是一款非常小巧而轻量化的社交 App zhnbilibili swift精仿bilibili","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"开发工具","slug":"15-06 开发工具","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:07:13.522Z","comments":true,"path":"整理/15-06 开发工具/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 开发工具/","excerpt":"","text":"FengNiao 猫神开源的 用于清理Xcode中未使用的资源的命令行工具。 SwiftGen 自动生成 Asset 的 image enum 的 Extension","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"博客整理","slug":"15-06 博客&Git","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:15:03.791Z","comments":true,"path":"整理/15-06 博客&Git/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 博客&Git/","excerpt":"","text":"GitHub Author GitHub iOS-Tips SwiftTips iOS沙龙 dev-blog LefexWork Halfrost-Field 冰霜之地 iOS 开发进阶之路 Blog OneV 戴铭 mrpeak 苹果核加入 WeRead isaced bestswifter RW 包含图文混排 Draveness’s Blog 玉令天下的博客 矢倉 臧成威 雷纯锋 南峰子 叶孤城 叶孤城, 优秀 iOS 开发工程师, 发表的文章都有很多干货, 对源码解析类文章写得浅显易懂, 并时常总结一些 iOS 开发技巧, 值得一读 100mango iOS, Swift, Objective-C 心得 new Kerwin 逆行云 网站 Swifter","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]},{"title":"三方库整理","slug":"15-06 三方库","date":"2015-06-09T16:00:00.000Z","updated":"2018-06-21T02:07:14.820Z","comments":true,"path":"整理/15-06 三方库/","link":"","permalink":"https://kysonyangs.github.io/整理/15-06 三方库/","excerpt":"","text":"OC&amp;Swift LSAnimator 用少量的代码实现复杂而又易于维护的动画。 JTCalendar 日历控件JTCalendar lottie-ios 动画库 PNChart 使用的简单而美观的图表库 OC Table高度自动适配 LBXScan 二维码、扫码、扫一扫、ZXing、ZBar、iOS系统AVFoundation扫码封装，扫码界面效果封装 DKNightVersion 更换主题 BabyBluetooth 一个非常容易使用的蓝牙库,适用于ios和os VKVideoPlayer 视频播放器 FLAnimatedImage iOS的高性能动画GIF引擎 TYAttributedLabel 属性文本控件，图文混排显示 CYLTabBarController【中国特色 TabBar】最低只需传两个数组即可完成主流App框架搭建 TZImagePickerController 支持多选、选原图和视频的图片选择器 GYDataCenter SQLite 替代方案 LunarCore 全功能农历日历库 XJYChart 图表 支持动画，点击，滚动，区域高亮 AAChartKit 极其精美而又强大的 iOS 图表组件库 ZFPlayer 支持定制任何播放器SDK和控制层 WMPlayer AVPlayer的封装，继承UIView Swift SwifterSwift Swift 扩展 ExSwift Swift 扩展 EZSwiftExtensions 标准类型和类扩展 SwiftString 全面轻量级字符串扩展 SwiftDate 管理日期和时区的最佳方法 DateTools 轻松实现日期和时间 Timepiece 日期扩展 KeychainAccess 钥匙串 SwiftyUserDefaults NSUserDefaults 扩展 DynamicColor 颜色扩展 XCGLogger Swift Log swiftScan 二维码 各种码识别，生成，界面效果 MonkeyKing 不用第三方分享微信/微博 Kanna HTML/XML解析 Fuzi HTML/XML解析 Ji HTML/XML解析 SwiftyJSON 处理JSON数据 handyjson alibaba 开源的模型解析库 SwiftyTimer NSTimer 易用扩展 ESTabBarController 高度自定制的Tabbar animated-tab-bar Tabbar 可动画 Then 初始化器的超甜语法糖 CVCalendar 自定义可视化日历 FSPagerView 轮播图 很多效果 [SkyFloatingLabelTextField] (https://github.com/Skyscanner/SkyFloatingLabelTextField) 浮标模式的TextField Localize-Swift 国际化 Disk 磁盘存储 FAPanels 左右侧边栏 NVActivityIndicatorView 多种 loading 动画 波纹动画","categories":[{"name":"整理","slug":"整理","permalink":"https://kysonyangs.github.io/categories/整理/"}],"tags":[]}]}