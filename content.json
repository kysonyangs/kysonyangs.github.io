{"meta":{"title":"kysonyangs","subtitle":"Stay Hungry, Stay Foolish","description":"kysonyangs个人站，备忘","author":"kysonyangs","url":"https://kysonyangs.github.io"},"pages":[{"title":"","date":"2018-06-19T02:40:54.000Z","updated":"2018-06-20T02:06:23.137Z","comments":false,"path":"about/index.html","permalink":"https://kysonyangs.github.io/about/index.html","excerpt":"","text":"个人简介： KysonYangs iOSer 来自江西 现居上海 Email: kysonyangs@gmail.com"},{"title":"categories","date":"2018-06-19T02:34:25.000Z","updated":"2018-06-19T02:34:35.000Z","comments":false,"path":"categories/index.html","permalink":"https://kysonyangs.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-19T02:33:55.000Z","updated":"2018-06-19T02:34:15.000Z","comments":false,"path":"tags/index.html","permalink":"https://kysonyangs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"R.Swift使用","slug":"R.Swift使用","date":"2019-08-12T12:32:33.000Z","updated":"2020-05-16T05:40:34.454Z","comments":true,"path":"default/R.Swift使用/","link":"","permalink":"https://kysonyangs.github.io/default/R.Swift使用/","excerpt":"R.Swift 高效引用资源文件 R.swift 介绍 R.swift 安装配置 R.swift 使用 R.swift 介绍 R.Swift 是一款基于 Swift 平台，针对 iOS 以及 tvOS 开发的资源引用框架 避免使用字符串来构造某些资源实例 R.Swift 能够使用类似语法 R.资源类型.资源名称 来对某资源进行引用构建 R.Swift 有着动态生成代码的机制, 它具有以下优点： 代码自动补全：就像输入其他的代码一样，R.Swift 支持 IDE 的代码自动补全 自动检测: 可以自动检测代码是否存在问题, 当我们的资源文件名修改的时候, 这是就会提示资源引用错误","text":"R.Swift 高效引用资源文件 R.swift 介绍 R.swift 安装配置 R.swift 使用 R.swift 介绍 R.Swift 是一款基于 Swift 平台，针对 iOS 以及 tvOS 开发的资源引用框架 避免使用字符串来构造某些资源实例 R.Swift 能够使用类似语法 R.资源类型.资源名称 来对某资源进行引用构建 R.Swift 有着动态生成代码的机制, 它具有以下优点： 代码自动补全：就像输入其他的代码一样，R.Swift 支持 IDE 的代码自动补全 自动检测: 可以自动检测代码是否存在问题, 当我们的资源文件名修改的时候, 这是就会提示资源引用错误 R.swift 安装配置 安装 CocoaPods pod &#39;R.swift&#39; 安装 配置 Build Phases -&gt; New Run Script Phase (-&gt; 重命名为 R.swift) 将 👆 添加的 Run Script 拖动到 Check Pods Manifest.lock 下面 添加脚本&quot;$PODS_ROOT/R.swift/rswift&quot; generate &quot;$SRCROOT/R.generated.swift&quot; 在 Input Files 下面添加 $TEMP_DIR/rswift-lastrun 在 Output Files 下面添加 $SRCROOT/R.generated.swift Command+B 编译项目，在项目代码目录下，会生成一个 R.generated.swift 的文件，将它拖如项目中 注意事项 不要勾选 Copy items if needed 选项，因为每次编译都会生成新的 R.generated.swift 文件，copy 的话，旧的 R.generated.swift 将不会被覆盖 每当我们修改了资源，我们需要 Command + B 来编译一下项目从而让 R.Swift 自动进行配置更新 在 .gitignore 添加 *.generated.swift 避免不必要的麻烦 如果想自定义位置存放 R.generated.swift 当按照上面配置安装 Build 后成功生成 R.generated.swift 文件后 拖动 R.generated.swift 到逆向存放的位置 修改脚本&quot;$PODS_ROOT/R.swift/rswift&quot; generate &quot;$SRCROOT/(路径)/R.generated.swift&quot; 修改 Output Files $SRCROOT/(路径)/R.generated.swift 删除项目 R.generated.swift,重新添加 在此 Build 即可 R.swift 使用 图片 1234//传统方式let oldImage = UIImage(named: &quot;yellow-image&quot;)//R.Swift方式let newImage = R.image.yellowImage() 字体 1234//传统方式let lightFontTitle = UIFont(name: &quot;Acme-Light&quot;, size: 22)//R.Swift方式let lightFontTitle = R.font.acmeLight(size: 22) 数据文件 1234567//传统方式let jsonData = Bundle.main.path(forResource: &quot;menuList&quot;, ofType: &quot;json&quot;)let jsonUrl1 = Bundle.main.url(forResource: &quot;menuList&quot;, withExtension: &quot;json&quot;)//R.Swift方式let jsonData2 = R.file.menuListJson.path()let newUrl = R.file.menuListJson() Storyboards 1234567891011121314//传统方式let nibVC1 = UIStoryboard(name: &quot;NibHome&quot;, bundle: nil).instantiateInitialViewController() ?? UIViewController()let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: nil)let initialTabBarController = storyboard.instantiateInitialViewController() as? UITabBarControllerlet settingsController = storyboard.instantiateViewController(withIdentifier: &quot;settingsController&quot;) as? SettingsControllerSettingsController//R.Swift方式let nibVC = R.storyboard.nibHome().instantiateInitialViewController() ?? UIViewController()let storyboard = R.storyboard.main()let initialTabBarController = R.storyboard.main.initialViewController()let settingsController = R.storyboard.main.settingsController() Nibs 12345678910111213141516//传统方式let nameOfNib = &quot;CustomView&quot;let customViewNib = UINib(nibName: &quot;CustomView&quot;, bundle: nil)let rootViews = customViewNib.instantiate(withOwner: nil, options: nil)let customView = rootViews[0] as? CustomViewlet viewControllerWithNib = CustomViewController(nibName: &quot;CustomView&quot;, bundle: nil)//R.Swift方式let nameOfNib = R.nib.customView.namelet customViewNib = R.nib.customView()let rootViews = R.nib.customView.instantiate(withOwner: nil)let customView = R.nib.customView.firstView(owner: nil)let viewControllerWithNib = CustomViewController(nib: R.nib.customView) cell复用 12345678910111213141516171819//传统方式let cellNib = UINib(nibName: &quot;NibTableViewCell&quot;, bundle: nil)tableView.register(cellNib, forCellReuseIdentifier: &quot;NibTableViewCell&quot;)func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;NibTableViewCell&quot;, for: indexPath) cell?.leftLabel.text = dataArr[indexPath.row] return cell ?? UITableViewCell()&#125;//R.Swift方式tableView.register(R.nib.nibTableViewCell(), forCellReuseIdentifier: R.nib.nibTableViewCell.name)func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: R.nib.nibTableViewCell.name, for: indexPath) as? NibTableViewCell cell?.leftLabel.text = dataArr[indexPath.row] return cell ?? UITableViewCell()&#125;","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"XCGLogger 使用","slug":"XCGLogger日志框架","date":"2019-08-12T08:10:05.000Z","updated":"2020-05-16T05:41:23.421Z","comments":true,"path":"default/XCGLogger日志框架/","link":"","permalink":"https://kysonyangs.github.io/default/XCGLogger日志框架/","excerpt":"XCGLogger的介绍 XCGLogger的安装与配置 基本用法 XCGLogger初始化 日志输出 运行效果 更高级的初始化方法 过滤日志信息 按文件名过滤 按标签过滤 选择性的执行代码 日期格式化 自动切换配置 在后台进行日志处理 下面两种方法都是实现将日志文件输出放在后台线程中进行： 也可以通过build flags来实现程序在调试、生产自动使用不同线程 实现日志文件的增量记录 实现日志文件的转储 XCGLogger的介绍 XCGLogger 是一个 debug 日志框架，可用于 Swift 项目中 使用 XCGLogger ，除了可以将日志详细信息输出到控制器台外，还可以输出到指定的文件中去 虽然使用起来同 NSLog() 或 print() 差不多，但 XCGLogger 会附带更多的额外信息，比如：日期、函数名、文件名和行号","text":"XCGLogger的介绍 XCGLogger的安装与配置 基本用法 XCGLogger初始化 日志输出 运行效果 更高级的初始化方法 过滤日志信息 按文件名过滤 按标签过滤 选择性的执行代码 日期格式化 自动切换配置 在后台进行日志处理 下面两种方法都是实现将日志文件输出放在后台线程中进行： 也可以通过build flags来实现程序在调试、生产自动使用不同线程 实现日志文件的增量记录 实现日志文件的转储 XCGLogger的介绍 XCGLogger 是一个 debug 日志框架，可用于 Swift 项目中 使用 XCGLogger ，除了可以将日志详细信息输出到控制器台外，还可以输出到指定的文件中去 虽然使用起来同 NSLog() 或 print() 差不多，但 XCGLogger 会附带更多的额外信息，比如：日期、函数名、文件名和行号 XCGLogger的安装与配置 从 GitHub 下载最新的代码, 并拖入项目 或者使用 CocoaPods 或 Carthage 基本用法XCGLogger初始化 定义一个全局的 XCGLogger 日志对象，并进行初始化 选择打印所有的日志信息（级别、方法名、文件名、行号） 日志除了会打印在控制台中外，还会同步输出到文件中（Library/Caches/log.txt） 同时日志在控制台打印和文件输出的消息级别一样，都是 debug 级 12345678910111213141516import XCGLoggerlet XCCacheDirectory: URL = &#123; let urls = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask) return urls[urls.endIndex - 1]&#125;()let log: XCGLogger = &#123; let log = XCGLogger.default // 日志文件地址 let logPath: URL = XCCacheDirectory.appendingPathComponent(&quot;XCGLogger_Log.txt&quot;) log.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true, writeToFile: logPath) return log&#125;() 日志输出通过 XCGLogger内置的方法，我们可以输出各种消息级别的日志信息。比如下面样例我们打印从低到高各种级别的日志 123456log.verbose(&quot;一条verbose级别消息：程序执行时最详细的信息。&quot;)log.debug(&quot;一条debug级别消息：用于代码调试。&quot;)log.info(&quot;一条info级别消息：常用与用户在console.app中查看。&quot;)log.warning(&quot;一条warning级别消息：警告消息，表示一个可能的错误。&quot;)log.error(&quot;一条error级别消息：表示产生了一个可恢复的错误，用于告知发生了什么事情。&quot;)log.severe(&quot;一条severe error级别消息：表示产生了一个严重错误。程序可能很快会奔溃。&quot;) 运行效果由于我们前面将日志显示级别设置成 debug，所以 verbose 级别的日志消息就不会打印 更高级的初始化方法通常情况下我们只需要像上面样例一样，使用 setup 方法初始化 XCGLogger对象相关配置即可。方便简单，代码也少。 当然 XCGLogger 也支持更加灵活的配置，使得我们日志记录会更加可控。比如：想让控制台显示的信息与日志文件里记录的信息不一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 创建一个logger对象let log = XCGLogger(identifier: &quot;advancedLogger&quot;, includeDefaultDestinations: false)// 控制台输出let systemDestination = AppleSystemLogDestination(identifier: &quot;advancedLogger.systemDestination&quot;)// 设置控制台输出的各个配置项systemDestination.outputLevel = .debugsystemDestination.showLogIdentifier = falsesystemDestination.showFunctionName = truesystemDestination.showThreadName = truesystemDestination.showLevel = truesystemDestination.showFileName = truesystemDestination.showLineNumber = truesystemDestination.showDate = true// logger对象中添加控制台输出log.add(destination: systemDestination)// 日志文件地址let logPath: URL = XCCacheDirectory.appendingPathComponent(&quot;XCGLogger_Log.txt&quot;)let fileDestination = FileDestination(writeToFile: logPath, identifier: &quot;advancedLogger.fileDestination&quot;)// 设置文件输出的各个配置项fileDestination.outputLevel = .debugfileDestination.showLogIdentifier = falsefileDestination.showFunctionName = truefileDestination.showThreadName = truefileDestination.showLevel = truefileDestination.showFileName = truefileDestination.showLineNumber = truefileDestination.showDate = true// Xcode8以上无效了// 设置输出语句颜色和样式（搭配XcodeColors使用）/**let ansiColorLogFormatter: ANSIColorLogFormatter = ANSIColorLogFormatter()ansiColorLogFormatter.colorize(level: .verbose, with: .colorIndex(number: 244), options: [.faint])ansiColorLogFormatter.colorize(level: .debug, with: .black)ansiColorLogFormatter.colorize(level: .info, with: .blue, options: [.underline])ansiColorLogFormatter.colorize(level: .warning, with: .red, options: [.faint])ansiColorLogFormatter.colorize(level: .error, with: .red, options: [.bold])ansiColorLogFormatter.colorize(level: .severe, with: .white, on: .red)fileDestination.formatters = [ansiColorLogFormatter]*/// 文件输出在后台处理fileDestination.logQueue = XCGLogger.logQueue// logger对象中添加控制台输出log.add(destination: fileDestination)// 开始启用log.logAppDetails()// 更改权限提示 eg: [debug]=&gt;&quot;🔹&quot;let emojiLogFormatter = PrePostFixLogFormatter()emojiLogFormatter.apply(prefix: &quot;🗯🗯🗯 &quot;, postfix: &quot; 🗯🗯🗯&quot;, to: .verbose)emojiLogFormatter.apply(prefix: &quot;🔹🔹🔹 &quot;, postfix: &quot; 🔹🔹🔹&quot;, to: .debug)emojiLogFormatter.apply(prefix: &quot;ℹ️ℹ️ℹ️ &quot;, postfix: &quot; ℹ️ℹ️ℹ️&quot;, to: .info)emojiLogFormatter.apply(prefix: &quot;⚠️⚠️⚠️ &quot;, postfix: &quot; ⚠️⚠️⚠️&quot;, to: .warning)emojiLogFormatter.apply(prefix: &quot;‼️‼️‼️ &quot;, postfix: &quot; ‼️‼️‼️&quot;, to: .error)emojiLogFormatter.apply(prefix: &quot;💣💣💣 &quot;, postfix: &quot; 💣💣💣&quot;, to: .severe)log.formatters = [emojiLogFormatter] 过滤日志信息按文件名过滤 下面代码不显示 AppDelegate.swift 中输出的日志，其它文件日志都会显示 1log.filters = [FileNameFilter(excludeFrom: [&quot;AppDelegate.swift&quot;], excludePathWhenMatching: true)] 下面代码只显示 AppDelegate.swift 中输出的日志，其它文件日志都不显示 1log.filters = [FileNameFilter(includeFrom: [&quot;AppDelegate.swift&quot;], excludePathWhenMatching: true)] 按标签过滤 使用自定义的标签字符串 比如我们在输出一条 debug 消息时，附上一个自定义的标签（sensitive） 12let sensitiveTag = XCGLogger.Constants.userInfoKeyTagslog.debug(&quot;这里进行用户身份验证。&quot;, userInfo: [tags: &quot;sensitive&quot;]) 下面设置分别是不显示这个标签的日志，以及只显示这个标签的日志 12345// 下面代码不显示标签为&quot;sensitive&quot;的日志，其它日志都会显示log.filters = [TagFilter(excludeFrom: [&quot;sensitive&quot;])]// 下面代码只显示标签为&quot;sensitive&quot;的日志，其它日志都不会显示log.filters = [TagFilter(includeFrom: [&quot;sensitive&quot;])] 通过扩展 Tag 和 Dev 这两个标签结构体Tag 和 Dev 是 XCGLogger 自带的，我们这里通过扩展，在其上面添加一个些自定义标签。 12345678910extension Tag &#123; static let sensitive = Tag(&quot;sensitive&quot;) static let ui = Tag(&quot;ui&quot;) static let data = Tag(&quot;data&quot;)&#125;extension Dev &#123; static let dave = Dev(&quot;dave&quot;) static let sabby = Dev(&quot;sabby&quot;)&#125; 我们日志输出时可以混合使用多个标签： 12345// 设置多个标签log.debug(&quot;A tagged log message&quot;, userInfo: Dev.dave | Tag.sensitive)// 设置单个标签log.debug(&quot;Another tagged log message&quot;, userInfo: Dev.dave.dictionary) 下面根据便签进行日志过滤： 12345// 下面代码不显示标签只为&quot;dave&quot;或&quot;sensitive&quot;的日志，其它日志都会显示log.filters = [TagFilter(excludeFrom: [Dev.dave, Tag.sensitive])]// 下面代码只显示标签为&quot;dave&quot;或&quot;sensitive&quot;的日志，其它日志都不会显示log.filters = [TagFilter(includeFrom: [Dev.dave, Tag.sensitive])] 选择性的执行代码有时我们日志输出前要进行一些计算或操作，再将结果通过日志打印出来。由于这些操作与程序实际运行无关，只是用于日志打印，那么我们可以将其放置在日志方法闭包中。这样既保证代码的干净，同时如果日志不输出的话也不会浪费系统资源。 比如下面样例，如果我们将日志消息级别调到 debug以上，那么下面日志不会输出，且内部的循环操作自然也不会执行。 12345678log.debug &#123; var total = 0.0 for receipt in receipts &#123; total += receipt.total &#125; return &quot;Total of all receipts: \\(total)&quot;&#125; 日期格式化默认日志输出的格式是 “2000-01-01 00:00:00.000” 这种形式。当然我们也可以改成任意的自定义的格式。1234let dateFormatter = DateFormatter()dateFormatter.dateFormat = &quot;MM/dd/yyyy hh:mma&quot;dateFormatter.locale = Locale.currentlog.dateFormatter = dateFormatter 自动切换配置通过使用 Swift 的编译标志（build flags）,我们可以在程序调试、生产版本中自动使用不同的日志级别和日志条目。1234567#if DEBUGlog.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)#elselog.setup(level: .severe, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)#endif 在后台进行日志处理默认情况下，日志输出是在调用它们的进程里进行的。这样可以确保日志消息可以立刻显示，方便我们使用断点调试时可以立刻看到结果。 但在发布的生产版本中，如果日志也在当前线程中执行会对性能造成一些影响。我们可以指定日志目标进程使用哪个执行队列中。 下面两种方法都是实现将日志文件输出放在后台线程中进行：12345//方式1fileDestination.logQueue = XCGLogger.logQueue//方式2fileDestination.logQueue = DispatchQueue.global(qos: .background) 也可以通过build flags来实现程序在调试、生产自动使用不同线程1234567891011#if DEBUG log.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)#else log.setup(level: .severe, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true) if let consoleLog = log.logDestination(XCGLogger.Constants.baseConsoleDestinationIdentifier) as? ConsoleDestination &#123; consoleLog.logQueue = XCGLogger.logQueue &#125;#endif 实现日志文件的增量记录默认情况下，日志文件的输出的是覆盖模式的。也就是说，我们指定了一个日志文件路径，程序每次重新启动时，如果这个文件原来就存在，其内容也会被覆盖。 我们可以在日志配置时将 shouldAppend 参数设置为 true，这样如果原来的文件存在，也不会重新覆盖。而是将新日志信息添加到文件尾部。* 同时 appendMarker可以设置个字符串，其在每次程序启动时会自动添加到日志文件中。方便我们区分开每次程序运行的日志。*1234567...//文件出输出let fileDestination = FileDestination(writeToFile: logURL, identifier: &quot;advancedLogger.fileDestination&quot;, shouldAppend: true, appendMarker: &quot;-- Relauched App --&quot;)... 实现日志文件的转储上面的样例中，我们都是将日志记录到 Caches 文件夹下的 log.txt。如果是增量日志的话，那个这个文件就会越来越大。所以我们可以通过 rotateFile(to:) 方法实现日志的转储。比如：每隔一段时间，或每当日志文件到一定大小时调用下该方法，将日志内容转储到另一个文件中。（注意：转储后原来日志文件里的内容会清空。） 具体转储操作的步骤如下： 首先通过 XCGLogger 的 destination(withIdentifier:) 方法获取 FileDestination 对象。 再调用 FileDestination 对象的 rotateFile(to:) 方法将日志文件转储到指定路径。 rotateFile(to:) 方法执行成功后会返回 true。根据结果我们可以进行一些后续操作。比如：压缩、邮件发送日志文件等等。 下面代码我们将日志文件转储到用户文档目录下：1234567891011// 获取FileDestinationlet fileDestination = log.destination(withIdentifier: &quot;advancedLogger.fileDestination&quot;) as! FileDestination// 获取用户文档目录let documentPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]let logURL = documentPath.appendingPathComponent(&quot;log.txt&quot;)// 将当前的日志文件复制到用户文档目录中去fileDestination.rotateFile(to: logURL)","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"SwiftLint 规则收录","slug":"SwiftLint规则","date":"2019-08-11T11:32:33.000Z","updated":"2020-05-16T05:39:17.487Z","comments":true,"path":"default/SwiftLint规则/","link":"","permalink":"https://kysonyangs.github.io/default/SwiftLint规则/","excerpt":"规则目录，按字母排序排列 anyobject_protocol对纯类协议使用 AnyObject 而不是 class 识别码 默认是否启用 是否支持自动更正 类型 anyobject_protocol 未启用 yes lint 示例 12345678910// 推荐protocol SomeProtocol &#123;&#125;protocol SomeClassOnlyProtocol: AnyObject &#123;&#125;protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123;&#125;@objc protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123;&#125;// 不推荐，触发警告protocol SomeClassOnlyProtocol: class &#123;&#125;protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;&#125;@objc protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;&#125;","text":"规则目录，按字母排序排列 anyobject_protocol对纯类协议使用 AnyObject 而不是 class 识别码 默认是否启用 是否支持自动更正 类型 anyobject_protocol 未启用 yes lint 示例 12345678910// 推荐protocol SomeProtocol &#123;&#125;protocol SomeClassOnlyProtocol: AnyObject &#123;&#125;protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123;&#125;@objc protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123;&#125;// 不推荐，触发警告protocol SomeClassOnlyProtocol: class &#123;&#125;protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;&#125;@objc protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;&#125; array_init序列转化成数组时, 优先使用数组转化, 而不是seq.map{$0} 将序列转换为数组 识别码 默认是否启用 是否支持自动更正 类型 array_init 未启用 no lint 示例 123456789101112131415161718192021222324252627282930// 推荐Array(foo)foo.map &#123; $0.0 &#125;foo.map &#123; $1 &#125;foo.map &#123; $0() &#125;foo.map &#123; ((), $0) &#125;foo.map &#123; $0! &#125;foo.map &#123; $0! /* force unwrap */ &#125;foo.something &#123; RouteMapper.map($0) &#125;foo.map &#123; !$0 &#125;foo.map &#123; /* a comment */ !$0 &#125;// 不推荐，触发警告foo.map(&#123; $0 &#125;)foo.map &#123; $0 &#125;foo.map &#123; return $0 &#125;foo.map &#123; elem in elem&#125;foo.map &#123; elem in return elem&#125;foo.map &#123; (elem: String) in elem&#125;foo.map &#123; elem -&gt; String in elem&#125;foo.map &#123; $0 /* a comment */ &#125;foo.map &#123; /* a comment */ $0 &#125; attributes函数和类型中，属性应该在一行 识别码 默认是否启用 是否支持自动更正 类型 attributes 未启用 no style 示例 1234567// 推荐@objc var x: String@IBOutlet private var label: UILabel// 不推荐，触发警告@objcvar x: String block_based_kvo使用Swift 3.2+时，首选系统的KVO 的API和keypath 识别码 默认是否启用 是否支持自动更正 类型 block_based_kvo 启用 no idiomatic 示例 1234567891011// 推荐let observer = foo.observe(\\.value, options: [.new]) &#123; (foo, change) in print(change.newValue)&#125;// 不推荐，触发警告class Foo: NSObject &#123; override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123;&#125;&#125; class_delegate_protocol委托协议应该仅是class，可以被弱引用 识别码 默认是否启用 是否支持自动更正 类型 默认配置 class_delegate_protocol 启用 no lint 示例 123456789101112131415// 推荐protocol FooDelegate: class &#123;&#125;protocol FooDelegate: class, BarDelegate &#123;&#125;protocol Foo &#123;&#125;class FooDelegate &#123;&#125;@objc protocol FooDelegate &#123;&#125;@objc(MyFooDelegate)protocol FooDelegate &#123;&#125;protocol FooDelegate: BarDelegate &#123;&#125;protocol FooDelegate: AnyObject &#123;&#125;protocol FooDelegate: NSObjectProtocol &#123;&#125;// 不推荐，触发警告protocol FooDelegate &#123;&#125;protocol FooDelegate: Bar &#123;&#125; Closing Brace Spacing小括号包含大括号的话之间不能有空格 识别码 默认是否启用 是否支持自动更正 类型 默认配置 closing_brace 启用 yes style 示例 12345678910// 推荐[1, 2].map(&#123; $0 &#125;)[1, 2].map( &#123; $0 &#125;)// 不推荐，触发警告[1, 2].map(&#123; $0 &#125; )[1, 2].map(&#123; $0 &#125; )[1, 2].map( &#123; $0 &#125;) Closure Body Length必报的函数体不应该太多行,20行警告，100行报错 识别码 默认是否启用 是否支持自动更正 类型 closure_body_length 未启用 no metrics Closure End Indentation闭包的封闭端和开始端有相同的缩进 就是 大括号（一般是方法）上下对齐的问题，这样使code看起来更加整洁 识别码 默认是否启用 是否支持自动更正 类型 默认配置 closure_end_indentation 未启用 no style 示例 123456789101112131415161718// 推荐[1, 2].map &#123; $0 + 1 &#125;SignalProducer(values: [1, 2, 3]) .startWithNext &#123; number in print(number) &#125;function &#123; ..........&#125;// 不推荐，触发警告SignalProducer(values: [1, 2, 3]) .startWithNext &#123; number in print(number)&#125;function &#123; .......... &#125; Closure Parameter Position闭包参数位置，闭包参数应该和大括号左边在同一行 识别码 默认是否启用 是否支持自动更正 类型 默认配置 closure_parameter_position 启用 no style 示例 1234567891011121314151617181920212223// 推荐let names = [1, 2, 3]names.forEach &#123; (number) in print(number)&#125;let names = [1, 2, 3]names.map &#123; number in number + 1&#125;// 不推荐，触发警告let names = [1, 2, 3]names.forEach &#123; (number) in print(number)&#125;let names = [1, 2, 3]names.map &#123; number in number + 1&#125; Closure Spacing在闭包的{}中间要有一个空格,如map({ $0 }) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 closure_spacing 未启用 no style 示例 123456789// 推荐map(&#123; $0 &#125;)[].map (&#123; $0.description &#125;)// 不推荐，触发警告map(&#123;$0 &#125;)map(&#123; $0&#125;)map(&#123;$0&#125;)[].map (&#123;$0.description &#125;) Collection Element Alignment集合中的所有元素应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 collection_alignment 未启用 no style 示例 123456789101112131415161718192021222324// 推荐doThings(arg: [ &quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;fizz&quot;: 2, &quot;buzz&quot;: 2])let abc = [ &quot;alpha&quot;: &quot;a&quot;, &quot;beta&quot;: &quot;b&quot;, &quot;gamma&quot;: &quot;g&quot;, &quot;delta&quot;: &quot;d&quot;, &quot;epsilon&quot;: &quot;e&quot;]let abc = [1, 2, 3, 4]// 不推荐，触发警告let abc = [ &quot;alpha&quot;: &quot;a&quot;, &quot;beta&quot;: &quot;b&quot;, &quot;gamma&quot;: &quot;g&quot;, &quot;delta&quot;: &quot;d&quot;, &quot;epsilon&quot;: &quot;e&quot;] Colon冒号应该紧挨左边，右边空一格 识别码 默认是否启用 是否支持自动更正 类型 默认配置 colon 启用 yes style 示例 12345678910// 不会触发警告let abc: String = &quot;jun&quot;let abc = [1: [3: 2], 3: 4]let abc = [1: [3: 2], 3: 4]// 会触发警告let jun:Voidlet jun : Voidlet jun :Voidlet jun: Void Comma Spacing逗号应该紧挨左边，右边空一格 识别码 默认是否启用 是否支持自动更正 类型 默认配置 comma 启用 yes style 示例 12345// 推荐[a, b, c, d]// 不推荐，触发警告[a ,b] Compiler Protocol Init推荐使用自变量初始化变量 识别码 默认是否启用 是否支持自动更正 类型 默认配置 compiler_protocol_init 启用 no lint 示例 123456// 推荐let set: Set&lt;Int&gt; = [1, 2]// 不推荐let set = Set(arrayLiteral: 1, 2)let set = Set.init(arrayLiteral: 1, 2) Conditional Returns on Newline条件语句在下一行返回 识别码 默认是否启用 是否支持自动更正 类型 默认配置 conditional_returns_on_newline 未启用 no style 示例 123456789101112// 推荐if true &#123; return&#125;guard true else &#123; return&#125;// 不推荐, 会触发warningif true &#123; return &#125;guard true else &#123; return &#125; contains_over_first_not_nil类似first函数不能判断是否为nil 识别码 默认是否启用 是否支持自动更正 类型 默认配置 contains_over_first_not_nil 未启用 no performance 示例 1234567// 推荐let first = myList.first(where: &#123; $0 % 2 == 0 &#125;)let first = myList.first &#123; $0 % 2 == 0 &#125;// 不推荐myList.first &#123; $0 % 2 == 0 &#125; != nilmyList.first(where: &#123; $0 % 2 == 0 &#125;) != nil control_statement控制语句, for，while，do，catch语句中的条件不能包含在()中 识别码 默认是否启用 是否支持自动更正 类型 默认配置 control_statement 启用 no style 示例 12345678// 推荐if condition &#123;if (a, b) == (0, 1) &#123;// 不推荐if (condition) &#123;if(condition) &#123;if ((a || b) &amp;&amp; (c || d)) &#123; custom_rules自定义规则。这个属性可以通过提供正则表达式来创建自定义规则，可选指定语法类型搭配，安全、级别和要陈列的什么信息。这个属性推荐熟悉使用正则表达式的人使用。 识别码 默认是否启用 是否支持自动更正 类型 默认配置 custom_rules 启用 no style cyclomatic_complexity循环复杂度。函数体的复杂度应该要限制，这个属性主要约束条件句、循环句中的循环嵌套问题，当嵌套太多的循环时，则会触发swiftlint中的warning和error，当达到10个循环嵌套时就会报warning，达到20个循环嵌套时就会报error 识别码 默认是否启用 是否支持自动更正 类型 默认配置 cyclomatic_complexity 启用 no metrics discarded_notification_center_observer当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知 识别码 默认是否启用 是否支持自动更正 类型 默认配置 discarded_notification_center_observer 启用 no lint 示例 1234567891011121314151617// 推荐let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) &#123; &#125;let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)func foo() -&gt; Any &#123; return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)&#125;// 不推荐nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) &#123; &#125;nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)@discardableResult func foo() -&gt; Any &#123; return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)&#125; discouraged_direct_init阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 discouraged_direct_init 启用 no lint 示例 12345678910// 推荐let foo = UIDevice.currentlet foo = Bundle.mainlet foo = Bundle(path: &quot;bar&quot;)let foo = Bundle(identifier: &quot;bar&quot;)// 不推荐let foo = UIDevice()let foo = Bundle()let foo = bar(bundle: Bundle(), device: UIDevice()) discouraged_optional_boolean不建议使用可选布尔值 识别码 默认是否启用 是否支持自动更正 类型 默认配置 discouraged_optional_boolean 未启用 no idiomatic 示例 1234567891011// 推荐var foo: Boolvar foo: [String: Bool]var foo: [Bool]let foo: Bool = true// 不推荐var foo: Bool?var foo: [String: Bool?]var foo: [Bool?]let foo: Bool? = nil discouraged_object_literal优先使用对象初始化方法, 不建议使用代码块初始化 识别码 默认是否启用 是否支持自动更正 类型 默认配置 discouraged_object_literal 未启用 no idiomatic 示例 123// 不建议let white = #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)let image = ↓#imageLiteral(resourceName: &quot;image.jpg&quot;) dynamic_inline避免一起使用 dynamic 和 @inline(_ _always)， 否则报 error 识别码 默认是否启用 是否支持自动更正 类型 默认配置 dynamic_inline 启用 no lint 示例 12345678910111213141516171819202122232425// 正确的做法class LangKe &#123; dynamic func myFunction() &#123; &#125;&#125;class LangKe &#123; @inline(__always) func myFunction() &#123; &#125;&#125;class LangKe &#123; @inline(never) dynamic func myFunction() &#123; &#125;&#125;// 只要同时使用 dynamic 和 @inline(_ _always)都报错 error！！！class LangKe &#123; @inline(__always) public dynamic func myFunction() &#123; &#125;&#125; empty_count建议使用isEmpty判断,而不是使用count==0判断 识别码 默认是否启用 是否支持自动更正 类型 默认配置 empty_count 未启用 no performance 示例 12345678910111213// 推荐 print(&quot;为空&quot;)&#125; else &#123; print(&quot;不为空&quot;)&#125;// 不推荐let number = &quot;long&quot;if number.characters.count == 0 &#123; print(&quot;为空&quot;)&#125; else &#123; print(&quot;不为空&quot;)&#125; empty_enum_arguments当枚举与关联类型匹配时，如果不使用它们，参数可以省略 识别码 默认是否启用 是否支持自动更正 类型 默认配置 empty_enum_arguments 启用 yes style 示例 123456789101112131415161718192021222324252627// 推荐switch foo &#123; case .bar: break&#125;switch foo &#123; case .bar(let x): break&#125;switch foo &#123; case let .bar(x): break&#125;switch (foo, bar) &#123; case (_, _): break&#125;switch foo &#123; case &quot;bar&quot;.uppercased(): break&#125;// 不推荐switch foo &#123; case .bar(_): break&#125;switch foo &#123; case .bar(): break&#125;switch foo &#123; case .bar(_), .bar2(_): break&#125; empty_parameters闭包参数为空时,建议使用() -&gt;Void, 而不是Void -&gt;Void 识别码 默认是否启用 是否支持自动更正 类型 默认配置 empty_parameters 启用 yes style 示例 12345678910111213// 推荐let abc: () -&gt; Voidfunc foo(completion: () -&gt; Void) &#123;&#125;// 不推荐，报错let bcd: Void -&gt; Voidfunc foo(completion: Void -&gt; Void) &#123;&#125; empty_parentheses_with_trailing_closure在使用尾随闭包的时候， 应该尽量避免使用空的圆括号 识别码 默认是否启用 是否支持自动更正 类型 默认配置 empty_parentheses_with_trailing_closure 启用 yes style explicit_acl所有属性和方法的声明, 都应该明确指定修饰关键字 识别码 默认是否启用 是否支持自动更正 类型 默认配置 explicit_acl 未启用 no idiomatic 示例 123456789101112131415161718192021// 推荐internal enum A &#123;&#125;public final class B &#123;&#125;private struct C &#123;&#125;internal func a() &#123; let a = &#125;private struct C &#123; let d = 5 &#125;internal class A &#123; deinit &#123;&#125; &#125;internal protocol A &#123; func b() var c: Int&#125;// 不推荐enum A &#123;&#125;final class B &#123;&#125;internal struct C &#123; let d = 5 &#125;public struct C &#123; let d = 5 &#125;func a() &#123;&#125;internal let a = 0func b() &#123;&#125; explicit_type_interface声明的属性应该明确其类型, 如: var myVar: Int = 0 识别码 默认是否启用 是否支持自动更正 类型 默认配置 explicit_type_interface 未启用 no idomatic 示例 1234567891011// 推荐class Foo &#123; var myVar: Int? = 0 let myLet: Int? = 0&#125;// 不推荐class Foo &#123; var myVar = 0 let myLet = 0&#125; extension_access_modifier在自定义类中,推荐使用extension扩展 识别码 默认是否启用 是否支持自动更正 类型 默认配置 extension_access_modifier 未启用 no idiomatic no_extension_access_modifier在extension扩展前面,不建议使用(fileprivate, public)等修饰符 识别码 默认是否启用 是否支持自动更正 类型 默认配置 no_extension_access_modifier 未启用 no idiomatic 示例 123456// 不推荐private extension String &#123;&#125;public extension String &#123;&#125;open extension String &#123;&#125;internal extension String &#123;&#125;fileprivate extension String &#123;&#125; fallthroughswitch语句中不建议使用fallthrough 识别码 默认是否启用 是否支持自动更正 类型 默认配置 fallthrough 启用 no idiomatic 示例 12345678910111213// 推荐switch foo &#123;case .bar, .bar2, .bar3: something()&#125;// 不推荐switch foo &#123;case .bar: fallthroughcase .bar2: something()&#125; fatal_error_message执行fatalError错误时,建议有一个提示信息; 如:fatalError(“Foo”) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 fatal_error_message 未启用 no idiomatic 示例 123456789// 推荐required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125;// 不推荐required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;&quot;)&#125; file_header文件头。新建的文件开始的注释应该一样 识别码 默认是否启用 是否支持自动更正 类型 默认配置 file_header 未启用 no style 示例 123456789101112131415161718/// 不会触发warning/// 如果我新建一个工程，在ViewController.swift文件中， 开始的注释应该是：// ViewController.swift// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved.//改变一下变为：//// MyViewController.swift...................由于这里和外面的文件名不一样，所以触发warning（实际上在swift 3.0上测试这个属性暂时没有任何作用！！）// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved................官方terminal表示，Copyright和Created没有对齐，也会触发warning！！！// file_length文件内容行数, 超过400行warning, 超过1000行给error 识别码 默认是否启用 是否支持自动更正 类型 默认配置 file_length 启用 no metrics first_where不建议在使用filter和map函数后直接使用.first 识别码 默认是否启用 是否支持自动更正 类型 默认配置 first_where 未启用 no performance 示例 123456789101112131415161718192021222324public static let description = RuleDescription( identifier: &quot;first_where&quot;, name: &quot;First Where&quot;, description: &quot;Prefer using `.first(where:)` over `.filter &#123; &#125;.first` in collections.&quot;, kind: .performance, // 不会触发警告 nonTriggeringExamples: [ &quot;kinds.filter(excludingKinds.contains).isEmpty &amp;&amp; kinds.first == .identifier\\n&quot;, &quot;myList.first(where: &#123; $0 % 2 == 0 &#125;)\\n&quot;, &quot;match(pattern: pattern).filter &#123; $0.first == .identifier &#125;\\n&quot;, &quot;(myList.filter &#123; $0 == 1 &#125;.suffix(2)).first\\n&quot; ], // 以下写法会触发警告 triggeringExamples: [ &quot;↓myList.filter &#123; $0 % 2 == 0 &#125;.first\\n&quot;, &quot;↓myList.filter(&#123; $0 % 2 == 0 &#125;).first\\n&quot;, &quot;↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first\\n&quot;, &quot;↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first?.something()\\n&quot;, &quot;↓myList.filter(someFunction).first\\n&quot;, &quot;↓myList.filter(&#123; $0 % 2 == 0 &#125;)\\n.first\\n&quot;, &quot;(↓myList.filter &#123; $0 == 1 &#125;).first\\n&quot; ]) for_where在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句 识别码 默认是否启用 是否支持自动更正 类型 默认配置 for_where 启用 no idiomatic 示例 123456789101112131415161718192021222324252627// 推荐for user in users where user.id == 1 &#123; &#125;for user in users &#123; if let id = user.id &#123; &#125;&#125;for user in users &#123; if var id = user.id &#123; &#125;&#125;for user in users &#123; if user.id == 1 &#123; &#125; else &#123; &#125;&#125;for user in users &#123; if user.id == 1 &#123; &#125; print(user)&#125;for user in users &#123; let id = user.id if id == 1 &#123; &#125;&#125;for user in users &#123; if user.id == 1 &amp;&amp; user.age &gt; 18 &#123; &#125;&#125;// 不推荐for user in users &#123; if user.id == 1 &#123; return true &#125;&#125; force_cast不建议直接强解类型 识别码 默认是否启用 是否支持自动更正 类型 默认配置 force_cast 启用 no idiomatic 示例 12345// 推荐NSNumber() as? Int// 不推荐NSNumber() as! Int force_try对会抛出异常(throws)的方法,不建议try!强解 识别码 默认是否启用 是否支持自动更正 类型 默认配置 force_try 启用 no idiomatic 示例 1234567891011func myFunction() throws &#123; &#125;// 推荐do &#123; try myFunction()&#125; catch &#123;&#125;// 不推荐，这样直接触发 errortry! myFunction() force_unwrapping强制解包/拆包。我们知道，当一个类型是可选类型的时候，当我们获取值时，需要强制解包（也叫隐式解包）, 通常我们是在一个变量或者所需要的常量、类型等后面加一个“ ！”， 然而，swiftlint建议强制解包应该要避免， 否则将给予warning 识别码 默认是否启用 是否支持自动更正 类型 默认配置 force_unwrapping 未启用 no idiomatic 示例 12345678910// 推荐，不会触发warningnavigationController?.pushViewController(myViewController, animated: true)/// 不推荐，将触发warningnavigationController!.pushViewController(myViewController, animated: true)let url = NSURL(string: &quot;http://www.baidu.com&quot;)!print(url)return cell! function_body_length函数体长度， 函数体不应该跨越太多行， 超过40行给warning， 超过100行直接报错，可以禁用规避掉 识别码 默认是否启用 是否支持自动更正 类型 默认配置 function_body_length 启用 no metrics function_parameter_count函数参数个数 函数参数数量(init方法除外)应该少点，不要太多，swiftlint规定函数参数数量超过5个给warning， 超过8个直接报error，可以禁用规避掉 识别码 默认是否启用 是否支持自动更正 类型 默认配置 function_parameter_count 启用 no metrics generic_type_name泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间 识别码 默认是否启用 是否支持自动更正 类型 默认配置 generic_type_name 未启用 no idiomatic 示例 1234567891011// 推荐func foo&lt;T&gt;() &#123;&#125;func foo&lt;T&gt;() -&gt; T &#123;&#125;func foo&lt;T, U&gt;(param: U) -&gt; T &#123;&#125;func foo&lt;T: Hashable, U: Rule&gt;(param: U) -&gt; T &#123;&#125;// 不推荐func foo&lt;T_Foo&gt;() &#123;&#125;func foo&lt;T, U_Foo&gt;(param: U_Foo) -&gt; T &#123;&#125;func foo&lt;TTTTTTTTTTTTTTTTTTTTT&gt;() &#123;&#125;func foo&lt;type&gt;() &#123;&#125; identifier_name变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短 识别码 默认是否启用 是否支持自动更正 类型 默认配置 identifier_name 启用 no style 示例 1234567891011121314151617181920212223242526272829303132internal struct IdentifierNameRuleExamples &#123; // 不会触发error static let nonTriggeringExamples = [ &quot;let myLet = 0&quot;, &quot;var myVar = 0&quot;, &quot;private let _myLet = 0&quot;, &quot;class Abc &#123; static let MyLet = 0 &#125;&quot;, &quot;let URL: NSURL? = nil&quot;, &quot;let XMLString: String? = nil&quot;, &quot;override var i = 0&quot;, &quot;enum Foo &#123; case myEnum &#125;&quot;, &quot;func isOperator(name: String) -&gt; Bool&quot;, &quot;func typeForKind(_ kind: SwiftDeclarationKind) -&gt; String&quot;, &quot;func == (lhs: SyntaxToken, rhs: SyntaxToken) -&gt; Bool&quot;, &quot;override func IsOperator(name: String) -&gt; Bool&quot; ] // 会触发error static let triggeringExamples = [ &quot;↓let MyLet = 0&quot;, &quot;↓let _myLet = 0&quot;, &quot;private ↓let myLet_ = 0&quot;, &quot;↓let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0&quot;, &quot;↓var myExtremelyVeryVeryVeryVeryVeryVeryLongVar = 0&quot;, &quot;private ↓let _myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0&quot;, &quot;↓let i = 0&quot;, &quot;↓var id = 0&quot;, &quot;private ↓let _i = 0&quot;, &quot;↓func IsOperator(name: String) -&gt; Bool&quot;, &quot;enum Foo &#123; case ↓MyEnum &#125;&quot; ]&#125; implicit_getter对于只有只读属性不建议重写get方法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 implicit_getter 启用 no style 示例 123456789101112131415161718192021222324252627282930313233343536373839404142//不会触发error//重写get和set方法class Foo &#123; var foo: Int &#123; get &#123; return 3 &#125; set &#123; _abc = newValue &#125; &#125;&#125;//只读class Foo &#123; var foo: Int &#123; return 20 &#125;&#125;class Foo &#123; static var foo: Int &#123; return 20 &#125;&#125;//会触发errorclass Foo &#123; var foo: Int &#123; get &#123; return 20 &#125; &#125;&#125;class Foo &#123; var foo: Int &#123; get&#123; return 20 &#125; &#125;&#125; implicit_return建议使用隐式返回闭包; 如: foo.map({ $0 + 1 }) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 implicit_return 未启用 no style 示例 123456789101112// 推荐foo.map &#123; $0 + 1 &#125;foo.map(&#123; $0 + 1 &#125;)foo.map &#123; value in value + 1 &#125;// 不推荐foo.map &#123; value in return value + 1&#125;foo.map &#123; return $0 + 1&#125; implicitly_unwrapped_optional尽量避免隐式解析可选类型的使用 识别码 默认是否启用 是否支持自动更正 类型 默认配置 implicitly_unwrapped_optional 未启用 no idiomatic 示例 12345678910111213141516171819202122232425262728293031public static let description = RuleDescription( identifier: &quot;implicitly_unwrapped_optional&quot;, name: &quot;Implicitly Unwrapped Optional&quot;, description: &quot;Implicitly unwrapped optionals should be avoided when possible.&quot;, kind: .idiomatic, //不会触发warning nonTriggeringExamples: [ &quot;@IBOutlet private var label: UILabel!&quot;, &quot;@IBOutlet var label: UILabel!&quot;, &quot;@IBOutlet var label: [UILabel!]&quot;, &quot;if !boolean &#123;&#125;&quot;, &quot;let int: Int? = 42&quot;, &quot;let int: Int? = nil&quot; ], //会触发warning triggeringExamples: [ &quot;let label: UILabel!&quot;, &quot;let IBOutlet: UILabel!&quot;, &quot;let labels: [UILabel!]&quot;, &quot;var ints: [Int!] = [42, nil, 42]&quot;, &quot;let label: IBOutlet!&quot;, &quot;let int: Int! = 42&quot;, &quot;let int: Int! = nil&quot;, &quot;var int: Int! = 42&quot;, &quot;let int: ImplicitlyUnwrappedOptional&lt;Int&gt;&quot;, &quot;let collection: AnyCollection&lt;Int!&gt;&quot;, &quot;func foo(int: Int!) &#123;&#125;&quot; ]) is_disjoint初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection 识别码 默认是否启用 是否支持自动更正 类型 默认配置 is_disjoint 启用 no idiomatic 示例 123// 推荐写法_ = Set(syntaxKinds).isDisjoint(with: commentAndStringKindsSet)let isObjc = !objcAttributes.isDisjoint(with: dictionary.enclosedSwiftAttributes) joined_default_parameterjoined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 joined_default_parameter 未启用 yes idiomatic 示例 12345678// 推荐let foo = bar.joined()let foo = bar.joined(separator: &quot;,&quot;)let foo = bar.joined(separator: toto)// 不推荐let foo = bar.joined(separator: &quot;&quot;)let foo = bar.filter(toto).joined(separator: &quot;&quot;) large_tuple定义的元组成员个数,超过两个warning 识别码 默认是否启用 是否支持自动更正 类型 默认配置 large_tuple 启用 no metrics 示例 123456789// 不推荐let foo: (Int, Int)let foo: (start: Int, end: Int)let foo: (Int, (Int, String))// 推荐let foo: (Int, Int, Int)let foo: (start: Int, end: Int, value: String)let foo: (Int, (Int, Int, Int)) leading_whitespace文件开始不应该有空格或者换行, 否则就会触发warning 识别码 默认是否启用 是否支持自动更正 类型 默认配置 leading_whitespace 启用 yes style legacy_cggeometry_functions当获取某个视图的宽、高、最小X、最大X值等等，swiftlint推荐使用swift的标准语法，尽量不要使用从Objective-C中的遗留版本，尽量语法swift化 识别码 默认是否启用 是否支持自动更正 类型 默认配置 legacy_cggeometry_functions 启用 yes idiomatic 示例 123456789// 推荐rect.widthrect.heightrect.minXrect.midXrect...................// 不推荐CGRectGetWidth(someView.frame) legacy_constant和属性 legacy_cggeometry_functions 一样， 结构范围常数尽量分开、明确、具体， 不要使用OC的遗留整体常数 识别码 默认是否启用 是否支持自动更正 类型 默认配置 legacy_constant 启用 yes idiomatic 示例 123456// 推荐CGPoint.zero// 不推荐CGPointZeroCGRectZero legacy_constructorswiftlint要求系统自带构造器， 使用swift语法化，不要使用OC版本的构造器 识别码 默认是否启用 是否支持自动更正 类型 默认配置 legacy_constructor 启用 yes idiomatic 示例 12345// swift语法，相信之后系统也会强制规定使用CGPoint（x: 10， y: 20）// 错误的构造器语法CGPointMake(10, 20) legacy_nsgeometry_functionsns类几何函数， 和前面的几个属性一样， 使用swift点语法函数， 不使用以前的版本。 识别码 默认是否启用 是否支持自动更正 类型 默认配置 legacy_nsgeometry_functions 启用 yes idiomatic 示例 12345/// 正确view.width/height/minX/// 错误NSWidth(view.frame) let_var_whitespacelet和var语句应该用空白行与其他语句分开 识别码 默认是否启用 是否支持自动更正 类型 默认配置 let_var_whitespace 未启用 no style 示例 123456789// 推荐let a = 0var x = 1x = 2// 不推荐var x = 1x = 2 line_length行的字符长度属性。官方的规定是超过120字符就给warning， 超过200个字符就直接报error！ 识别码 默认是否启用 是否支持自动更正 类型 默认配置 line_length 启用 no metrics literal_expression_end_indentation字典和数组的开头和结尾要有相同的缩进格式 识别码 默认是否启用 是否支持自动更正 类型 默认配置 literal_expression_end_indentation 未启用 no style mark标记方法或者属性。 识别码 默认是否启用 是否支持自动更正 类型 默认配置 mark 启用 yes lint 示例 123456789101112// 推荐// MARK: good// MARK: - good// MARK: -// 不推荐//MARK: bad// MARK:bad//MARK:bad// MARK: bad// MARK: bad// MARK: -bad multiline_arguments调用函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 默认配置 multiline_arguments 未启用 no style 示例 12345678// 不推荐foo(0, param1: 1, param2: true, param3: [3])foo( 0, param1: 1, param2: true, param3: [3]) multiline_parameters声明函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 默认配置 multiline_parameters 未启用 no style 示例 12345678910// 不推荐protocol Foo &#123; func foo(param1: Int, param2: Bool, param3: [String]) &#123; &#125;&#125;protocol Foo &#123; func foo(param1: Int, param2: Bool, param3: [String]) &#123; &#125;&#125; multiple_closures_with_trailing_closure当函数有多个闭包时, 不建议使用尾随闭包语法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 multiple_closures_with_trailing_closure 启用 no style 示例 12345678// 不推荐foo.something(param1: &#123; $0 &#125;) &#123; $0 + 1 &#125;UIView.animate(withDuration: 1.0, animations: &#123; someView.alpha = 0.0&#125;) &#123; _ in someView.removeFromSuperview()&#125; nesting嵌套。类型嵌套至多一级结构， 函数语句嵌套至多五级结构。 识别码 默认是否启用 是否支持自动更正 类型 默认配置 nesting 启用 no metrics nimble_operator快捷操作符。和自由匹配函数相比，更喜欢快捷操作符，比如：&gt;=、 ==、 &lt;=、 &lt;等等。 识别码 默认是否启用 是否支持自动更正 类型 默认配置 nimble_operator 未启用 yes idiomatic 示例 123456789// 推荐(person.voice) != &quot;Hello world&quot; // 判断字符串相同10 &gt; 5 // 10比5大99 &lt; 100 // 99比100小// 不推荐(person.voice).toNot(equal(&quot;Hello world&quot;)) // 判断字符串相同10.to(beGreaterThan(5)) // 10比5大99.to(beLessThan(100)) // 99比100小 no_grouping_extension只有class和protocol可以使用extension,其他类型不可使用 识别码 默认是否启用 是否支持自动更正 类型 默认配置 no_grouping_extension 未启用 no idiomatic 示例 123456789101112// 不推荐enum Fruit &#123;&#125;extension Fruit &#123;&#125;extension Tea: Error &#123;&#125;struct Tea &#123;&#125;class Ham &#123; class Spam &#123;&#125;&#125;extension Ham.Spam &#123;&#125;extension External &#123; struct Gotcha &#123;&#125;&#125;extension External.Gotcha &#123;&#125; notification_center_detachment对象移除通知只能在deinit移除self,函数中不能removeObserver(self) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 notification_center_detachment 启用 no lint 示例 1234567891011121314151617181920// 不会触发warningclass Foo &#123; deinit &#123; NotificationCenter.default.removeObserver(self) &#125;&#125;class Foo &#123; func bar() &#123; NotificationCenter.default.removeObserver(otherObject) &#125;&#125;// 会触发warningclass Foo &#123; func bar() &#123; NotificationCenter.default.removeObserver(self) &#125;&#125; number_separator数字分割线。当在大量的小数中， 应该使用下划线来作为千分位分割线 识别码 默认是否启用 是否支持自动更正 类型 默认配置 number_separator 未启用 yes style 示例 1234567// 推荐let xxx = 1_000_000_000.000_1print(xxx)// 不推荐let xxx = 1000000000.0001print(xxx) object_literalswiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法。与 discouraged_object_literal 互斥， 个人不推荐 识别码 默认是否启用 是否支持自动更正 类型 默认配置 object_literal 未启用 no idiomatic 示例 123456789101112131415// 推荐let image = #imageLiteral(resourceName: &quot;image.jpg&quot;)let color = #colorLiteral(red: 0.9607843161, green: 0.7058823705, blue: 0.200000003, alpha: 1)let image = UIImage(named: aVariable)let image = UIImage(named: &quot;interpolated \\(variable)&quot;)let color = UIColor(red: value, green: value, blue: value, alpha: 1)let image = NSImage(named: aVariable)let image = NSImage(named: &quot;interpolated \\(variable)&quot;)let color = NSColor(red: value, green: value, blue: value, alpha: 1)// 不推荐let image = ↓UIImage(named: &quot;foo&quot;)let color = ↓UIColor(red: 0.3, green: 0.3, blue: 0.3, alpha: 1)let color = ↓UIColor(red: 100 / 255.0, green: 50 / 255.0, blue: 0, alpha: 1)let color = ↓UIColor(white: 0.5, alpha: 1) opening_brace花括号之前应该有一个空格,且与声明在同一行 识别码 默认是否启用 是否支持自动更正 类型 默认配置 opening_brace 启用 yes style 示例 12345678// 建议func abc() &#123;&#125;[].map() &#123; $0 &#125;[].map(&#123; &#125;)if let a = b &#123; &#125;while a == b &#123; &#125;guard let a = b else &#123; &#125; operator_usage_whitespace操作符使用规则，操作符两边应该有空格。比如 “+” “-” “？？” 识别码 默认是否启用 是否支持自动更正 类型 默认配置 operator_usage_whitespace 未启用 yes style 示例 1234567891011// 推荐let foo = 1 + 2let foo = 1 &gt; 2let foo = !false// 不推荐let foo = 1+2let foo = 1 + 2let foo = 1 + 2let foo = 1 + 2let foo=1+2 operator_whitespace空格/空白操作符。当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符 识别码 默认是否启用 是否支持自动更正 类型 默认配置 operator_whitespace 启用 no style 示例 12345678// 触发警告class Something: Equatable &#123; var text: String? // &quot;==&quot;和“(lhs: Something, rhs: Something)”之间应该有一个空格 static func ==(lhs: Something, rhs: Something) -&gt; Bool &#123; return lhs.text == rhs.text &#125;&#125; overridden_super_call一些重写的方法应该调用super.(父类的)方法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 overridden_super_call 未启用 no lint override_in_extension在extension中,不能重写未声明的属性和未定义的方法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 override_in_extension 未启用 no lint 示例 12345678910// 错误写法extension Person &#123; //该属性之前未定义, 不能重写 override var age: Int &#123; return 42 &#125;&#125;extension Person &#123; //该方法之前也为定义不能重写 override func celebrateBirthday() &#123;&#125;&#125; pattern_matching_keywords在switch-case语句中, 建议不要将case中的let和var等关键字放到元祖内 识别码 默认是否启用 是否支持自动更正 类型 默认配置 pattern_matching_keywords 未启用 no style prefixed_toplevel_constant类似全局常量,建议前缀以k开头 识别码 默认是否启用 是否支持自动更正 类型 默认配置 prefixed_toplevel_constant 未启用 no style 示例 12345// 推荐private let kFoo = 20.0public let kFoo = falseinternal let kFoo = &quot;Foo&quot;let kFoo = true private_actionIBActions修饰的方法,应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 默认配置 private_action 未启用 no lint private_outletIBOutlets修饰的属性应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 默认配置 private_outlet 未启用 no lint private_over_fileprivateprivate比fileprivate的私有程度更高 识别码 默认是否启用 是否支持自动更正 类型 默认配置 private_over_fileprivate 启用 yes idiomatic private_unit_test私有的单元测试。被标记为private的单元测试不会被测试工具XCTest运行， 也就是说，被标记为private的单元测试会被静态跳过 识别码 默认是否启用 是否支持自动更正 类型 默认配置 private_unit_test 启用 no lint 示例 123456789101112131415161718192021222324252627private ↓class FooTest: XCTestCase &#123; ...............继承于测试用例类XCTestCase, 被标记为private，所以触发warning func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private func test4() &#123;&#125;.......另外注意这里，上面既然不会通过，那显然这里也不会通过，根本不会走这个func &#125; internal class FooTest: XCTestCase &#123; ......开始通过测试，因为没有被标记为private func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;................不通过，因为被标记为private &#125; public class FooTest: XCTestCase &#123; ..........通过 func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;.................不通过，因为被标记成private &#125; class FooTest: XCTestCase &#123; ..........通过 func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;.................不通过，因为被标记成private &#125; prohibited_super_call一些方法不应该调用父类的方法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 prohibited_super_call 未启用 no lint 示例 1234567891011121314151617181920212223242526//以下方法不建议调用父类的方法class VC: UIViewController &#123; override func loadView() &#123;↓ super.loadView() &#125;&#125;class VC: NSFileProviderExtension &#123; override func providePlaceholder(at url: URL,completionHandler: @escaping (Error?) -&gt; Void) &#123;↓ self.method1() super.providePlaceholder(at:url, completionHandler: completionHandler) &#125;&#125;class VC: NSView &#123; override func updateLayer() &#123;↓ self.method1() super.updateLayer() self.method2() &#125;&#125;class VC: NSView &#123; override func updateLayer() &#123;↓ defer &#123; super.updateLayer() &#125; &#125;&#125; protocol_property_accessors_order在协议中声明属性时，访问者的顺序应该是get set 识别码 默认是否启用 是否支持自动更正 类型 默认配置 protocol_property_accessors_order 启用 yes style 示例 123456789// 建议protocol Foo &#123; var bar: String &#123; get set &#125;&#125;// 不建议protocol Foo &#123; var bar: String &#123; set get &#125;&#125; quick_discouraged_call在单元测试中,不建议在describe和content比保重直接调用方法和类 识别码 默认是否启用 是否支持自动更正 类型 默认配置 quick_discouraged_call 未启用 no lint quick_discouraged_focused_test在单元测试中,不建议集中测试,否则可能不能运行成功 识别码 默认是否启用 是否支持自动更正 类型 默认配置 quick_discouraged_focused_test 未启用 no lint quick_discouraged_pending_test单元测试中阻止未进行的测试单元 识别码 默认是否启用 是否支持自动更正 类型 默认配置 quick_discouraged_pending_test 未启用 no lint redundant_discardable_let不需要初始化方法返回结果时,建议使用: _ = Person(), 而不是:let _ = Person() 识别码 默认是否启用 是否支持自动更正 类型 默认配置 redundant_discardable_let 启用 yes style 示例 12345678// 推荐_ = foo()if let _ = foo() &#123; &#125;guard let _ = foo() else &#123; return &#125;// 不建议let _ = foo()if _ = foo() &#123; let _ = bar() &#125; redundant_nil_coalescing使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格 识别码 默认是否启用 是否支持自动更正 类型 默认配置 redundant_nil_coalescing 未启用 yes idiomatic 示例 123456// 建议var myVar: Int?; myVar ?? 0// 不建议var myVar: Int? = nil; myVar ?? nilvar myVar: Int? = nil; myVar??nil redundant_optional_initialization初始化nil变量时,不建议赋值nil 识别码 默认是否启用 是否支持自动更正 类型 默认配置 redundant_optional_initialization 启用 yes idiomatic 示例 1234567891011// 不会触发warningvar myVar: Int?let myVar: Int? = nilvar myVar: Optional&lt;Int&gt;let myVar: Optional&lt;Int&gt; = nil// 会触发warningvar myVar: Int?↓ = nilvar myVar: Optional&lt;Int&gt;↓ = nilvar myVar: Int?↓=nilvar myVar: Optional&lt;Int&gt;↓=nil redundant_string_enum_value在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值 识别码 默认是否启用 是否支持自动更正 类型 默认配置 redundant_string_enum_value 启用 no idiomatic 示例 123456789101112131415161718// 不会触发warningenum Numbers: String &#123; case one case two&#125;enum Numbers: Int &#123; case one = 1 case two = 2&#125;// 会触发warningenum Numbers: String &#123; case one = ↓&quot;one&quot; case two = ↓&quot;two&quot;&#125;enum Numbers: String &#123; case one = ↓&quot;one&quot;, two = ↓&quot;two&quot;&#125; redundant_void_return当函数返回值为Void时,建议不写返回值, 定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 默认配置 redundant_void_return 启用 yes idiomatic 示例 12345678910111213141516// 不会触发warningfunc foo() &#123;&#125;func foo() -&gt; Int &#123;&#125;func foo() -&gt; Int -&gt; Void &#123;&#125;func foo() -&gt; VoidResponselet foo: Int -&gt; Void// 会触发warningfunc foo()↓ -&gt; Void &#123;&#125;protocol Foo &#123; func foo()↓ -&gt; Void&#125;func foo()↓ -&gt; () &#123;&#125;protocol Foo &#123; func foo()↓ -&gt; ()&#125; required_enum_case定义的枚举,必须有与其对应的操作实现 识别码 默认是否启用 是否支持自动更正 类型 默认配置 required_enum_case 未启用 no lint return_arrow_whitespaceswiftlint推荐返回箭头和返回类型应该被空格分开 识别码 默认是否启用 是否支持自动更正 类型 默认配置 return_arrow_whitespace 启用 yes style 示例 12345678910// 推荐写法func abc() -&gt; Int &#123;&#125;func abc() -&gt; [Int] &#123;&#125;// 不建议写法func abc()↓-&gt;Int &#123;&#125;func abc()↓-&gt;[Int] &#123;&#125;func abc()↓-&gt;(Int, Int) &#123;&#125;func abc()↓-&gt; Int &#123;&#125;func abc()↓ -&gt;Int &#123;&#125; shorthand_operator在swiftlint中， 就是我们常用的简洁操作运算符，比如：+= ， -=， *=， /= 等等。在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符 识别码 默认是否启用 是否支持自动更正 类型 默认配置 shorthand_operator 启用 no style 示例 123456789/// 不推荐使用var value = 4value = value / 2print(value)/// 推荐使用var value = 4value /= 2print(value) single_test_class单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类 识别码 默认是否启用 是否支持自动更正 类型 默认配置 single_test_class 未启用 no style sorted_first_last在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().lase 识别码 默认是否启用 是否支持自动更正 类型 默认配置 sorted_first_last 未启用 no style sorted_imports分类/有序导入。 这个属性有些奇怪， 要求导入的时候导入的类要按顺序导入 识别码 默认是否启用 是否支持自动更正 类型 默认配置 sorted_imports 未启用 yes style 示例 123456789//建议写法import AAAimport BBBimport CCCimport DDDimport Alamofireimport API statement_position陈述句位置， 这里主要指的是 else 和 catch 前面要加一个空格， 也不能大于1个空格， 否则就会触发警告 识别码 默认是否启用 是否支持自动更正 类型 默认配置 statement_position 启用 yes style 示例 1234567891011121314151617181920212223242526/// 没有空格，触发warninglet number = &quot;long&quot;if number.isEmpty &#123; print(&quot;为空&quot;)&#125;else &#123;.............................注意这里 print(&quot;不为空&quot;)&#125;/// 这里也会触发warning， 因为else if换行了let number = &quot;long&quot;if number.isEmpty &#123; print(&quot;为空&quot;)&#125;else if number.contains(&quot;long&quot;) &#123;............................注意这里 print(&quot;不为空&quot;)&#125; else &#123; print(&quot;s&quot;)&#125;/// 正确的写法let number = &quot;long&quot;if number.isEmpty &#123; print(&quot;为空&quot;)&#125; else &#123; print(&quot;不为空&quot;)&#125; strict_fileprivateextension中不建议使用fileprivate 修饰方法和属性 识别码 默认是否启用 是否支持自动更正 类型 默认配置 strict_fileprivate 未启用 no idiomatic superfluous_disable_command被禁用的规则不会在禁用区域触发警告 识别码 默认是否启用 是否支持自动更正 类型 默认配置 superfluous_disable_command 启用 no lint switch_case_alignmentswitch-case语句中switch和case应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 默认配置 switch_case_alignment 启用 no style 示例 1234567891011121314151617// 推荐switch someBool &#123;case true: // case 1 print(&apos;red&apos;)case false: if case let .someEnum(val) = someFunc() &#123; print(&apos;blue&apos;) &#125;&#125;// 不推荐switch someBool &#123; ↓case true: print(&apos;red&apos;) ↓case false: print(&apos;blue&apos;)&#125; switch_case_on_newline在switch语法里， case应该总是在一个新行上面 识别码 默认是否启用 是否支持自动更正 类型 默认配置 switch_case_on_newline 启用 no idiomatic 示例 12345678910111213141516// swiftlint表示会触发warningswitch type &#123;case .value1: print(&quot;1&quot;)...................在同一行错case .value2: print(&quot;2&quot;)...................在同一行错default: print(&quot;3&quot;)...................在同一行错&#125;/// 不会触发warningswitch type &#123;case .value1: print(&quot;1&quot;)case .value2: print(&quot;2&quot;)default: print(&quot;3&quot;)&#125; syntactic_sugarswiftlint推荐使用速记语法糖， 例如 [Int] 代替 Array, 强烈建议推荐使用 识别码 默认是否启用 是否支持自动更正 类型 默认配置 syntactic_sugar 启用 no idiomatic 示例 1234567/// 触发warninglet myArray: Array&lt;Int&gt; = [1, 2, 3]print(myArray)/// 正确写法，不会触发warninglet myArray: [Int] = [1, 2, 3] print(myArray) todoTODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求 识别码 默认是否启用 是否支持自动更正 类型 默认配置 todo 启用 no lint trailing_closure关于闭包中{}的使用, 推荐使用尾随闭包的语法 识别码 默认是否启用 是否支持自动更正 类型 默认配置 trailing_closure 未启用 no style 示例 1234567//推荐使用foo.map &#123; $0 + 1 &#125;foo.reduce(0) &#123; $0 + 1 &#125;//不推荐使用foo.map(&#123; $0 + 1 &#125;)↓foo.reduce(0, combine: &#123; $0 + 1 &#125;) trailing_comma 识别码 默认是否启用 是否支持自动更正 类型 默认配置 trailing_comma 启用 yes style trailing_newline文件（属性、方法）结束的的时候（“}”之前）， 应该有一个空格新行，但这里要注意的是 识别码 默认是否启用 是否支持自动更正 类型 默认配置 trailing_newline 启用 yes style 示例 1234567891011121314151617/// 空一行，不会触发警告nonTriggeringExamples: [ &quot;let a = 0\\n&quot;],/// 下面会触发警告triggeringExamples: [ &quot;let a = 0&quot;, /// 不空行，会触发警告（实际上，我试过，不会触发警告） &quot;let a = 0\\n\\n&quot; /// 空两行， 会触发警告（实际上，我试过，会触发警告，但是触发的是vertical_whitespace警告而不是trailing_newline）],/// 说说这里，它要求改正为都空一行，虽然这样code看起来很轻松，但如果定义变量或常量太多，就太分散了（值得说的是，就算不空行也不会触发trailing_newline, 应该刚才也已经说了，这个属性只是说“应该”，而不是必须）corrections: [ &quot;let a = 0&quot;: &quot;let a = 0\\n&quot;, &quot;let b = 0\\n\\n&quot;: &quot;let b = 0\\n&quot;, &quot;let c = 0\\n\\n\\n\\n&quot;: &quot;let c = 0\\n&quot;] trailing_semicolon尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;” 识别码 默认是否启用 是否支持自动更正 类型 默认配置 trailing_semicolon 启用 yes idiomatic trailing_whitespace函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突 识别码 默认是否启用 是否支持自动更正 类型 默认配置 trailing_whitespace 启用 yes style 示例 12345678910111213/// 下面这个例子不会触发警告，但是一旦其中有一个空行就会触发警告trailing_whitespace, 这和vertical_whitespace实质上有些冲突，vertical_whitespace要求两行code之间不超过1行，要么没有空行，要么只有1行，而trailing_whitespace要求没有空行！！！class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let a = 0 let b = 1 let c = 2 &#125; func chenlong() -&gt; Void &#123; let a = 0 print(a) &#125;&#125; type_body_length类型体长度。类型体长度不应该跨越太多行， 超过200行给warning，超过350行给error。一般是大括号或者括号内, 比如定义一个enum或struct 识别码 默认是否启用 是否支持自动更正 类型 默认配置 type_body_length 启用 no metrics type_name类型名， 类型名应该只包含字母数字字符， 并且以大写字母开头，长度在3-40个字符 识别码 默认是否启用 是否支持自动更正 类型 默认配置 type_name 启用 no idiomatic unneeded_break_in_switch在switch-case语句中, 有方法调用或操作时,避免使用break语句 识别码 默认是否启用 是否支持自动更正 类型 默认配置 unneeded_break_in_switch 启用 no idiomatic 示例 123456789101112131415161718192021//不会触发warningswitch foo &#123;case .bar: break&#125;switch foo &#123;default: break&#125;switch foo &#123;case .bar: something()&#125;//会触发warningswitch foo &#123;case .bar://这里已经有方法调用了 something() ↓break&#125; unneeded_parentheses_in_closure_argument在定义或使用闭包时,闭包参数不建议使用括号() 识别码 默认是否启用 是否支持自动更正 类型 默认配置 unneeded_parentheses_in_closure_argument 未启用 yes style 示例 12345678//建议let foo = &#123; (bar: Int) in &#125;let foo = &#123; bar, _ in &#125;let foo = &#123; bar in &#125;//不建议call(arg: &#123; ↓(bar) in &#125;)call(arg: &#123; ↓(bar, _) in &#125;) unused_closure_parameterswiftlint建议最好把不使用的闭包参数使用 “_”代替 识别码 默认是否启用 是否支持自动更正 类型 默认配置 unused_closure_parameter 启用 yes lint 示例 123456789101112131415//不会触发warning[1, 2].map &#123; number in number + 1&#125;[1, 2].map &#123; _ in 3&#125;//会触发warning[1, 2].map &#123; ↓number in return 3&#125;[1, 2].map &#123; ↓number in return numberWithSuffix&#125; unused_enumerated在for遍历数组时, 如有未使用的索引,不建议使用.enumerated() 识别码 默认是否启用 是否支持自动更正 类型 默认配置 unused_enumerated 启用 no idiomatic 示例 12345678910//不会触发warningfor (idx, foo) in bar.enumerated() &#123; &#125;for (_, foo) in bar.enumerated().something() &#123; &#125;for (_, foo) in bar.something() &#123; &#125;//会触发warningfor (↓_, foo) in bar.enumerated() &#123; &#125;for (↓_, foo) in abc.bar.enumerated() &#123; &#125;for (↓_, foo) in abc.something().enumerated() &#123; &#125;for (idx, ↓_) in bar.enumerated() &#123; &#125; unused_optional_binding在使用if判断某变量是否为nil的时候, 不建议使用下划线(_) 识别码 默认是否启用 是否支持自动更正 类型 默认配置 unused_optional_binding 启用 no style 示例 123456789//不会触发warningif let bar = Foo.optionalValue &#123;&#125;//会触发warningif let ↓_ = Foo.optionalValue &#123;&#125;if let a = Foo.optionalValue, let ↓_ = Foo.optionalValue2 &#123;&#125; valid_ibinspectable@IBInspectable在swiftlint中的使用需要注意， 第一必须是变量， 第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型：String, NSString, UIColor, NSColor, UIImage, NSImage. 识别码 默认是否启用 是否支持自动更正 类型 默认配置 valid_ibinspectable 启用 no lint 示例 12345678910111213/// 指定为变量var， 类型为String？和String！@IBInspectable private var yyy: String?@IBInspectable private var zzz: String!/// 如果写成这样，编译能通过，但是会触发警告, 因为swiftlint暂不支持Int可选和隐式类型:@IBInspectable private var dddl: Int!@IBInspectable private var eeel: Int?/// 如果指定的类型不是可选类型， 就应该初始化，否则系统不允许，会报错所在的类没有初始化对：@IBInspectable private var counts: Int = 0系统报错：@IBInspectable private var counts: Int vertical_parameter_alignment垂直方向上的参数对齐。当函数参数有多行的时候， 函数参数在垂直方向上应该对齐（参数换行的时候左边对齐） 识别码 默认是否启用 是否支持自动更正 类型 默认配置 vertical_parameter_alignment 启用 no style 示例 12345678910//不会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) &#123; &#125;func validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) -&gt; [StyleViolation]//会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, ↓dictionary: [String: SourceKitRepresentable]) &#123; &#125; vertical_parameter_alignment_on_call当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 默认配置 vertical_parameter_alignment_on_call 未启用 no style 示例 12345678910111213141516171819//不会触发warningfoo(param1: 1, param2: bar param3: false, param4: true)foo(param1: 1, param2: bar)foo(param1: 1, param2: bar param3: false, param4: true)//会触发warningfoo(param1: 1, param2: bar ↓param3: false, param4: true)foo(param1: 1, param2: bar ↓param3: false, param4: true)foo(param1: 1, param2: bar ↓param3: false, ↓param4: true) vertical_whitespace垂直方向上的空格行，限制为一行（注释除外） 识别码 默认是否启用 是否支持自动更正 类型 默认配置 vertical_whitespace 启用 yes style 示例 1234567891011121314151617181920/// 没有空格， nonTriggerWarningoverride func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0&#125;/// 有一行空格, nonTriggerWarningoverride func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0 ............................1&#125;/// &gt;=2行，就会触发警告override func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0 .............................1 .............................2&#125; void_return多余的返回值为空， 在函数声明的时候，返回值为空是多余的。定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 默认配置 void_return 启用 yes style 示例 123456789/// 这个属性要求这样写， 返回值为空省略func XingYun() &#123; print(&quot;titan&quot;)&#125;/// 这个属性要求别这样写，否则会有warning（但是我在swift 3.0上测试并没有触发warning）func XingYun() -&gt; Void &#123; print(&quot;titan&quot;)&#125; weak_delegate代理应该写成weak类型（弱代理）来避免循环引用 识别码 默认是否启用 是否支持自动更正 类型 默认配置 weak_delegate 启用 no lint 示例 123456789101112131415161718192021222324252627282930/// 1.1 编译通过class Langke &#123; var chenlong: NSObjectProtocol?&#125;/// 1.2 编译通过，但是触发swiftlint的 weak_delegate警告， 原因是变量名 myDelegate 中有 delegate 关键字，这属于名字滥用class Langke &#123; var myDelegate: NSObjectProtocol?&#125;/// 1.3 编译通过， 不会触发警告， 原因是在 var 关键字前面加了 weakclass Langke &#123; weak var myDelegate: NSObjectProtocol?&#125;/// 2.1 编译通过，但是触发 weak_delegate 警告，原因是 scrollDelegate 中 Delegate 放在了最后， 被理解成了代理class Langke &#123; var scrollDelegate: UIScrollViewDelegate?&#125;/// 2.2 编译通过， 既然变量名被理解成了代理， 那为了类似防止循环引用， 应该加关键字 weakclass Langke &#123; weak var scrollDelegate: UIScrollViewDelegate?&#125;/// 编译通过， 不会触发警告， 因为delegate放在了前面， 没有被理解成代理class Langke &#123; var delegateScroll: UIScrollViewDelegate?&#125; xctfail_message单元测试中,XCTFail调用应该包括声明描述 识别码 默认是否启用 是否支持自动更正 类型 默认配置 xctfail_message 启用 no idiomatic yoda_condition 识别码 默认是否启用 是否支持自动更正 类型 默认配置 yoda_condition 未启用 no lint 示例 123456789101112//不会触发warningif foo == 42 &#123;&#125;if foo &lt;= 42.42 &#123;&#125;guard foo &gt;= 42 else &#123; return &#125;guard foo != &quot;str str&quot; else &#123; return &#125;//会触发warning↓if 42 == foo &#123;&#125;↓if 42.42 &gt;= foo &#123;&#125;↓guard 42 &lt;= foo else &#123; return &#125;↓guard &quot;str str&quot; != foo else &#123; return &#125;↓while 10 &gt; foo &#123; &#125;","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"SwiftLint 使用","slug":"SwiftLint使用","date":"2019-08-11T07:32:33.000Z","updated":"2020-05-16T05:40:03.190Z","comments":true,"path":"default/SwiftLint使用/","link":"","permalink":"https://kysonyangs.github.io/default/SwiftLint使用/","excerpt":"SwiftLint官方文档 SwiftLint 介绍 SwiftLint 安装 SwiftLint 规则 自定义配置 SwiftLint 介绍 SwiftLint 是 Realm 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 Github 公布的 Swift 代码规范 进行代码检查，并且能够很好的和 Xcode 整合 配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过 警告 或者 红色错误 的形式指示出来 支持自定义规则,可禁用或者开启某一些规则","text":"SwiftLint官方文档 SwiftLint 介绍 SwiftLint 安装 SwiftLint 规则 自定义配置 SwiftLint 介绍 SwiftLint 是 Realm 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 Github 公布的 Swift 代码规范 进行代码检查，并且能够很好的和 Xcode 整合 配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过 警告 或者 红色错误 的形式指示出来 支持自定义规则,可禁用或者开启某一些规则 SwiftLint 安装 安装 使用Homebrew brew install swiftlint CocoaPods 安装 pod &#39;SwiftLint&#39; 注意在 .gitignore 添加 对应目录 避免不必要的麻烦 配置 Build Phases -&gt; New Run Script Phase (-&gt; 重命名为 SwiftLint) 添加脚本 Homebrew 安装 12345if which swiftlint &gt;/dev/null; thenswiftlintelseecho &quot;warning: SwiftLint not installed, download from https://github.com/realm/ SwiftLint&quot;fi CocoaPods安装 &quot;${PODS_ROOT}/SwiftLint/swiftlint&quot; Command+B 编译项目，可以查看你不规范的地方了 SwiftLint 规则 Rules.md 在代码中关闭某个规则1234可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：// swiftlint:disable &lt;rule&gt;在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：// swiftlint:enable &lt;rule&gt; 1234567也可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。// swiftlint:disable:next force_castlet noWarning = NSNumber() as! Intlet hasWarning = NSNumber() as! Intlet noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_castlet noWarning3 = NSNumber() as! Int// swiftlint:disable:previous force_cast 自定义配置当编译后发现 999+警告 999+ 错误，是不是很崩溃，如果觉得规范太严格，我们可以自定义一些配置来符合自己的风格，再做一些配置忽略 CocoaPods、Carthage、自己导入的包 等包管理器引入的第三方库 创建配置文件 根目录下 touch .swiftlint.yml 新建一个 .swiftlint.yml 的配置文件 几个配置选项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849disabled_rules: # 禁用指定的规则 - colon - comma - control_statementopt_in_rules: # 启用指定的规则 - empty_count - missing_docs # 可以通过执行如下指令来查找所有可用的规则: # swiftlint rulesincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。 - Sourceexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift# 可配置的规则可以通过这个配置文件来自定义# 二进制规则可以设置他们的严格程度force_cast: warning # 隐式force_try: severity: warning # 显式# 同时有警告和错误等级的规则，可以只设置它的警告等级# 隐式line_length: 110# 可以通过一个数组同时进行隐式设置type_body_length: - 300 # warning - 400 # error# 或者也可以同时进行显式设置file_length: warning: 500 error: 1200# 命名规则可以设置最小长度和最大程度的警告/错误# 此外它们也可以设置排除在外的名字type_name: min_length: 4 # 只是警告 max_length: # 警告和错误 warning: 40 error: 50 excluded: iPhone # 排除某个名字identifier_name: min_length: # 只有最小长度 error: 4 # 只有错误 excluded: # 排除某些名字 - id - URL - GlobalAPIKeyreporter: &quot;xcode&quot; # 报告类型 (xcode, json, csv, checkstyle, junit, html, emoji) 我的配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677disabled_rules: # rule identifiers to exclude from running - missing_docs - unused_closure_parameter - cyclomatic_complexityopt_in_rules: # some rules are only opt-in - empty_count# Find all the available rules by running:# swiftlint rulesincluded: # paths to include during linting. `--path` is ignored if present. - xxx - xxx - xxxexcluded: # paths to ignore during linting. Takes precedence over `included`. - Pods - xxx - xxx# configurable rules can be customized from this configuration file# binary rules can set their severity levelforce_cast: warning # implicitlyforce_try: severity: warning # explicitly# rules that have both warning and error levels, can set just the warning level# implicitlyline_length: 300function_body_length: - 300 # warning - 400 # errorfunction_parameter_count: - 10 # warning - 15 # errorlarge_tuple: - 6 # warning - 12 # error# they can set both implicitly with an arraytype_body_length: - 300 # warning - 400 # error# or they can set both explicitlyfile_length: warning: 1000 error: 2000cyclomatic_complexity: - 15 # warning - 30 # error# naming rules can set warnings/errors for min_length and max_length# additionally they can set excluded namestype_name: min_length: 3 # only warning max_length: # warning and error warning: 40 error: 50 excluded: # excluded via string - T - Eidentifier_name: min_length: # only min_length error: 3 # only error excluded: # excluded via string array - vc - id - in - kf - x - y","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"YYCache源码阅读","slug":"YYCache源码阅读","date":"2018-12-16T12:18:20.000Z","updated":"2020-05-17T08:12:25.627Z","comments":true,"path":"default/YYCache源码阅读/","link":"","permalink":"https://kysonyangs.github.io/default/YYCache源码阅读/","excerpt":"一直想写一写自己读源码的感受与理解，可惜一直未付诸行动。最近闲来无事，索性整理一下，记录于此. YYCacheYYCahce 包括 内存缓存(YYMemoryCache) 与 磁盘缓存(YYDiskCache), 而且都是线程安全的！ YYMemoryCache 内存缓存一般这个缓存需要进行高效查询数据，所以使用字典这种 key-value 模式。那为什么不直接使用字典呢，因为需要保证线程安全。而为什么不直接使用 NSCache 呢，因为 YYMemoryCache 提供一种 LRU(least-recently-used: 最近最久少使用的会先删除) 算法去操作缓存。","text":"一直想写一写自己读源码的感受与理解，可惜一直未付诸行动。最近闲来无事，索性整理一下，记录于此. YYCacheYYCahce 包括 内存缓存(YYMemoryCache) 与 磁盘缓存(YYDiskCache), 而且都是线程安全的！ YYMemoryCache 内存缓存一般这个缓存需要进行高效查询数据，所以使用字典这种 key-value 模式。那为什么不直接使用字典呢，因为需要保证线程安全。而为什么不直接使用 NSCache 呢，因为 YYMemoryCache 提供一种 LRU(least-recently-used: 最近最久少使用的会先删除) 算法去操作缓存。 _YYLinkedMap为了实现算法，YYMemoryCache 内部封装了一个 _YYLinkedMap 的双向链表12345678910@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 哈希字典，存放 (key : _YYLinkedMapNode) NSUInteger _totalCost; // 缓存总大小 NSUInteger _totalCount; // 缓存节点个数 _YYLinkedMapNode *_head; // 头结点 _YYLinkedMapNode *_tail; // 尾节点 BOOL _releaseOnMainThread; // 在主线程释放 BOOL _releaseAsynchronously; // 在异步线程释放&#125; _YYLinkedMapNode 链表节点数据123456789@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // 指向前一个节点的指针 __unsafe_unretained _YYLinkedMapNode *_next; // 指向后一个节点的指针 id _key; // 缓存数据的key id _value; // 缓存的数据 NSUInteger _cost; // 节点占用大小 NSTimeInterval _time; // 节点操作时间&#125; CFMutableDictionaryRef 操作: CoreFoundation 的字典，其性能更好 12345678/// 初始化_dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);/// 存储数据CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node));/// 根据key删除数据CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key));/// 获取字典元素个数CFDictionaryGetCount(_dic); 2._YYLinkedMap 方法列表： 12345678910/// 插入头节点- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;/// 将节点设为头结点- (void)bringNodeToHead:(_YYLinkedMapNode *)node;/// 删除节点- (void)removeNode:(_YYLinkedMapNode *)node;/// 删除尾节点- (_YYLinkedMapNode *)removeTailNode;/// 删除所有数据- (void)removeAll; pthread_mutex_t 互斥锁，保证线程安全操作方法:1234pthread_mutex_init(&amp;_lock, NULL); // 初始化pthread_mutex_lock(&amp;_lock); // 加锁pthread_mutex_unlock(&amp;_lock); // 解锁pthread_mutex_trylock(&amp;_lock) == 0 // 是否加锁，0:未锁住，其他值：锁住 边界检测YYMemoryCache 有一个边界检测机制，从 YYMemoryCache 初始化就开始工作(类似于定时器，隔一段时间就执行一次操作，但不是使用定时器)，使用递归调用1234567891011121314151617- (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; [self _trimInBackground]; // 边界检测 [self _trimRecursively]; // 递归调用自己，实现定时器的效果 &#125;);&#125;- (void)_trimInBackground &#123; dispatch_async(_queue, ^&#123; [self _trimToCost:self-&gt;_costLimit]; // 缓存大小是否超过预定值，超过则从尾节点开始删除 [self _trimToCount:self-&gt;_countLimit];// 缓存个数是否超过预定值，超过则从尾节点开始删除 [self _trimToAge:self-&gt;_ageLimit]; // 遍历节点，删除和now相差 _ageLimit 的节点 &#125;);&#125; _trimToCost _trimToCount123456789101112131415161718192021222324252627282930313233343536- (void)_trimToCost:(NSUInteger)costLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); if (costLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCost &lt;= costLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCost &gt; costLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // 在这里 释放 node，防止分散控制 &#125;); &#125;&#125;- (void)_trimToCount:(NSUInteger)countLimit &#123; ...&#125; _trimToAge12345678910111213141516171819- (void)_trimToAge:(NSTimeInterval)ageLimit &#123; ... NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; ...&#125; 监听内存警告通知/进入后台通知自动清空内存缓存 增删查改所有操作都需要进行线程安全控制：加锁 增/改 12345678910111213141516171819202122232425262728293031323334- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; ... pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; // 数据存在: 更新，并移动到头结点 _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; [_lru bringNodeToHead:node]; &#125; else &#123; // 数据不存在：直接添加到头结点 node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; [_lru insertNodeAtHead:node]; &#125; // 计算缓存大小是否大于预定值，大于则进行删缓存操作 if (_lru-&gt;_totalCost &gt; _costLimit) &#123; dispatch_async(_queue, ^&#123; [self trimToCost:_costLimit]; &#125;); &#125; // 缓存个数大于预定值，直接删除尾节点 if (_lru-&gt;_totalCount &gt; _countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; ... &#125; pthread_mutex_unlock(&amp;_lock);&#125; 删 12345678910111213/// 根据key进行删除- (void)removeObjectForKey:(id)key &#123; ... pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; ... &#125; pthread_mutex_unlock(&amp;_lock);&#125;/// 删除所有- (void)removeAllObjects; 查 1234/// 是否包含某个数据- (BOOL)containsObjectForKey:(id)key;/// 获取缓存数据: 1.更新节点的时间戳，2.并将节点移到头结点- (id)objectForKey:(id)key; 总结 YYMemoryCache 操作了内存缓存, 相较于磁盘缓存需要进行I/O操作, 在性能上快很多, 因此YYCache访问缓存时, 优先用的是YYMemoryCache。 YYMemoryCache 就是操作双向链表和哈希字典，使用 LRU 算法操作数据 YYDiskCache 磁盘缓存YYDiskCache 磁盘缓存又分为 文件缓存 和 数据库缓存12345/// 根据这个属性进行区分，当大于该值时使用数据库缓存，小于该值使用文件缓存/// 默认 20480(20kb)/// 0 文件缓存/// NSUIntegerMax 数据库缓存@property (readonly) NSUInteger inlineThreshold; NSMapTableYYDiskCache 维护一个 NSMapTable(Path : YYDiskCache) 来进行缓存操作 NSMapTable: 类似于 NSDictionary 但是可以指定key-value的引用类型，当value的引用类型为 weak 时，当 value 为 nil 时，自动删除key-value123456/// 初始化_globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];/// set[_globalInstances setObject:cache forKey:cache.path];/// getid cache = [_globalInstances objectForKey:path]; 信号量 dispatch_semaphoreYYDiskCache 使用信号量进行加锁解锁操作。dispatch_semaphore_t GCD 中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量 +1；每当发送一个等待信号时信号量 -1,；如果信号量为 0 则信号会处于等待状态，直到信号量大于 0(或者超时) 开始执行之后代码。 边界检查YYDiskCache 在初始化时也会进行一个递归调用的边界检查任务1234567891011121314151617181920212223- (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; [self _trimInBackground]; // 边界检查 [self _trimRecursively]; // 递归调用 &#125;);&#125;- (void)_trimInBackground &#123; __weak typeof(self) _self = self; dispatch_async(_queue, ^&#123; __strong typeof(_self) self = _self; if (!self) return; Lock(); [self _trimToCost:self.costLimit]; // 缓存大小判断清理 [self _trimToCount:self.countLimit]; // 缓存个数判断清理 [self _trimToAge:self.ageLimit]; // 缓存的时间判断清理 [self _trimToFreeDiskSpace:self.freeDiskSpaceLimit]; // 最小空白磁盘判断, 当空闲磁盘空间小于该值则清楚缓存已达到最小的空白磁盘空间 Unlock(); &#125;);&#125; 调用 YYKVStorage 的相应方法 YYKVStorage: YYDiskCache 控制缓存的操作类，下面会介绍, 把它当成 YYMemoryCache 的 _YYLinkedMap YYDiskCache 默认将数据归档成 Data 然后操作 Data 数据进行缓存YYKVStorage: YYDiskCache 操作数据的工具类。 YYKVStorage 实现了 文件缓存 和 数据库缓存 功能。可以向操作字典一样使用 key-value 操作数据。YYKVStorageType 枚举类型，代表使用哪个方式进行存储12345678typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; // 使用文件缓存 当 YYDiskCache 的 inlineThreshold 为 O 时 YYKVStorageTypeFile = 0, // 使用数据库缓存 当 YYDiskCache 的 inlineThreshold 为 NSUIntegerMax 时 YYKVStorageTypeSQLite = 1, // 同时使用数据库和文件缓存，当大于 YYDiskCache 的 inlineThreshold 时使用数据库缓存，小于使用文件缓存 YYKVStorageTypeMixed = 2,&#125;; YYKVStorageItem: YYKVStorage 操作的数据123456789@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; // 缓存数据的key@property (nonatomic, strong) NSData *value; // 缓存数据@property (nullable, nonatomic, strong) NSString *filename; // 缓存文件名（文件缓存时有，数据库缓存没有，有可能是数据库缓存但是仍然存在，应为没大于边界值时使用的文件缓存）@property (nonatomic) int size; // 数据大小@property (nonatomic) int modTime; // 修改时间@property (nonatomic) int accessTime; // 访问时间@property (nullable, nonatomic, strong) NSData *extendedData; // 附加数据@end 初始化123456789101112131415161718192021222324252627- (instancetype)initWithPath:(NSString *)path type:(YYKVStorageType)type &#123; ... self = [super init]; _path = path.copy; _type = type; _dataPath = [path stringByAppendingPathComponent:kDataDirectoryName]; // 文件存储文件夹路径 _trashPath = [path stringByAppendingPathComponent:kTrashDirectoryName]; // 删除文件的文件夹路径，删除的时候先添加到该文件夹，到时候统一删除，回收站 _trashQueue = dispatch_queue_create(&quot;com.ibireme.cache.disk.trash&quot;, DISPATCH_QUEUE_SERIAL); // 删除文件队列 _dbPath = [path stringByAppendingPathComponent:kDBFileName]; // 数据库路径 _errorLogsEnabled = YES; ... 文件夹创建 // _dbOpen 方法创建和打开数据库 manifest.sqlite // 调用 _dbInitialize 方法创建数据库中的表 if (![self _dbOpen] || ![self _dbInitialize]) &#123; // db file may broken... [self _dbClose]; [self _reset]; // rebuild if (![self _dbOpen] || ![self _dbInitialize]) &#123; [self _dbClose]; NSLog(@&quot;YYKVStorage init error: fail to open sqlite db.&quot;); return nil; &#125; &#125; [self _fileEmptyTrashInBackground]; // 清空回收站 return self;&#125; 12345678910111213141516171819202122232425/* File: /path/ /manifest.sqlite /manifest.sqlite-shm /manifest.sqlite-wal /data/ /e10adc3949ba59abbe56e057f20f883e /e10adc3949ba59abbe56e057f20f883e /trash/ /unused_file_or_folder SQL: create table if not exists manifest ( key text, filename text, size integer, inline_data blob, modification_time integer, last_access_time integer, extended_data blob, primary key(key) ); create index if not exists last_access_time_idx on manifest(last_access_time); */ 增删查改 增 1234567891011121314151617181920212223- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123; ... // 文件名存在 (&gt;inlineThreshold) if (filename.length) &#123; if (![self _fileWriteWithName:filename data:value]) &#123; // 创建文件失败 return NO; &#125; if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123; // 存储数据失败 [self _fileDeleteWithName:filename]; // 删除文件 return NO; &#125; return YES; &#125; else &#123; if (_type != YYKVStorageTypeSQLite) &#123; NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; &#125; return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData]; &#125;&#125; 删 12345678910111213141516171819202122232425- (BOOL)removeItemForKey:(NSString *)key &#123; ... switch (_type) &#123; case YYKVStorageTypeSQLite: &#123; return [self _dbDeleteItemWithKey:key]; &#125; break; case YYKVStorageTypeFile: case YYKVStorageTypeMixed: &#123; NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; return [self _dbDeleteItemWithKey:key]; &#125; break; default: return NO; &#125;&#125;- (BOOL)removeItemForKeys:(NSArray *)keys;// 删除时间超了的数据- (BOOL)removeItemsEarlierThanTime:(int)time;// 当数据总大小大于临界值时删除- (BOOL)removeItemsToFitSize:(int)maxSize;// 当数据个数大于临界值时执行删除操作- (BOOL)removeItemsToFitCount:(int)maxCount;- (BOOL)removeAllItems; DB操作_db... 直接操作sqlite数据库，又想了解的自己去看，挺全面的 总结 YYDiskCache 使用 YYKVStorage 进行文件缓存 和 数据库缓存，提供了一整套接口，让我们使用时就像使用字典一样方便","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://kysonyangs.github.io/tags/源码/"}]},{"title":"使用 Xcode 工具（Network Link Conditioner）模拟网络状态","slug":"iOS网络调试","date":"2018-10-13T12:24:15.000Z","updated":"2020-05-17T08:14:34.333Z","comments":true,"path":"default/iOS网络调试/","link":"","permalink":"https://kysonyangs.github.io/default/iOS网络调试/","excerpt":"当在和服务器进行接口调试时，有的时候网络不好，接口返回慢，这个不好调试，但是 Apple 为我们提供了一款工具，让我们可以很方便的进行挖网络状态的模拟. 安装 Additional Tools 下载我们使用 Additional Tools for Xcode 工具来进行网络状态的模拟测试. 下载完毕 打开 DMG -&gt; Hardware -&gt; 双击 Network Link Conditioner.prefPane 添加到偏好设置里。 选择 ON 打开 Network Link Conditioner , 就可以模拟网络状态了","text":"当在和服务器进行接口调试时，有的时候网络不好，接口返回慢，这个不好调试，但是 Apple 为我们提供了一款工具，让我们可以很方便的进行挖网络状态的模拟. 安装 Additional Tools 下载我们使用 Additional Tools for Xcode 工具来进行网络状态的模拟测试. 下载完毕 打开 DMG -&gt; Hardware -&gt; 双击 Network Link Conditioner.prefPane 添加到偏好设置里。 选择 ON 打开 Network Link Conditioner , 就可以模拟网络状态了 启动 Network Link Conditioner 可以根据配置来更改系统的网络环境，从而达到网络状态模拟. 选项： 100% Loss 3G DSL EDGE High Latency DNS Very Bad Network WIFI 或者也可以自己添加 在iOS设备上启用 Network Link Conditioner要在iOS上使用 Network Link Conditioner，可以设置： iOS连接Mac 在Xcode中，导航到Window&gt; Organizer 在侧栏中选择您的设备 点击“用于开发”现在，可以访问“设置”应用的“开发者”部分。您可以在iOS设备上的设置&gt;开发人员&gt;网络下启用和配置 Network Link Conditioner。","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/tags/Xcode/"}]},{"title":"Runtime03 Method","slug":"Runtime03_Method","date":"2018-06-23T10:30:50.000Z","updated":"2020-05-17T08:13:24.547Z","comments":true,"path":"default/Runtime03_Method/","link":"","permalink":"https://kysonyangs.github.io/default/Runtime03_Method/","excerpt":"class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容","text":"class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 然后看下方法的结构123456struct method_t&#123; SEL name; // 方法名 const char *types; // 参数和返回类型encode IMP imp; // 函数指针&#125;;typedef struct method_t *Method; 看下class_rw_t methods 的初始化, class_ro_t 的结构在编译期间已经决定，无法更改12345678910111213141516171819202122232425262728293031static Class realizeClass(Class cls)&#123; const class_ro_t *ro = (const class_ro_t *)cls-&gt;data(); class_rw_t *rw; if(ro-&gt;flags &amp; RO_FUTERE)&#123; // rw已经分配好了 rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING,RW_FUTURE); &#125;else&#123; // 未初始化 rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125; // 其它的一些初始化 // Attach categories methodizeClass(cls);&#125;static void methodizeClass(Class cls)&#123; // 将ro中的基本方法添加到rw中去 method_list_t *list = cls-&gt;data()-&gt;ro-&gt;baseMethods(); prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); cls-&gt;data()-&gt;methods.attachLists(&amp;list, 1); // 初始化属性、协议和分类&#125; 向类动态添加方法class_addMethod 这个函数可以在运行期对类动态添加方法，我们来看下是怎么实现的： 1234567891011121314151617181920212223242526272829BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)&#123; return !addMethod(cls, name, imp, types ?:&quot;&quot;, NO);&#125;static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)&#123; method_t *m; IMP result; if((m = getMethodNoSuper_nolock(cls, name))&#123; // 已经存在这个方法 if(!replace)&#123; result = m-&gt;imp; &#125;else&#123; result = _method_setImplementation(cls, m, imp); // 重新设置imp &#125; &#125;else&#123; // 添加方法 method_list_t *newlist = (method_list_t *)calloc(sizeof(*newlist), 1); newlist-&gt;first.name = name; newlist-&gt;first.types = types; newlist-&gt;first.imp = imp; prepareMethodsLists(cls, &amp;newlist, 1, NO, NO); cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1); flushCaches(cls); result = nil; &#125; return resul;&#125; 向一个类中添加新方法，cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1)，仍然是添加到class_rw_t.methods列表中。","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kysonyangs.github.io/tags/Runtime/"}]},{"title":"Runtime02 NSObject与isa","slug":"Runtime02_NSObject与isa","date":"2018-06-23T08:04:10.000Z","updated":"2020-05-17T08:13:09.767Z","comments":true,"path":"default/Runtime02_NSObject与isa/","link":"","permalink":"https://kysonyangs.github.io/default/Runtime02_NSObject与isa/","excerpt":"NSObject底层看下NSObject中的定义: 123@interface NSObject &lt;NSObject&gt; Class isa;@end 其实NSObject就是一个Class对象，不过是对变量isa封装了一系列的操作而已，那么Class又是什么类型呢？在objc-runtime-new.h可以找到其定义，是指向结构体objc_class的指针，如下：","text":"NSObject底层看下NSObject中的定义: 123@interface NSObject &lt;NSObject&gt; Class isa;@end 其实NSObject就是一个Class对象，不过是对变量isa封装了一系列的操作而已，那么Class又是什么类型呢？在objc-runtime-new.h可以找到其定义，是指向结构体objc_class的指针，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; //isa指针&#125; OBJC2_UNAVAILABLE;struct objc_class : objc_object &#123; // Class ISA; Class superclass; // superclass指针 cache_t cache; // 方法缓存 class_data_bits_t bits; // 数据 // 通过(bits &amp; FAST_DATA_MASK)获取 class_rw_t 数据 class_rw_t *data() &#123; return bits.data(); &#125; ...&#125;struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; //只读属性 method_array_t methods; // 方法列表二维数组 property_array_t properties; //属性列表 protocol_array_t protocols; //协议列表 ...&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; //instance对象所占内存大小#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 再来看一张图 实例、类、元类 存储信息instance对象在内存中存储的信息包括 isa 指针 其他成员变量 class类对象在内存中存储的信息主要包括 isa 指针 superclass 指针 类的属性信息（@property） 类的对象方向方法信息（instance method） 类的协议信息（protocol） 类的成员变量信息（ivar） … meta-class元类对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa 指针 superclass 指针 类的类方向方法信息（class method） …. isa指针在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址 从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息 1234567891011121314151617181920union isa_t&#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; // arm64架构下 uintptr_t nonpointer : 1; // 代表isa的类型，如果为0，则isa中只保存着class的信息，则是之前32位机器时的设计raw isa，如果为1，class信息保存在shiftcls中，其它空间用于保存额外的信息。 uintptr_t has_assoc : 1; // 对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 uintptr_t has_cxx_dtor : 1; // 这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存 uintptr_t shiftcls : 44; // 保存对应的Class指针信息，可以看到复制代码是这样的`newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3`，右移3位的目的是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。 uintptr_t magic : 6; // 初始化之后值为0x3d，用于调试器判断当前对象是真的对象还是没有初始化的空间 uintptr_t weakly_referenced : 1; // 对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 uintptr_t deallocating : 1; // 对象正在释放内存 uintptr_t has_sidetable_rc : 1; // 对象的引用计数太大了，存不下，要用辅助的sidetable来保存 uintptr_t extra_rc : 8; // 对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 6，extra_rc 的值就为 5....&#125;;","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kysonyangs.github.io/tags/Runtime/"}]},{"title":"Runtime01 类与元类","slug":"Runtime01_类与元类","date":"2018-06-23T07:26:30.000Z","updated":"2020-05-16T05:34:22.014Z","comments":true,"path":"default/Runtime01_类与元类/","link":"","permalink":"https://kysonyangs.github.io/default/Runtime01_类与元类/","excerpt":"来看一张经典的描述 isa 和 superclass 指向的图。 从这我们可以看到： isa instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class superclass class的superclass指向父类的class 如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class 基类的meta-class的superclass指向基类的class 方法调用 instance调用对象方法的轨迹 isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹 isa找meta-class，方法不存在，就通过superclass找父类","text":"来看一张经典的描述 isa 和 superclass 指向的图。 从这我们可以看到： isa instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class superclass class的superclass指向父类的class 如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class 基类的meta-class的superclass指向基类的class 方法调用 instance调用对象方法的轨迹 isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹 isa找meta-class，方法不存在，就通过superclass找父类 下面通过代码来确定一下 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface Person: NSObject@end...void test1() &#123; NSLog(@&quot;NSObject class:%p metaclass:%p&quot;, [NSObject class], object_getClass([NSObject class])); Person *person = [[Person alloc] init]; Class cls = person; int i = 0; while (i &lt; 4) &#123; NSLog(@&quot;class:%p metaclass:%p&quot;, cls, object_getClass(cls)); cls = object_getClass(cls); i++; &#125;&#125;输出信息：NSObject class:0x7fff991bd118 metaclass:0x7fff991bd0f0---&gt; 说明 NSObject 的isa 确实指向它的元类class:0x100659b60 metaclass:0x100002100---&gt; 说明 person对象的 isa 指向 Person类对象class:0x100002100 metaclass:0x1000020d8---&gt; 说明 Peson类对象的 isa 指向 Person元对象class:0x1000020d8 metaclass:0x7fff991bd0f0---&gt; 说明 Peson元类对象的 isa 指向 NSObject元类对象class:0x7fff991bd0f0 metaclass:0x7fff991bd0f0---&gt; 说明 NSObject元类对象 isa 指向 NSObject元类对象// 注：// object_getClass 获取 isa 指向对象Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 我们再看一下 objc_allocateClassPair 方法内部实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)&#123; Class cls, meta; rwlock_writer_t lock(runtimeLock); // Fail if the class name is in use. // Fail if the superclass isn&apos;t kosher. if (getClass(name) || !verifySuperclass(superclass, true/*rootOK*/)) &#123; return nil; &#125; // Allocate new classes. cls = alloc_class_for_subclass(superclass, extraBytes); //分配 meta = alloc_class_for_subclass(superclass, extraBytes); // fixme mangle the name if it looks swift-y? objc_initializeClassPair_internal(superclass, name, cls, meta); return cls;&#125;static void objc_initializeClassPair_internal(Class superclass, const char *name, Class cls, Class meta)&#123; runtimeLock.assertWriting(); class_ro_t *cls_ro_w, *meta_ro_w; // 初始化cls和meta的大小和数据 cls-&gt;setData((class_rw_t *)calloc(sizeof(class_rw_t), 1)); meta-&gt;setData((class_rw_t *)calloc(sizeof(class_rw_t), 1)); ... cls_ro_w-&gt;flags = 0; // 普通类 meta_ro_w-&gt;flags = RO_META; // 标记为meta ... // Connect to superclasses and metaclasses cls-&gt;initClassIsa(meta); // 将cls的isa指向meta if (superclass) &#123; meta-&gt;initClassIsa(superclass-&gt;ISA()-&gt;ISA()); // meta的isa指向根类的meta cls-&gt;superclass = superclass; meta-&gt;superclass = superclass-&gt;ISA(); //// meta的父类为父类的meta addSubclass(superclass, cls); addSubclass(superclass-&gt;ISA(), meta); &#125; else &#123; meta-&gt;initClassIsa(meta); // 根类的isa指向自己 cls-&gt;superclass = Nil; meta-&gt;superclass = cls; // 根类的父类指向cls addRootClass(cls); addSubclass(cls, meta); &#125; ....&#125;","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kysonyangs.github.io/tags/Runtime/"}]},{"title":"Runtime相关","slug":"Runtime相关","date":"2018-06-22T07:26:30.000Z","updated":"2020-05-13T11:12:38.972Z","comments":true,"path":"default/Runtime相关/","link":"","permalink":"https://kysonyangs.github.io/default/Runtime相关/","excerpt":"Runtime 是什么？Runtime 又叫运行时，是一套由 C、C++ 会和编写的一套 API，为OC加入了面向对象与运行时机制。 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 KVO 实现原理简单理解 KVO是基于runtime机制实现的 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制 如果原类为Person，那么生成的派生类名为 NSKVONotifying_Person 每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。","text":"Runtime 是什么？Runtime 又叫运行时，是一套由 C、C++ 会和编写的一套 API，为OC加入了面向对象与运行时机制。 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 KVO 实现原理简单理解 KVO是基于runtime机制实现的 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制 如果原类为Person，那么生成的派生类名为 NSKVONotifying_Person 每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 深入理解 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听； 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。 （isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制. 子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 消息发送原理如下这个方法：1[lisi read:huozhe]; 会被编译成1objc_sgSend(lisi, @selector(read:), huozhe); objc_msgSend的具体流程如下： 通过isa指针找到所属类 查找类的cache列表, 如果没有则下一步 查找类的”方法列表” 如果能找到与选择子名称相符的方法, 就跳至其实现代码 找不到, 就沿着继承体系继续向上查找 如果能找到与选择子名称相符的方法, 就跳至其实现代码 找不到, 执行”消息转发”. 消息转发机制原理消息转发机制基本分为三个步骤： 动态方法解析 备用接受者 完整转发 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod:(实例方法)或者 +resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过 class_addMethod 函数动态添加到类里面就可以了。 1234567891011121314151617181920@interface HiClass: NSObject- (void)hello;@end@implementation HiClassvoid functionForMethod(id self, SEL _cmd) &#123; NSLog(@&quot;hello!&quot;);&#125;// selector : 那个未知的选择子// 返回YES则结束消息转发// 返回NO则进入备用接受者+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSLog(@&quot;resolveInstanceMethod&quot;); NSString *selString = NSStringFromSelector(sel); if ([selString isEqualToString:@&quot;hello&quot;]) &#123; class_addMethod(self, @selector(hello), (IMP)functionForMethod, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end 备用接受者动态方法解析无法处理消息，则会走备用接受者。这个备用接受者只能是一个新的对象，不能是self本身，否则就会出现无限循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。123456789101112131415161718192021222324252627@interface RuntimeMethodHelper: NSObject@end@implementation RuntimeMethodHelper- (void)hello &#123; NSLog(@&quot;%@, %p -&gt; hello&quot;, self, _cmd);&#125;@end@interface HiClass: NSObject&#123; RuntimeMethodHelper *_helper;&#125;- (void)hello;@end@implementation HiClass// selector : 那个未知的消息// 返回一个能响应该未知选择子的备用对象- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSLog(@&quot;forwardingTargetForSelector&quot;); NSString *selectorString = NSStringFromSelector(aSelector); // 将消息交给_helper来处理 if ([selectorString isEqualToString:@&quot;hello&quot;]) &#123; return _helper; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 完整消息转发如果动态方法解析和备用接受者都没有处理这个消息，那么就会走完整消息转发： 123456789101112131415161718192021222324252627282930313233343536@interface RuntimeMethodHelper: NSObject@end@implementation RuntimeMethodHelper- (void)hello &#123; NSLog(@&quot;%@, %p -&gt; hello&quot;, self, _cmd);&#125;@end@interface HiClass: NSObject&#123; RuntimeMethodHelper *_helper;&#125;- (void)hello;@end@implementation HiClass// invocation : 封装了与那条尚未处理的消息相关的所有细节的对象- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; NSLog(@&quot;forwardInvocation&quot;); if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:_helper]; &#125;&#125;// 必须重新这个方法，消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象// NSMethodSignature : 该selector对应的方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSLog(@&quot;methodSignatureForSelector&quot;); NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([RuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123; signature = [RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;@end weak实现原理Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 附加： 实现weak后，为什么对象释放后会自动为nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？ 调用objc_release 因为对象的引用计数为0，所以执行dealloc 在dealloc中，调用了_objc_rootDealloc函数 在_objc_rootDealloc中，调用了object_dispose函数 调用objc_destructInstance 最后调用objc_clear_deallocating,详细过程如下： a. 从weak表中获取废弃对象的地址为键值的记录 b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil c. 将weak表中该记录删除 d. 从引用计数表中删除废弃对象的地址为键值的记录","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kysonyangs.github.io/tags/Runtime/"}]},{"title":"线程安全、锁","slug":"线程安全、锁","date":"2018-06-20T07:23:23.000Z","updated":"2020-05-17T08:16:01.535Z","comments":true,"path":"default/线程安全、锁/","link":"","permalink":"https://kysonyangs.github.io/default/线程安全、锁/","excerpt":"nonatomic 与 atomic nonatomic: 不会对生成的 getter、setter 方法加同步锁（非原子性） atomic: 会对生成的 getter、setter 加同步锁（原子性）setter / getter 被 atomic 修饰的属性时，该属性是读写安全的。然而读写安全并不代表线程安全。","text":"nonatomic 与 atomic nonatomic: 不会对生成的 getter、setter 方法加同步锁（非原子性） atomic: 会对生成的 getter、setter 加同步锁（原子性）setter / getter 被 atomic 修饰的属性时，该属性是读写安全的。然而读写安全并不代表线程安全。 线程安全概念（thread safety） 线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 验证 atomic 非线程安全如下代码12345678910111213141516171819202122232425@interface ViewController ()@property (atomic, copy) NSString *name;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; self.name = @&quot;kyson&quot;; NSLog(@&quot;kyson == %@&quot;, self.name); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; self.name = @&quot;shen&quot;; NSLog(@&quot;shen == %@&quot;, self.name); &#125; &#125;);&#125;@end 输出结果123456782018-07-09 15:28:05.681759+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:05.681857+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:05.681956+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:05.721291+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:05.721291+0800 YSThreadSafetyTest[3186:1387832] kyson == shen2018-07-09 15:28:06.347283+0800 YSThreadSafetyTest[3186:1387942] shen == shen2018-07-09 15:28:06.386894+0800 YSThreadSafetyTest[3186:1387832] kyson == kyson2018-07-09 15:28:06.386894+0800 YSThreadSafetyTest[3186:1387942] shen == kyson 第五行和第8行可以看出， atomic 非线程安全。 也就是说 atomic 只能做到读写安全并不能做到线程安全，若要实现线程安全还需要采用更为深层的锁定机制才行。 iOS开发时一般都会使用 nonatomic 属性，因为在iOS中使用同步锁的开销较大，这会带来性能问题，但是在Mac OS X程序时，使用 atomic 属性通常都不会有性能瓶颈。 锁的概念在计算机科学中，锁是一种同步机制，用于在存在多线程的环境中实施对资源的访问限制。 锁的作用 通俗来讲：就是为了防止在多线程的情况下对共享资源的脏读或者脏写。 也可以理解为：执行多线程时用于强行限制资源访问的同步机制，即并发控制中保证互斥的要求。 iOS开发中常用的锁 @synchronized NSLock 对象锁 NSRecursiveLock 递归锁 NSConditionLock 条件锁 pthread_mutex 互斥锁（C语言） dispatch_semaphore 信号量实现加锁（GCD） OSSpinLock 自旋锁 性能：ibireme 大神博客盗的性能图 =-= @synchronized@synchronized 其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读性。@synchronized 是我们平常使用最多的但是性能最差的。123456789// OC@synchronized(self) &#123; // 需要执行的代码块&#125;// Swiftobjc_sync_enter(self)// 需要执行的代码块objc_sync_exit(self) 如下代码示例1234567891011121314dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; @synchronized(self) &#123; NSLog(@&quot;第一个线程同步操作开始&quot;); sleep(3); NSLog(@&quot;第一个线程同步操作结束&quot;); &#125;&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); @synchronized(self) &#123; NSLog(@&quot;第二个线程同步操作&quot;); &#125;&#125;); 输出结果1232018-07-09 15:42:06.226069+0800 YSThreadSafetyTest[3294:1487479] 第一个线程同步操作开始2018-07-09 15:42:09.226758+0800 YSThreadSafetyTest[3294:1487479] 第一个线程同步操作结束2018-07-09 15:42:09.226942+0800 YSThreadSafetyTest[3294:1487480] 第二个线程同步操作 @synchronized(self) 指令使用的 self 为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的 self 改成其它对象，线程2就不会被阻塞。 @synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized 块会隐式的添加一个异常处理来保护代码，该处理会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 如果在 @sychronized(object){} 内部 object 被释放或被设为 nil，从我做的测试的结果来看，的确没有问题，但如果 object 一开始就是 nil，则失去了锁的功能。不过虽然 nil 不行，但 @synchronized([NSNull null]) 是完全可以的。 NSLock 对象锁 NSLock 中实现了一个简单的互斥锁。通过 NSLocking 协议定义了 lock 和 unlock 方法。 1234@protocol NSLocking- (void)lock;- (void)unlock;@end 代码示例：银行取钱1234567891011121314151617181920212223242526272829- (void)nslockTest &#123; _money = 1000; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self drawMoney:@&quot;小明&quot;]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self drawMoney:@&quot;小红&quot;]; &#125;);&#125;- (void)drawMoney:(NSString *)person &#123; while (1) &#123; sleep(1); // 加锁 [_lock lock]; if (_money &gt; 0) &#123; _money -= 200; NSLog(@&quot;%@ 取出200元，剩余：%zd元&quot;, person, _money); &#125; else &#123; NSLog(@&quot;%@ 小明 没钱了，勿取&quot;, person); break; &#125; // 解锁 [_lock unlock]; &#125;&#125; 加锁结果：1234562018-07-09 16:04:06.603614+0800 YSThreadSafetyTest[3547:1618383] 小红 取出200元，剩余：800元2018-07-09 16:04:06.603813+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：600元2018-07-09 16:04:07.608957+0800 YSThreadSafetyTest[3547:1618383] 小红 取出200元，剩余：400元2018-07-09 16:04:07.609166+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：200元2018-07-09 16:04:08.611343+0800 YSThreadSafetyTest[3547:1618389] 小明 取出200元，剩余：0元2018-07-09 16:04:08.611538+0800 YSThreadSafetyTest[3547:1618383] 小红 小明 没钱了，勿取 不加锁结果：12345672018-07-09 16:05:10.608726+0800 YSThreadSafetyTest[3565:1624593] 小红 取出200元，剩余：600元2018-07-09 16:05:10.608736+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：800元2018-07-09 16:05:11.612305+0800 YSThreadSafetyTest[3565:1624593] 小红 取出200元，剩余：200元2018-07-09 16:05:11.612305+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：400元2018-07-09 16:05:12.616221+0800 YSThreadSafetyTest[3565:1624593] 小红 小明 没钱了，勿取2018-07-09 16:05:12.616220+0800 YSThreadSafetyTest[3565:1624590] 小明 取出200元，剩余：0元2018-07-09 16:05:13.617584+0800 YSThreadSafetyTest[3565:1624590] 小明 小明 没钱了，勿取 NSLock 类还增加了 tryLock 和 lockBeforeDate: 方法 12- (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; tryLock 尝试加锁，它不会阻塞线程，失败返回NO。 lockBeforeDate: 在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。示例代码： 123456789101112131415161718192021222324252627282930- (void)nslockTest2 &#123; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [_lock lock]; NSLog(@&quot;线程1同步开始&quot;); sleep(5); NSLog(@&quot;线程1同步结束&quot;); [_lock unlock]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); NSLog(@&quot;尝试加锁&quot;); if ([_lock tryLock]) &#123;//尝试加锁，如果不行返回NO，不会阻塞该线程 NSLog(@&quot;加锁成功&quot;); [_lock unlock]; &#125; else &#123; NSLog(@&quot;加锁失败，已经有锁了&quot;); &#125; NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3]; NSLog(@&quot;3s后尝试加锁&quot;); if ([_lock lockBeforeDate:date]) &#123;//尝试在未来的3s内加锁，并阻塞该线程，如果3s内不行恢复线程, 返回NO,不会阻塞该线程 NSLog(@&quot;没有超时，加锁成功&quot;); [_lock unlock]; &#125; else &#123; NSLog(@&quot;超时，加锁失败&quot;); &#125; NSLog(@&quot;线程2 OK&quot;); &#125;);&#125; 输出结果：12345672018-07-09 16:33:51.939314+0800 YSThreadSafetyTest[3874:1773831] 线程1同步开始2018-07-09 16:33:52.944446+0800 YSThreadSafetyTest[3874:1773854] 尝试加锁2018-07-09 16:33:52.944671+0800 YSThreadSafetyTest[3874:1773854] 加锁失败，已经有锁了2018-07-09 16:33:52.944826+0800 YSThreadSafetyTest[3874:1773854] 3s后尝试加锁2018-07-09 16:33:55.946002+0800 YSThreadSafetyTest[3874:1773854] 超时，加锁失败2018-07-09 16:33:55.946176+0800 YSThreadSafetyTest[3874:1773854] 线程2 OK2018-07-09 16:33:56.944367+0800 YSThreadSafetyTest[3874:1773831] 线程1同步结束 NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁。 如下代码：12345678910111213141516171819- (void)recursiveLockTest &#123; _lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;递归开始&quot;); static void(^TestMethod)(int); TestMethod = ^(int value)&#123; [_lock lock]; if (value &gt; 0) &#123; sleep(1); value--; NSLog(@&quot;递归中 %zd&quot;, value); TestMethod(value); &#125; [_lock unlock]; &#125;; TestMethod(5); NSLog(@&quot;结束&quot;); &#125;);&#125; 输出结果：122018-07-09 16:39:52.833302+0800 YSThreadSafetyTest[3947:1804640] 递归开始2018-07-09 16:39:53.834239+0800 YSThreadSafetyTest[3947:1804640] 递归中 4 可以看到永远都不会结束，这是一个死锁情况。在这个线程中，TestMethod 递归调用，每次进入Block 都会去加一次锁，而从第二次开始，由于锁已经使用了且没有解锁，所以他需要等待锁被解除，这样就导致死锁，线程被阻塞住。 这里可以使用 NSRecursiveLock 递归锁来解决。递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。 NSConditionLock 条件锁NSCoditionLock 做多线程之间的任务等待调用，而且是线程安全的。 NSConditionLock 源码：123456789101112131415161718@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125;- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;@property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);@end NSConditionLock 和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock，tryLockWhenCondition:，NSConditionLock 可以称为条件锁，只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。而 unlockWithCondition: 并不是当 condition符合条件时才解锁，而是解锁之后，修改 Condition 的值。 如下代码：1234567891011121314151617181920212223242526- (void)conditionLockTest &#123; NSMutableArray *products = [NSMutableArray array]; NSInteger HAS_DATA = 1; NSInteger NO_DATA = 0; _conditionLock = [[NSConditionLock alloc] initWithCondition:NO_DATA]; // 初始化一个条件 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; [_conditionLock lockWhenCondition:NO_DATA]; // 当条件为NO_DATA时加锁 [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;生产&quot;); [_conditionLock unlockWithCondition:HAS_DATA]; // 解锁并将条件置为HAS_DATA sleep(5); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (1) &#123; NSLog(@&quot;等待&quot;); [_conditionLock lockWhenCondition:HAS_DATA]; // 当条件为HAS_DATA时加锁 [products removeObjectAtIndex:0]; NSLog(@&quot;售卖&quot;); [_conditionLock unlockWithCondition:NO_DATA]; // 解锁并将条件置为NO_DATA &#125; &#125;);&#125; 输出结果：123452018-07-09 16:55:54.080428+0800 YSThreadSafetyTest[4077:1872496] 等待2018-07-09 16:55:54.080425+0800 YSThreadSafetyTest[4077:1872434] 生产2018-07-09 16:55:54.080664+0800 YSThreadSafetyTest[4077:1872496] 售卖2018-07-09 16:55:54.080751+0800 YSThreadSafetyTest[4077:1872496] 等待... NSCondition一种最基本的条件锁。手动控制线程wait和signal。 NSCondition 源码：12345678910111213@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125;- (void)wait;- (BOOL)waitUntilDate:(NSDate *)limit;- (void)signal;- (void)broadcast;@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);@end NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，经测试，NSCondition 并不会像上文的那些锁一样，先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 示例代码：1234567891011121314151617181920212223242526- (void)conditionTest &#123; NSCondition *condition = [[NSCondition alloc] init]; NSMutableArray *products = [NSMutableArray array]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; if ([products count] == 0) &#123; NSLog(@&quot;等待添加&quot;); [condition wait]; // waitUntilDate: 方法有个等待时间限制，指定的时间到了，则放回 NO，继续运行接下来的任务 &#125; [products removeObjectAtIndex:0]; NSLog(@&quot;删除第一个&quot;); [condition unlock]; &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;数组 总量:%zi&quot;,products.count); [condition signal]; [condition unlock]; sleep(1); &#125; &#125;);&#125; 输出结果：12342018-07-09 17:08:52.504797+0800 YSThreadSafetyTest[4144:1951113] 等待添加2018-07-09 17:08:52.504920+0800 YSThreadSafetyTest[4144:1951112] 数组 总量:12018-07-09 17:08:52.505196+0800 YSThreadSafetyTest[4144:1951113] 删除第一个... waitUntilDate: 方法有个等待时间限制，指定的时间到了，则放回 NO，继续运行接下来的任务 其中 signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。如果没有等待的线程，这两个方法都没有作用。 pthread_mutex 互斥锁（C语言）c语言定义下多线程加锁方式。 pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr); 初始化锁变量mutex。attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t mutex); 加锁 pthread_mutex_tylock(*pthread_mutex_t *mutex); 加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t* mutex); 使用完后释放 示例代码:123456789101112131415161718#import &lt;pthread.h&gt;- (void)pthread_mutex_test &#123; __block pthread_mutex_t theLock; pthread_mutex_init(&amp;theLock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;theLock); NSLog(@&quot;线程1同步开始&quot;); sleep(3); NSLog(@&quot;线程1同步结束&quot;); pthread_mutex_unlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;theLock); NSLog(@&quot;线程2同步操作&quot;); pthread_mutex_unlock(&amp;theLock); &#125;);&#125; 输出结果：1232018-07-09 17:18:39.172501+0800 YSThreadSafetyTest[4201:2003796] 线程1同步开始2018-07-09 17:18:42.177652+0800 YSThreadSafetyTest[4201:2003796] 线程1同步结束2018-07-09 17:18:42.177872+0800 YSThreadSafetyTest[4201:2004380] 线程2同步操作 pthread_mutex 还可以创建条件锁，提供了和 NSCondition 一样的条件控制，初始化互斥锁同时使用 pthread_cond_init 来初始化条件数据结构 123456789101112// 初始化int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);// 等待（会阻塞）int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);// 定时等待int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);// 唤醒int pthread_cond_signal (pthread_cond_t *cond);// 广播唤醒int pthread_cond_broadcast (pthread_cond_t *cond);// 销毁int pthread_cond_destroy (pthread_cond_t *cond); pthread_mutex 还提供了很多函数，有一套完整的API，包含 Pthreads线程的创建控制等等，非常底层，可以手动处理线程的各个状态的转换即管理生命周期，甚至可以实现一套自己的多线程，感兴趣的可以继续深入了解。 dispatch_semaphore 信号量实现加锁（GCD）dispatch_semaphore_t GCD 中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量 +1；每当发送一个等待信号时信号量 -1,；如果信号量为 0 则信号会处于等待状态，直到信号量大于 0(或者超时) 开始执行之后代码。 源码如下：123456789101112131415161718192021222324252627282930/*! * @param value * 信号量的起始值，当传入的值小于零时返回NULL * @result * 成功返回一个新的信号量，失败返回NULL */dispatch_semaphore_t dispatch_semaphore_create(long value)/*! * @discussion * 信号量减1，如果结果小于0，那么等待队列中信号增量到来直到timeout * @param dsema * 信号量 * @param timeout * 等待时间 * 类型为dispatch_time_t，这里有两个宏DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER * @result * 若等待成功返回0，timeout返回非0 */long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);/*! * @discussion * 信号量加1，如果之前的信号量小于0，将唤醒一条等待线程 * @param dsema * 信号量 * @result * 唤醒一条线程返回非0，否则返回0 */long dispatch_semaphore_signal(dispatch_semaphore_t dsema) 示例代码:12345678910111213141516171819202122- (void)semaphoreTest &#123; // 创建信号量 dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC); //线程1 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(semaphore, overTime); // DISPATCH_TIME_FOREVER NSLog(@&quot;任务1开始&quot;); sleep(3); NSLog(@&quot;任务1结束&quot;); dispatch_semaphore_signal(semaphore); &#125;); //线程2 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, overTime); NSLog(@&quot;任务2&quot;); dispatch_semaphore_signal(semaphore); &#125;);&#125; 输出结果：1232018-07-09 17:30:16.753036+0800 YSThreadSafetyTest[4309:2092729] 任务1开始2018-07-09 17:30:19.755907+0800 YSThreadSafetyTest[4309:2092729] 任务1结束2018-07-09 17:30:19.755907+0800 YSThreadSafetyTest[4309:2092656] 任务2 将超时代码设置为1，则输出：1232018-07-09 17:28:41.082817+0800 YSThreadSafetyTest[4286:2081073] 任务1开始2018-07-09 17:28:42.085262+0800 YSThreadSafetyTest[4286:2081075] 任务22018-07-09 17:28:44.084425+0800 YSThreadSafetyTest[4286:2081073] 任务1结束 OSSpinLock 自旋锁示例代码：12345678910111213141516171819#import &lt;libkern/OSAtomic.h&gt;- (void)osspinlockTest &#123; __block OSSpinLock theLock = OS_SPINLOCK_INIT; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); NSLog(@&quot;线程1同步操作开始&quot;); sleep(3); NSLog(@&quot;线程1同步操作结束&quot;); OSSpinLockUnlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); sleep(1); NSLog(@&quot;线程2同步操作&quot;); OSSpinLockUnlock(&amp;theLock); &#125;);&#125; 输出结果：1232018-07-09 17:33:04.759875+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作开始2018-07-09 17:33:07.762309+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作结束2018-07-09 17:33:08.817638+0800 YSThreadSafetyTest[4349:2110977] 线程2同步操作 OSSpinLock 自旋锁，性能最高的锁。它的缺点是当等待时会消耗大量 CPU 资源，不太适用于较长时间的任务。 YY大神在博客 不再安全的 OSSpinLock 中说明了OSSpinLock 已经不再安全，暂不建议使用。 iOS 10 之后，苹果给出了解决方案，就是用 os_unfair_lock 代替 OSSpinLock。1&apos;OSSpinLockLock&apos; is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock_lock() from &lt;os/lock.h&gt; instead 示例代码1234567891011121314151617#import &lt;os/lock.h&gt;__block os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; os_unfair_lock_lock(&amp;lock); NSLog(@&quot;线程1同步操作开始&quot;); sleep(8); NSLog(@&quot;线程1同步操作结束&quot;); os_unfair_lock_unlock(&amp;lock);&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(1); os_unfair_lock_lock(&amp;lock); NSLog(@&quot;线程2同步操作&quot;); os_unfair_lock_unlock(&amp;lock);&#125;); 输出结果：1232018-07-09 17:33:04.759875+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作开始2018-07-09 17:33:07.762309+0800 YSThreadSafetyTest[4349:2110976] 线程1同步操作结束2018-07-09 17:33:08.817638+0800 YSThreadSafetyTest[4349:2110977] 线程2同步操作 总结 @synchronized：适用线程不多，任务量不大的多线程加锁 NSLock：性能不算差，但感觉用的人不多。 dispatch_semaphore_t：使用信号来做加锁，性能很高和 OSSpinLock 差不多。推荐 NSConditionLock：多线程处理不同任务的通信建议时用， 只加锁的话性能很低。 NSRecursiveLock：性能不错，使用场景限制于递归。 POSIX(pthread_mutex)：C语言的底层api，复杂的多线程处理建议使用，也可以封装自己的多线程。 OSSpinLock：性能非常高，可惜不安全了，使用 os_unfair_lock 来代替。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"iOS设备信息","slug":"iOS设备信息","date":"2018-06-13T07:24:15.000Z","updated":"2020-05-17T08:14:44.599Z","comments":true,"path":"default/iOS设备信息/","link":"","permalink":"https://kysonyangs.github.io/default/iOS设备信息/","excerpt":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，整理一下各种信息的获取方式：","text":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，整理一下各种信息的获取方式： 设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 获取设备型号然后手动转化为对应名称- (NSString *)getDeviceName&#123; // 需要#import &quot;sys/utsname.h&quot; #warning 题主呕心沥血总结！！最全面！亲测！全网独此一份！！ struct utsname systemInfo; uname(&amp;systemInfo); NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;; if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;; if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;; // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([deviceString isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;; if ([deviceString isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;; if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;; if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;; if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;; if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;; if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;; if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;; if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;; if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;; if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;; if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;; if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;; if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;; if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;; if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;; if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;; if ([machineString isEqualToString:@&quot;iPad6,11&quot;]) return @&quot;iPad 5 (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5 (Cellular)&quot;; if ([machineString isEqualToString:@&quot;iPad7,1&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (Cellular)&quot;; if ([machineString isEqualToString:@&quot;iPad7,3&quot;]) return @&quot;iPad Pro 10.5 inch (WiFi)&quot;; if ([machineString isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5 inch (Cellular)&quot;; if ([deviceString isEqualToString:@&quot;AppleTV2,1&quot;]) return @&quot;Apple TV 2&quot;; if ([deviceString isEqualToString:@&quot;AppleTV3,1&quot;]) return @&quot;Apple TV 3&quot;; if ([deviceString isEqualToString:@&quot;AppleTV3,2&quot;]) return @&quot;Apple TV 3&quot;; if ([deviceString isEqualToString:@&quot;AppleTV5,3&quot;]) return @&quot;Apple TV 4&quot;; if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;; if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;; return deviceString;&#125; iPhone名称1[UIDevice currentDevice].name; app版本号1[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]; 电池电量1[[UIDevice currentDevice] batteryLevel]; localizedModel1[UIDevice currentDevice].localizedModel; 当前系统名称1[UIDevice currentDevice].systemName; 当前系统版本号1[UIDevice currentDevice].systemVersion; device_model123struct utsname systemInfo;uname(&amp;systemInfo);NSString *device_model = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; mac 地址12345678910111213141516171819202122232425262728293031323334353637383940414243- (NSString *)getMacAddress &#123; int mib[6]; size_t len; char *buf; unsigned char *ptr; struct if_msghdr *ifm; struct sockaddr_dl *sdl; mib[0] = CTL_NET; mib[1] = AF_ROUTE; mib[2] = 0; mib[3] = AF_LINK; mib[4] = NET_RT_IFLIST; if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123; printf(&quot;Error: if_nametoindex error/n&quot;); return NULL; &#125; if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 1/n&quot;); return NULL; &#125; if ((buf = malloc(len)) == NULL) &#123; printf(&quot;Could not allocate memory. error!/n&quot;); return NULL; &#125; if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 2&quot;); return NULL; &#125; ifm = (struct if_msghdr *)buf; sdl = (struct sockaddr_dl *)(ifm + 1); ptr = (unsigned char *)LLADDR(sdl); NSString *outstring = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)]; free(buf); return [outstring uppercaseString];&#125; IP 地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (NSString *)getDeviceIPAddresses &#123; int sockfd = socket(AF_INET, SOCK_DGRAM, 0); NSMutableArray *ips = [NSMutableArray array]; int BUFFERSIZE = 4096; struct ifconf ifc; char buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr; struct ifreq *ifr, ifrcopy; ifc.ifc_len = BUFFERSIZE; ifc.ifc_buf = buffer; if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= 0)&#123; for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )&#123; ifr = (struct ifreq *)ptr; int len = sizeof(struct sockaddr); if (ifr-&gt;ifr_addr.sa_len &gt; len) &#123; len = ifr-&gt;ifr_addr.sa_len; &#125; ptr += sizeof(ifr-&gt;ifr_name) + len; if (ifr-&gt;ifr_addr.sa_family != AF_INET) continue; if ((cptr = (char *)strchr(ifr-&gt;ifr_name, &apos;:&apos;)) != NULL) *cptr = 0; if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0) continue; memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ); ifrcopy = *ifr; ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy); if ((ifrcopy.ifr_flags &amp; IFF_UP) == 0) continue; NSString *ip = [NSString stringWithFormat:@&quot;%s&quot;, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)]; [ips addObject:ip]; &#125; &#125; close(sockfd); NSString *deviceIP = @&quot;&quot;; for (int i=0; i &lt; ips.count; i++) &#123; if (ips.count &gt; 0) &#123; deviceIP = [NSString stringWithFormat:@&quot;%@&quot;,ips.lastObject]; &#125; &#125; return deviceIP;&#125; 设备上次重启的时间12NSTimeInterval time = [[NSProcessInfo processInfo] systemUptime];NSDate *lastRestartDate = [[NSDate alloc] initWithTimeIntervalSinceNow:(0 - time)]; 广告位标识符在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置 | 隐私 | 广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了 1NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; UUID通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。12NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString];NSLog(@&quot;唯一识别码uuid--&gt;%@&quot;, uuid); CPU12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// CPU总数目- (NSUInteger)getCPUCount &#123; return [NSProcessInfo processInfo].activeProcessorCount;&#125;// 已使用的CPU比例- (float)getCPUUsage &#123; float cpu = 0; NSArray *cpus = [self getPerCPUUsage]; if (cpus.count == 0) return -1; for (NSNumber *n in cpus) &#123; cpu += n.floatValue; &#125; return cpu;&#125;// 获取每个cpu的使用比例- (NSArray *)getPerCPUUsage &#123; processor_info_array_t _cpuInfo, _prevCPUInfo = nil; mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0; unsigned _numCPUs; NSLock *_cpuUsageLock; int _mib[2U] = &#123; CTL_HW, HW_NCPU &#125;; size_t _sizeOfNumCPUs = sizeof(_numCPUs); int _status = sysctl(_mib, 2U, &amp;_numCPUs, &amp;_sizeOfNumCPUs, NULL, 0U); if (_status) _numCPUs = 1; _cpuUsageLock = [[NSLock alloc] init]; natural_t _numCPUsU = 0U; kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;_numCPUsU, &amp;_cpuInfo, &amp;_numCPUInfo); if (err == KERN_SUCCESS) &#123; [_cpuUsageLock lock]; NSMutableArray *cpus = [NSMutableArray new]; for (unsigned i = 0U; i &lt; _numCPUs; ++i) &#123; Float32 _inUse, _total; if (_prevCPUInfo) &#123; _inUse = ( (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER]) + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM]) + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]) ); _total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]); &#125; else &#123; _inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]; _total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]; &#125; [cpus addObject:@(_inUse / _total)]; &#125; [_cpuUsageLock unlock]; if (_prevCPUInfo) &#123; size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo; vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize); &#125; return cpus; &#125; else &#123; return nil; &#125;&#125; Disk 磁盘123456789101112131415161718192021222324252627// 获取磁盘总空间- (int64_t)getTotalDiskSpace &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;// 获取未使用的磁盘空间- (int64_t)getFreeDiskSpace &#123; NSError *error = nil; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) return -1; int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue]; if (space &lt; 0) space = -1; return space;&#125;// 获取已使用的磁盘空间- (int64_t)getUsedDiskSpace &#123; int64_t totalDisk = [self getTotalDiskSpace]; int64_t freeDisk = [self getFreeDiskSpace]; if (totalDisk &lt; 0 || freeDisk &lt; 0) return -1; int64_t usedDisk = totalDisk - freeDisk; if (usedDisk &lt; 0) usedDisk = -1; return usedDisk;&#125; 内存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 系统总内存空间- (int64_t)getTotalMemory &#123; int64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory]; if (totalMemory &lt; -1) totalMemory = -1; return totalMemory;&#125;// 活跃的内存,正在使用或者很短时间内被使用过- (int64_t)getActiveMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.active_count * page_size;&#125;// 最近使用过,但是目前处于不活跃状态的内存- (int64_t)getInActiveMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.inactive_count * page_size;&#125;// 空闲的内存空间- (int64_t)getFreeMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.free_count * page_size;&#125;// 已使用的内存空间- (int64_t)getUsedMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);&#125;// 用来存放内核和数据结构的内存,framework、用户级别的应用无法分配- (int64_t)getWiredMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.wire_count * page_size;&#125;// 可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间- (int64_t)getPurgableMemory &#123; mach_port_t host_port = mach_host_self(); mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t); vm_size_t page_size; vm_statistics_data_t vm_stat; kern_return_t kern; kern = host_page_size(host_port, &amp;page_size); if (kern != KERN_SUCCESS) return -1; kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size); if (kern != KERN_SUCCESS) return -1; return vm_stat.purgeable_count * page_size;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"Playground使用","slug":"Playground使用","date":"2018-06-08T07:25:50.000Z","updated":"2020-05-17T08:13:31.513Z","comments":true,"path":"default/Playground使用/","link":"","permalink":"https://kysonyangs.github.io/default/Playground使用/","excerpt":"Sources 目录通常情况下，我们直接在 Playground 上面写代码，然后编译器会实时编译我们代码，并将结果显示出来。这很好，我们可以实时得到代码的反馈。 但是这也会产生一个问题，如果我们写了一个函数，或者自定义了一个 view，这部分代码一般情况下是不会变的，而编译器却会一次又一次地去编译这些代码，最终的结果就是导致效率的低下。 这时，Sources 目录就派上用场了，使用 Cmd + 1 打开项目导航栏(Project Navigator)，可以看到一个 Sources 目录。放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。 注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。","text":"Sources 目录通常情况下，我们直接在 Playground 上面写代码，然后编译器会实时编译我们代码，并将结果显示出来。这很好，我们可以实时得到代码的反馈。 但是这也会产生一个问题，如果我们写了一个函数，或者自定义了一个 view，这部分代码一般情况下是不会变的，而编译器却会一次又一次地去编译这些代码，最终的结果就是导致效率的低下。 这时，Sources 目录就派上用场了，使用 Cmd + 1 打开项目导航栏(Project Navigator)，可以看到一个 Sources 目录。放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。 注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。 资源由于 Playground 并没有使用沙盒机制，所以我们无法直接使用沙盒来存储资源文件。 但是，这并不意味着在 Playground 中没办法使用资源文件，Playground 提供了两个地方来存储资源，一个是每个 Playground 都独立的资源，而另一个是所有 Playground 都共享的资源。 独立资源在打开的项目导航栏中可以看到有一个 Resources 目录，放置到此目录下的资源是每个 Playground 独立的。 这个目录的资源是直接放到 mainBundle 中的，可以使用如下代码来获取资源路径：1234if let path = NSBundle.mainBundle().pathForResource(&quot;example&quot;, ofType: &quot;json&quot;) &#123; // do something with json // ...&#125; 如果是图片文件，也可以直接使用UIImage(named:)来获取。 共享资源共享资源的目录是放在用户目录的 Documents 目录下的。在代码中可以直接使用XCPlaygroundSharedDataDirectoryURL来获取共享资源目录的 URL(需要先导入 XCPlayground 模块)。123import XCPlaygroudlet sharedFileURL = XCPlaygroundSharedDataDirectoryURL.URLByAppendingPathComponent(&quot;example.json&quot;) 注意：你需要创建~/Documents/Shared Playground Data目录，并将资源放到此目录下，才能在 Playground 中获取到 异步执行Playground 中的代码是顶层代码(top-level code)，也就是它是在于全局作用域中的。这些代码将会从上到下执行，并在执行完毕之后立即停止。 我们的异步回调代码一般都无法在程序结束之前获得执行，因此如果我们在 Playground 执行网络，或者其它耗时的异步操作，都无法获得我们想要的结果(之前我在 Playgroud 中学习网络操作的时候，就被这个特性折磨到发狂，我一直以为是自己的网络代码写错了)。 为了让程序在代码执行结束后继续执行，我们可以使用如下代码：1XCPlaygroundPage.currentPage.needsIndefiniteExecution = true 这句代码会让 Playground 永远执行下去 ，当我们获取了需要的结果后，可以使用 XCPlaygroundPage.currentPage.finishExecution() 停止 Playground 的执行：123456789101112import XCPlaygroundXCPlaygroundPage.currentPage.needsIndefiniteExecution = truelet url = NSURL(string: &quot;http://httpbin.org/image/png&quot;)!let task = NSURLSession.sharedSession().dataTaskWithURL(url) &#123; data, _, _ in let image = UIImage(data: data!) XCPlaygroundPage.currentPage.finishExecution()&#125;task.resume() 支持 MarkdownPlayground 已经原生支持 markdown 注释渲染，只需要在单行或多行注释的后面添加冒号 :，标记这是一个 markdown 注释。1234567891011//: This line will have **bold** and *italic* text./*:## Headers of All Sizes### Lists of Links- [NSHipster](http://nshipster.com)- [ASCIIwwdc](http://asciiwwdc.com)- [SwiftDoc](http://swiftdoc.org)*/ 可以到菜单 Editor → Show Rendered Markup 下切换是否进行 markdown 渲染。 多页面Playground 支持多页面，这可以让我们将不同类别的代码分别写到不同的页面下，并可以在多个页面之间进行跳转。在项目导航栏中，选择 File &gt; New &gt; Playground Page， 就可以新建一个页面，或者选择项目导航栏左下角的 + 号选择 New Page。注意：如果本 Playground 是第一次新建 Page，则系统会产生两个 Page，一个代表你当前的页面，一个是新建的页面。 页面跳转Playground 支持三种方式的页面跳转： 上一页 下一页 跳转到指定页 页面顺序都是根据它们在项目文件中的排序来决定的。 上一页与下一页的语法：123//: [&quot;Go to Next Page&quot;](@next)//: [&quot;Go to Previous Page&quot;](@previous) 与 markdown 中的超链接类似，方括号中的代码要显示的文字，而小括号则代表跳转的目的地。 指定页跳转：1//: [&quot;Go to The End&quot;](PageName) PageName 代表目标页面的名称，如果页面名称中有空格，则需要使用%20来代替，这是 ASCII 中空格的符号。如下：1//: [&quot;Go to The End&quot;](Last%20Page) 官方文档","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"LLDB调试","slug":"LLDB调试","date":"2018-05-25T07:25:19.000Z","updated":"2020-05-17T08:13:56.299Z","comments":true,"path":"default/LLDB调试/","link":"","permalink":"https://kysonyangs.github.io/default/LLDB调试/","excerpt":"LLDB是XCode内置的为我们开发者提供的调试工具，它与LLVM编译器一起，存在于主窗口底部的控制台中，能够带给我们更丰富的流程控制和数据检测的调试功能。在调试过程中熟练使用LLDB，可以让你debug事半功倍。 LLDB可以带来以下体验： 允许你在程序运行的特定时暂停它 查看变量的值 执行自定的指令 按照你所认为合适的步骤来操作程序的进展 More","text":"LLDB是XCode内置的为我们开发者提供的调试工具，它与LLVM编译器一起，存在于主窗口底部的控制台中，能够带给我们更丰富的流程控制和数据检测的调试功能。在调试过程中熟练使用LLDB，可以让你debug事半功倍。 LLDB可以带来以下体验： 允许你在程序运行的特定时暂停它 查看变量的值 执行自定的指令 按照你所认为合适的步骤来操作程序的进展 More 常用基本命令expr可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。如图设置断点，然后运行程序。程序中断后输入下面的命令： bt打印调用堆栈，加all可打印所有thread的堆栈 打印打印变量的值可以使用print命令，print命令的简化方式有prin pri p，幸运的是p被lldb实现为特指print。该命令如果打印的是简单类型，则会列出简单类型的类型和值。如果是对象，还会打印出对象指针地址，如下所示：123456789101112(lldb) print a(NSInteger) $0 = 0(lldb) print b(NSInteger) $1 = 0(lldb) print str(NSString *) $2 = 0x0000000100001048 @&quot;abc&quot;(lldb) print url(NSURL *) $3 = 0x0000000100206cc0 @&quot;abc&quot; 在输出结果中我们还能看到类似于$0,$1这样的符号，我们可以将其看作是指向对象的一个引用，我们在控制面板中可以直接使用这个符号来操作对应的对象，这些东西存在于LLDB的全名空间中，目的是为了辅助调试。如下所示：1234(lldb) exp $0 = 100(NSInteger) $9 = 100(lldb) p a(NSInteger) $10 = 100 另外$后面的数值是递增的，每打印一个与对象相关的命令，这个值都会加1。 上面的print命令会打印出对象的很多信息，如果我们只想查看对象的值的信息，则可以使用po(print object的缩写)命令，如下所示：12(lldb) po strabc 当然，po命令是”exp -O —“命令的别名，使用”exp -O —”能达到同样的效果。 对于简单类型，我们还可以为其指定不同的打印格式，其命令格式是print/，如下所示：12(lldb) p/x a(NSInteger) $13 = 0x0000000000000064 格式的完整清单可以参考Output Formats。 expression在开发中，我们经常会遇到这样一种情况：我们设置一个视图的背景颜色，运行后发现颜色不好看。嗯，好吧，在代码里面修改一下，再编译运行一下，嗯，还是不好看，然后再修改吧～～这样无形中浪费了我们大把的时间。在这种情况下，expression命令强大的功能就能体现出来了，它不仅会改变调试器中的值，还改变了程序中的实际值。我们先来看看实际效果，如下所示：12345(lldb) exp a = 10(NSInteger) $0 = 10(lldb) exp b = 100(NSInteger) $1 = 1002015-01-25 14:00:41.313 test[18064:71466] a + b = 110, abc expression命令的功能不仅于此，正如上面的po命令，其实际也是”expression -O —“命令的别名。更详细使用可以参考Evaluating Expressions。","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/tags/Xcode/"}]},{"title":"YYModel使用","slug":"YYModel使用","date":"2018-04-25T07:27:25.000Z","updated":"2020-05-17T08:12:32.792Z","comments":true,"path":"default/YYModel使用/","link":"","permalink":"https://kysonyangs.github.io/default/YYModel使用/","excerpt":"简单的 Model 与 JSON 相互转换12345678910111213// JSON:&#123; &quot;uid&quot;:123456, &quot;name&quot;:&quot;Harry&quot;, &quot;created&quot;:&quot;1965-07-31T00:00:00+0000&quot;&#125;// Model:@interface User : NSObject@property UInt64 uid;@property NSString *name;@property NSDate *created;@end JSON Model12345// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:User *user = [User yy_modelWithJSON:json];// 将 Model 转换为 JSON 对象:NSDictionary *json = [user yy_modelToJSONObject];","text":"简单的 Model 与 JSON 相互转换12345678910111213// JSON:&#123; &quot;uid&quot;:123456, &quot;name&quot;:&quot;Harry&quot;, &quot;created&quot;:&quot;1965-07-31T00:00:00+0000&quot;&#125;// Model:@interface User : NSObject@property UInt64 uid;@property NSString *name;@property NSDate *created;@end JSON Model12345// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:User *user = [User yy_modelWithJSON:json];// 将 Model 转换为 JSON 对象:NSDictionary *json = [user yy_modelToJSONObject]; 当 JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。 JSON/Dictionary Model NSString NSNumber, NSURL, SEL, Class NSNumber NSString NSString/NSNumber C number (BOOL, int, float, NSUInteger, UInt64, …) NaN and Inf will be ignored NSString NSDate parsed with these formats: yyyy-MM-dd yyyy-MM-dd HH:mm:ss yyyy-MM-dd’T’HH:mm:ss yyyy-MM-dd’T’HH:mm:ssZ EEE MMM dd HH:mm:ss Z yyyy NSDate NSString formatted with ISO8601: “YYYY-MM-dd’T’HH:mm:ssZ” NSValue struct (CGRect,CGSize,…) NSNull nil, 0 “no”, “false”, … @(NO), 0 “yes”, “true”, … @(YES), 1 Model 属性名和 JSON 中的 Key 不相同1234567891011121314151617181920212223242526// JSON:&#123; &quot;n&quot;:&quot;Harry Pottery&quot;, &quot;p&quot;: 256, &quot;ext&quot; : &#123; &quot;desc&quot; : &quot;A book written by J.K.Rowing.&quot; &#125;, &quot;ID&quot; : 100010&#125;// Model:@interface Book : NSObject@property NSString *name;@property NSInteger page;@property NSString *desc;@property NSString *bookID;@end@implementation Book//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@&quot;name&quot; : @&quot;n&quot;, @&quot;page&quot; : @&quot;p&quot;, @&quot;desc&quot; : @&quot;ext.desc&quot;, @&quot;bookID&quot; : @[@&quot;id&quot;,@&quot;ID&quot;,@&quot;book_id&quot;]&#125;;&#125;@end 你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。 在 json-&gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。 在 model-&gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。 Model 包含其他的 Model12345678910111213141516171819202122232425// JSON&#123; &quot;author&quot;:&#123; &quot;name&quot;:&quot;J.K.Rowling&quot;, &quot;birthday&quot;:&quot;1965-07-31T00:00:00+0000&quot; &#125;, &quot;name&quot;:&quot;Harry Potter&quot;, &quot;pages&quot;:256&#125;// Model: 什么都不用做，转换会自动完成@interface Author : NSObject@property NSString *name;@property NSDate *birthday;@end@implementation Author@end@interface Book : NSObject@property NSString *name;@property NSUInteger pages;@property Author *author; //Book 包含 Author 属性@end@implementation Book@end 容器类属性12345678910111213141516@class Shadow, Border, Attachment;@interface Attributes@property NSString *name;@property NSArray *shadows; //Array&lt;Shadow&gt;@property NSSet *borders; //Set&lt;Border&gt;@property NSMutableDictionary *attachments; //Dict&lt;NSString,Attachment&gt;@end@implementation Attributes// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@&quot;shadows&quot; : [Shadow class], @&quot;borders&quot; : Border.class, @&quot;attachments&quot; : @&quot;Attachment&quot; &#125;;&#125;@end 在实际使用过过程中，[Shadow class]， Border.class， @&quot;Attachment&quot; 没有明显的区别。 黑名单与白名单123456789101112131415@interface User@property NSString *name;@property NSUInteger age;@end@implementation Attributes// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性+ (NSArray *)modelPropertyBlacklist &#123; return @[@&quot;test1&quot;, @&quot;test2&quot;];&#125;// 如果实现了该方法，则处理过程中不会处理该列表外的属性。+ (NSArray *)modelPropertyWhitelist &#123; return @[@&quot;name&quot;];&#125;@end 数据校验与自定义转换实际这个分类的目的比较简单和明确。 就是对判断是否为时间戳，然后对时间戳进行处理，调用 _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; 获取时间。 1234567891011121314151617181920212223242526272829303132// JSON:&#123; &quot;name&quot;:&quot;Harry&quot;, &quot;timestamp&quot; : 1445534567 //时间戳&#125;// Model:@interface User@property NSString *name;@property NSDate *createdAt;@end@implementation User// 当 JSON 转为 Model 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; NSNumber *timestamp = dic[@&quot;timestamp&quot;]; if (![timestamp isKindOfClass:[NSNumber class]]) return NO; _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; return YES;&#125;// 当 Model 转为 JSON 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123; if (!_createdAt) return NO; dic[@&quot;timestamp&quot;] = @(n.timeIntervalSince1970); return YES;&#125;@end Coding/Copying/hash/equal/description以下方法都是YYModel的简单封装，实际使用过程和系统方法区别不大。对其感兴趣的可以点进方法内部查看。 123456789101112131415161718192021222324252627@interface YYShadow :NSObject &lt;NSCoding, NSCopying&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) CGSize size;@end@implementation YYShadow// 直接添加以下代码即可自动完成- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder];&#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder];&#125;- (id)copyWithZone:(NSZone *)zone &#123; return [self yy_modelCopy];&#125;- (NSUInteger)hash &#123; return [self yy_modelHash];&#125;- (BOOL)isEqual:(id)object &#123; return [self yy_modelIsEqual:object];&#125;- (NSString *)description &#123; return [self yy_modelDescription];&#125;@end","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://kysonyangs.github.io/tags/源码/"}]},{"title":"iPhoneX适配","slug":"iPhoneX+版本适配","date":"2018-01-20T07:12:36.000Z","updated":"2020-05-17T08:14:27.314Z","comments":true,"path":"default/iPhoneX+版本适配/","link":"","permalink":"https://kysonyangs.github.io/default/iPhoneX+版本适配/","excerpt":"","text":"iPhoneX适配push 和 pop时，页面偏移在有 UIScrollView 或 UIScrollView 子类（如tableView）的控制器中，push 到第二个几面和 pop 回去，scrollView 都会往下偏移。 在 AppDelegate 中用 UISCrollView 的 UIAppearance 修改1234// AppDelegate 进行全局设置 不然iOS 11 push时界面会有个下滑的效果，pop回去会有个上划的效果if (@available(iOS 11.0, *)) &#123; [[UIScrollView appearance] setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentNever];&#125; TabBar 在 push 的时候会向上弹，然后还会有黑块自定义 navigationController 重写的 push 方法里面修改 tabbar 的 frame12345678910// 修改tabBar的frame 不然iPhone X push的时候tabBar上会向上弹- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; if (self.viewControllers.count &gt; 0) &#123; viewController.hidesBottomBarWhenPushed = YES; &#125; [super pushViewController:viewController animated:animated]; CGRect frame = self.tabBarController.tabBar.frame; frame.origin.y = [UIScreen mainScreen].bounds.size.height - frame.size.height; self.tabBarController.tabBar.frame = frame;&#125; TableView 添加 MJFooter 时，底部显示 MJFooter修改 MJFooter 偏移位置1self.tableView.mj_footer.ignoredScrollViewContentInsetBottom = kSalfBottomSpace;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"CocoaPods/Carthage","slug":"CocoaPods-Carthage","date":"2017-12-05T07:21:48.000Z","updated":"2020-05-17T08:15:33.430Z","comments":true,"path":"default/CocoaPods-Carthage/","link":"","permalink":"https://kysonyangs.github.io/default/CocoaPods-Carthage/","excerpt":"CocoaPods (默认)自动建立和更新一个 Xcode workspace，用来管理你的项目和所有依赖。Carthage 使用 xcodebuild 来编译出二进制库，剩下的集成工作完全交给开发人员。 CocoaPods 使用起来方便， Carthage 更加灵活并且对现有项目没有太多的侵略性。 CocoaPods 希望建立一个生态系统，可以更加方便的发现和集成第三方代码库。 Carthage 希望变成一个去中心化的依赖管理系统，不提供中心化的项目列表，减少维护成本和单点失败的概率。不过这样给开发人员寻找项目带来不便。 CocoaPods 的项目需要配置 podspec 文件，包含了项目和第三方库的信息。 Carthage 并不使用类似的配置文件，第三方库的依赖关系是通过 Xcode 项目来配置的。","text":"CocoaPods (默认)自动建立和更新一个 Xcode workspace，用来管理你的项目和所有依赖。Carthage 使用 xcodebuild 来编译出二进制库，剩下的集成工作完全交给开发人员。 CocoaPods 使用起来方便， Carthage 更加灵活并且对现有项目没有太多的侵略性。 CocoaPods 希望建立一个生态系统，可以更加方便的发现和集成第三方代码库。 Carthage 希望变成一个去中心化的依赖管理系统，不提供中心化的项目列表，减少维护成本和单点失败的概率。不过这样给开发人员寻找项目带来不便。 CocoaPods 的项目需要配置 podspec 文件，包含了项目和第三方库的信息。 Carthage 并不使用类似的配置文件，第三方库的依赖关系是通过 Xcode 项目来配置的。 CocoaPods 安装与使用安装 安装需要用到 Ruby，但是 Mac 自带了 Ruby，如果嫌弃版本过低，可以更新一下 ruby。 a. 安装 RVM，curl -L https://get.rvm.io | bash -s stable b. 查看 rvm 版本，rvm -v c. rvm 安装 rubya. 列出已知的ruby版本，`rvm list known` b. 选择版本安装，`rvm install 2.0.0` c. 查询已经安装的 ruby，`rvm list` d. 卸载一个已安装版本，`rvm remove 1.9.2` d. 设置默认 ruby 版本，rvm 2.0.0 --default 安装 CocoaPods1sudo gem install cocoapods 然后你会发现无比的慢，但是我们可以通过换源来提高那么一点速度a. gem sources -l 查看现有的源b. gem sources --remove https://rubygems.org/ 删除原来的源c. gem sources -a http://ruby.taobao.org/ 更换为淘宝的源 使用example: 使用CocoaPods 导入 AFNetworking 库 在项目(CocosPodsDemo)地址下，新建一个文件 podfile, 基本使用如下： 12345678source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &quot;CocosPodsDemo&quot; dopod &apos;AFNetworking&apos;end 项目路径下使用 pod install 完成后打开 CocosPodsDemo.xcworkspace 完成项目开发. 更多使用方法自行百度 Carthage 安装与使用安装12brew updatebrew install carthage 注意 如果报错提示需要安装 Xcode 插件，xcode-select --install 查看版本1carthage version 使用example: 使用 Carthage 导入 AFNetworking 库 在项目(CarthageDemo)地址下，新建一个文件 Cartfile, 基本使用如下： 1github &quot;AFNetworking/AFNetworking&quot; ~&gt; 3.0 在项目(CarthageDemo)地址下，执行命令 1carthage update --platform iOS 打开 Carthage 查看生成的文件目录 1open Carthage 配置项目 a. 打开项目，点击 Target -&gt; Build Phases -&gt; Link Library with Libraries 选择 Carthage/Build 目录中的 framework b. 添加编译的脚本（该脚本文件保证在提交归档时会对相关文件和dSYMs进行复制），点击 Target -&gt; Build Phases -&gt; + -&gt; New Run Script Phase c. 添加脚本，/usr/local/bin/carthage copy-frameworks d. 添加 &quot;Input Files&quot; $(SRCROOT)/Carthage/Build/iOS/AFNetworking.framework","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://kysonyangs.github.io/tags/CocoaPods/"}]},{"title":"Alfred使用","slug":"Alfred使用","date":"2017-10-16T07:22:32.000Z","updated":"2020-05-17T08:15:56.590Z","comments":true,"path":"default/Alfred使用/","link":"","permalink":"https://kysonyangs.github.io/default/Alfred使用/","excerpt":"设置Alfred 启动后，点击帽子图标，选择 Preferences... 打开设置面板","text":"设置Alfred 启动后，点击帽子图标，选择 Preferences... 打开设置面板 General: 通用设置 Startup: 是否在系统启动时自启动Alfred。神器，默认勾上，不解释。 Alfred Hotkey: 调出Alfred操作界面的热键。默认为 Alt + 空格。 Where are you: 你在哪个国家。Alfred内置了常用网站搜索功能，在搜索时打开对应国家的网站。 Features: 特性界面 Alfred几乎所有搜索功能都在这个界面设置。免费用户(没有购买Powerpack开启Workflows)重点关注的地方了。 Features包含的所有功能，本文不打算讲解所有的功能，只讲解最常用的。如：Default Results、File Search、Web Search、Calculator等。 Default Results: 默认结果 Essentials: 可设置搜索“应用程序”、“联系人”、“设置”、“Safari书签”。 Extras: 可设置搜索“文件夹”、“文本文件”、“压缩文件”、“个人文档目录”、“图片”、“AppleScript”等其他文件。 Unintelligent: Search all file types 搜索所有文件类型。若勾选此项不但影响巡查速度，还混淆默认搜索结果。Alfred建议用户使用 Find+空格+文件名 来查询文件或文件夹；使用 Open+空格+文件名 也可以。 Search Scope: 设置Alfred查询时 会搜索的文件夹范围，可自己添加和删除。 Fallbacks: 若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。 默认反馈结果为 Google 、Amazon、Wikipedia 网页搜索。 可以自己添加搜索引擎。 Web Search: 网页搜索 Keyword 为 Alfred命令/关键字；DisplayText 为此搜索功能的标题；Custom 有图标表示这个为用户自定义；Enabled 为是否启用。 Alfred网站搜索的设置，这是本人使用最频繁的功能。在图中可看到Alfred默认设置了很多搜索网站，但几乎都是国外网站，因为天朝特色，很多都是我们用不上，因此需要添加自定义的搜索设置。 点击右下角的 Add Custom Search。 根据下面的示意图在弹出界面中输入对应信息，其中网站图标可忽略，然后保存即可。 比如我自定义的百度搜索，信息如下： Search URL: https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;ch=&amp;tn=baiduerr&amp;bar=&amp;wd={query} Title: baidu。 Keyword: bd。 Validation: 为热爱祖国，此项可随意。 Alfred 输入 bd+空格+查询内容, 回车即自动打开百度进行搜索。 只要在对应的网站上搜索一次，记下当时的网址，并把具体的搜索内容改为 {query} 就可以找到我们自定义搜索设置中所需要的 Search URL 信息了。 Calculator: 计算器 直接在Alfred 输入 1+1 可以立即得到结果 输入 = 来进行复杂运算，Alfred支持很多高级的数学函数。eg: =sin(1) Clipboard: 剪切板 开启Alfred的剪切板功能。 查看Alfred剪切板历史记录。默认热键为 Command + Alt + C。 清空Alfred剪切板。在Alfred操作界面中输入 clear。 Advanced: 高级设置 配置同步 点击 Set sync folder... 设置Alfred配置导出的目录。点击 Reveal in Finder 查看Alfred配置所在的目录。 只要将Alfred配置导出的目录设置为 Dropbox 同步目录，就可以实现云同步。 Workflow: 神器啊, 这里收藏自己使用的Workflow。Workflow ListWorkflow ListWorkflow packal Github: 更便捷地使用Github Github Search: 在Alfred上列出Github的搜索结果 使用：github 要搜索的库名 eg: github YYKit 对搜索结果按回车，打开Github网页。 对搜索结果按Cmd + c，复制链接。 按住Cmd再点击搜索结果，打开pull请求。 按住Alt再点击搜索结果，打开issues页面。 Stackoverflow: Stackoverflow 的查询结果 使用：.so 要查询的问题 eg: .so ios Hash: 哈希工具，对字符串和文件进行MD5、SHA1等常用哈希，另外支持Base64等。 对字符串进行SHA1：sha1 kyson Copy Path: 将Finder中文件的路径复制到剪切板中。(该网址下包含众多workflow) 点击 workflow -&gt; copy path -&gt; hotkey 修改此Workflow的热键为 Ctrl + Command + C。 在Finder中选中文件后执行此热键即可复制该文件的路径。 CodeVar: 生成可用的代码变量 小驼峰命名法: xt 大驼峰命名法: dt 下划线命名法: xh 常量命名法: cl 有道词典: 有道词典 并同步到单词本 改变默认终端为 iTerm 首先将 Terminal 的 Application 改变为 Custom： 然后在输入栏中输入：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657on write_to_file(this_data, target_file, append_data) try set the target_file to the target_file as string set the open_target_file to open for access file target_file with write permission if append_data is false then set eof of the open_target_file to 0 write this_data to the open_target_file starting at eof close access the open_target_file return true on error try close access file target_file end try return false end tryend write_to_fileon alfred_script(q) -- Write the command to run to a file. This is done because Applescript quoting is impossible to get right, esp. for backslashes. set tmp_dir to path to temporary items as string from user domain set applescript_alfred_file to tmp_dir &amp; &quot;alfredscript&quot; set alfred_file to POSIX path of applescript_alfred_file write_to_file(q &amp; return, applescript_alfred_file, false) -- Create this file, which prevents iTerm2 from restoring a saved window arrangement. do shell script &quot;touch ~/Library/Application&apos; Support/iTerm/quiet&apos;&quot; -- Test cases: -- 1. iTerm2 running, has windows open. Should open a new window for Alfred command. -- 2. iTerm2 running, no windows open. Should open a new window for Alfred command. -- 3. iTerm2 not running, set to restores arrangement. Should not restore arrangement but open a new window for the Afred command. -- 4. iTerm2 not running. No windows to restore. Should open a single window for the Alfred command. -- 5. iTerm2 not running. Has windows to restore. Restores windows and then opens a new window for the Alfred command. -- Compose a script. This is necessary because compiling in a &apos;tell application&apos; command causes the app to be launched, which would happen prior to the creation of the quiet file. set theScript to &quot;tell application \\&quot;iTerm2.app\\&quot; if (exists current window) then tell current window to create tab with default profile tell current session of current window write contents of file \\&quot;&quot; &amp; alfred_file &amp; &quot;\\&quot; end tell else create window with default profile tell current session of current window write contents of file \\&quot;&quot; &amp; alfred_file &amp; &quot;\\&quot; end tell end if activateend tell&quot; -- Invoke the script. run script theScript -- Clean up-- do shell script &quot;rm -f ~/Library/Application&apos; Support/iTerm/quiet&apos; /tmp/alfredscript&quot;end alfred_script","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://kysonyangs.github.io/tags/Mac/"}]},{"title":"iOS MVC、MVP、MVVM","slug":"iOS设计模式","date":"2017-10-16T07:22:32.000Z","updated":"2020-05-16T05:34:17.934Z","comments":true,"path":"default/iOS设计模式/","link":"","permalink":"https://kysonyangs.github.io/default/iOS设计模式/","excerpt":"MVC Model：负责封装数据，存储和处理数据运算等工作 View：负责数据展示、监听用户触摸等操作 Controller：负责业务逻辑、事件响应、数据加工等工作 用户操作View，在Controller层完成业务逻辑处理，更新Model层，将数据显示在View层。 View把控制权交给Controller层，自己不执行业务逻辑；Controller层执行业务逻辑并且操作Model层，但不会直接操作View层；View和Model层的同步消息是通过观察者模式进行，而同步操作是由View层自己请求Model层的数据，然后对视图进行更新，观察者模式可以做到多视图同时更新。 优点：View、Model可以重复利用 缺点：导致Controller臃肿，代码特别多，视图一复杂起来，代码量过长，不好维护；写在Controller里View的代码无法复用；","text":"MVC Model：负责封装数据，存储和处理数据运算等工作 View：负责数据展示、监听用户触摸等操作 Controller：负责业务逻辑、事件响应、数据加工等工作 用户操作View，在Controller层完成业务逻辑处理，更新Model层，将数据显示在View层。 View把控制权交给Controller层，自己不执行业务逻辑；Controller层执行业务逻辑并且操作Model层，但不会直接操作View层；View和Model层的同步消息是通过观察者模式进行，而同步操作是由View层自己请求Model层的数据，然后对视图进行更新，观察者模式可以做到多视图同时更新。 优点：View、Model可以重复利用 缺点：导致Controller臃肿，代码特别多，视图一复杂起来，代码量过长，不好维护；写在Controller里View的代码无法复用； MVPMVP模式是MVC模式的一个演化版本 Model：与MVC中的model没有太大的区别。主要提供数据的存储功能，一般都是用来封装网络获取的json数据的集合。Presenter通过调用Model进行对象交互。 View：这个View可以是viewcontroller、view等控件。View负责界面展示和布局管理，向Presenter暴露视图更新和数据获取的接口 Presenter：作为model和view的中间人，从model层获取数据之后传给view，使得View和model解耦。Present中间层负责UI改变及时更新数据；数据的改变及时的更新UI 用户操作View，在Presenter层完成业务逻辑处理，更新Model层，通过Presenter将数据显示在View层，完全隔断Model和View之间的通信。 通过接口的方式来连接view和presenter层，这样导致的问题是，如果页面过于复杂，我们的接口就会很多，为了更好的处理类似的问题，需要定义一些基类接口，把一些公共的逻辑，比如网络请求，toast，提示框等放在里面。因为MVP不依赖Model，所以可以更好的进行组件化，把它从特定的场景中脱离出来，做到高度复用。MVP中的Presenter更多的作为框架的控制者，承担了大量的逻辑操作。 Controller其实将view和viewController传递给了P层, 这样P层其实就拥有了控制器的权利, 完全可以行使控制器的职责. Controller又持有Presenter, 那么它只需要调用P层暴露出的接口, 就完全可以完成整个业务逻辑和页面展示 关于C端和P端的循环引用的问题, 直接用weak关键字就可以解决了 优点： 模型与视图完全分离，我们可以修改视图而不影响模型 可以更高效的使用模型，因为所有的交互都在Presenter内部 缺点： 由于对视图的渲染都在Presenter中，所以视图和Persenter的交互会过于频繁。 MVVMMVVM和MVP的最大区别是采用了双向绑定机制，View的变动，自动反映在ViewModel上。 M：Model: 作为数据的容器。 V：View、部分ViewController组成。负责界面的展示以及用户交互的处理。 VM：ViewModel: 负责业务逻辑处理。就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层 View持有ViewModel：在View中通过绑定的方式关联UI元素和ViewModel的属性，UI元素的属性变化和ViewMode的数据属性进行双向影响。 ViewModel持有Model：Model为ViewModel提供数据支持，同时ViewModel的数据属性变化也会影响Model上，用于数据提交等。 Model和ViewModel的功能区别在于，ViewModel是View提供数据支持的，其结构和View保持一致。Model来源于业务处理，保持业务数据的基本关联和完整性。 当Model层结束查询或者运算时将结果更新到ViewModel层，ViewModel层因为存在和View的绑定，使得UI层得到通知更新，体现了数据驱动界面的思想。 优点： 方便测试 便于代码的移植。 兼容MVC。 缺点： 类会增多，ViewModel会越来越庞大，调用复杂度增加。","categories":[],"tags":[]},{"title":"方法替换","slug":"iOS 方法替换","date":"2017-10-05T07:12:36.000Z","updated":"2020-05-17T08:15:03.241Z","comments":true,"path":"default/iOS 方法替换/","link":"","permalink":"https://kysonyangs.github.io/default/iOS 方法替换/","excerpt":"","text":"AspectsAspects 是一个基于 Method Swizzle 的函数替换的第三方库，支持在方法执行前（AspectPositionBefore）/执行后（AspectPositionAfter）或替代原方法执行（AspectPositionInstead） 使用 HOOK一个类的所有实例的指定方法 12345678910111213/// 为一个指定的类的某个方法执行前/替换/后,添加一段代码块.对这个类的所有对象都会起作用.////// @param block 方法被添加钩子时,Aspectes会拷贝方法的签名信息./// 第一个参数将会是 `id&lt;AspectInfo&gt;`,余下的参数是此被调用的方法的参数./// 这些参数是可选的,并将被用于传递给block代码块对应位置的参数./// 你甚至使用一个没有任何参数或只有一个`id&lt;AspectInfo&gt;`参数的block代码块.////// @注意 不支持给静态方法添加钩子./// @return 返回一个唯一值,用于取消此钩子.+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; HOOK一个类实例的指定方法 12345/// 为一个指定的对象的某个方法执行前/替换/后,添加一段代码块.只作用于当前对象.- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; Example 123456789101112131415161718192021222324252627+(void)Aspect &#123; // 在类UIViewController所有的实例执行viewWillAppear:方法完毕后做一些事情 [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; info) &#123; NSString *className = NSStringFromClass([[info instance] class]); NSLog(@&quot;%@&quot;, className); &#125; error:NULL]; // 在实例myVc执行viewWillAppear:方法完毕后做一些事情 UIViewController* myVc = [[UIViewController alloc] init]; [myVc aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; info) &#123; id instance = info.instance; //调用的实例对象 id invocation = info.originalInvocation; //原始的方法 id arguments = info.arguments; //参数 [invocation invoke]; //原始的方法，再次调用 &#125; error:NULL]; // HOOK类方法 Class metalClass = objc_getMetaClass(NSStringFromClass(UIViewController.class).UTF8String); [metalClass aspect_hookSelector:@selector(ClassMethod) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; info) &#123; NSLog(@&quot;%@&quot;, HOOK类方法); &#125; error:NULL];&#125;","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kysonyangs.github.io/tags/Runtime/"}]},{"title":"Swift技巧","slug":"Swift技巧","date":"2017-10-03T07:33:46.000Z","updated":"2020-05-17T08:12:07.679Z","comments":true,"path":"default/Swift技巧/","link":"","permalink":"https://kysonyangs.github.io/default/Swift技巧/","excerpt":"cell分割线置顶1tableView.separatorInset = UIEdgeInsets.zero Swift中lazy作惰性求值函数式编程中有惰性求值的概念，即一次计算在真正需要时才执行，尽可能推迟求解表达式。假如我们有一个数组，我们对每个元素作 element*2 的 map 操作，获取其中某一个元素，我们会如下代码处理:123let array = [1, 2, 4, 5, 3, 7]let element = array.map&#123; $0 * 2 &#125;[3]print(element) 这个计算对每个元素都*2，最后我们只取了其中一个值，也就是说在这个场景中另外5次计算是无意义的。 这时使用惰性求值就可以避免这算浪费。我们知道Swift中有个lazy关键字，如果用来修饰属性之类的，可以实现属性的惰性求值。同样，Swift扩展了LazySequenceProtocol协议，提供了一个lazy属性，用于处理map，filter等操作的惰性求值，定义如下代码所示：1234extension LazySequenceProtocol &#123; /// Identical to `self`. public var lazy: Self &#123; get &#125;&#125; 所以，上面这个例子如果要实现惰性求值，则可以如下代码处理：123let array = [1, 2, 4, 5, 3, 7]let element = array.lazy.map&#123; $0 * 2 &#125;[3]print(element)","text":"cell分割线置顶1tableView.separatorInset = UIEdgeInsets.zero Swift中lazy作惰性求值函数式编程中有惰性求值的概念，即一次计算在真正需要时才执行，尽可能推迟求解表达式。假如我们有一个数组，我们对每个元素作 element*2 的 map 操作，获取其中某一个元素，我们会如下代码处理:123let array = [1, 2, 4, 5, 3, 7]let element = array.map&#123; $0 * 2 &#125;[3]print(element) 这个计算对每个元素都*2，最后我们只取了其中一个值，也就是说在这个场景中另外5次计算是无意义的。 这时使用惰性求值就可以避免这算浪费。我们知道Swift中有个lazy关键字，如果用来修饰属性之类的，可以实现属性的惰性求值。同样，Swift扩展了LazySequenceProtocol协议，提供了一个lazy属性，用于处理map，filter等操作的惰性求值，定义如下代码所示：1234extension LazySequenceProtocol &#123; /// Identical to `self`. public var lazy: Self &#123; get &#125;&#125; 所以，上面这个例子如果要实现惰性求值，则可以如下代码处理：123let array = [1, 2, 4, 5, 3, 7]let element = array.lazy.map&#123; $0 * 2 &#125;[3]print(element) Swift的stride操作创建一个一定步长的数组, Swift提供了一个便捷函数：stride，可以在某个区间内创建一个任意可变步长的序列，这个步长可以是任意值。123let array = stride(from: 0, to: 3, by: 0.3).map &#123; $0&#125; stride有两个变种： stride(from:to:by)，开区间处理，最后一个值严格小于最大值； stride(from:through:by)，闭区间处理，最后一个值小于或等于最大值 static方法与class方法的区别static和class这两个关键字都可以修饰类的方法，以表明这个方法是一个类方法。不过这两者稍微有一些区别：class修饰的类方法可以被子类重写，而static修饰的类方法则不能。 Swift中的函数值在Swift中，函数是一等公民，即函数也是一种类型，可充当参数、返回值等角色，当然也可以定义函数类型的常量/变量。利用这个特性，在某些场景下可以简化我们的代码，如下代码所示：12345let setInt: (Int, String) -&gt; Void = UserDefaults.standard.setlet getInt: (String) -&gt; Int = UserDefaults.standard.integersetInt(10, &quot;key&quot;)print(getInt(&quot;key&quot;)) Array.contains操作Swift中判断一个Array中是否包含某个元素，我们可以使用contains方法，如下代码所示：12let array = [2, 5, 6, 7, 19, 40]array.contains(10) // false 不过这个方法要求数组中的元素类型实现了Equatable协议，否则无法使用，如下代码所示：1234567enum Animal &#123; case dog case cat(Int)&#125;let animals: [Animal] = [.dog, .dog]let hasCat = animals.contains(.cat(100)) // 编译器错误 还好Swift为我们提供了另一个contains方法，可以自定义谓词条件作为判断依据，其定义如下：1public func contains(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool 这个方法会查看数组是否包含满足给定的谓词条件的元素。可以看到这个方法是一个高阶函数，其参数是一个尾随闭包，在闭包内我们可以根据实际需要来实现我们自己的判断。所以上面的判断可以如下代码实现：1234567891011121314enum Animal &#123; case dog case cat(Int)&#125;let animals: [Animal] = [.dog, .dog]let hasCat = animals.contains &#123; animal in if case .cat = animal &#123; return true &#125; else &#123; return false &#125;&#125; 当然，对于元素类型实现了Equatable协议的数组，也可以使用这个方法。可以自定义谓词条件，查看数组是否有满足此条件的元素，如下代码所示：12345let array = [2, 5, 6, 7, 19, 40]array.contains &#123; (element) -&gt; Bool in element % 7 == 0&#125; filter与flatMap过滤nil使用高阶函数过滤一个数组中的nil可以有两种方法：filter和flatMap。filter方法如下代码所示：1234567let array: [Int?] = [1, 2, 3, 5, nil, 9]let result = array.filter &#123; element in element != nil&#125;print(result) // [Optional(1), Optional(2), Optional(3), Optional(5), Optional(9)] flatMap方法如下代码所示：123456let array: [Int?] = [1, 2, 3, 5, nil, 9]let result: [Int] = array.flatMap &#123; $0&#125;print(result) // [1, 2, 3, 5, 9] 从输出可以看出，filter返回的仍然是一个Optional数组，而flatMap返回的是一个非Optional数组。一般推荐使用第二种方法。 Extension-Selector在Swift中，我们可以使用#selector设置target-action模式中的action操作，如下代码所示：1button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside) 如果你有代码洁癖，想把#selector集中起来管理，则可以定义一个结构体，来统一归集这样的代码，如下图所示。这样看着是不是会更整洁一些？1234fileprivate struct Action &#123; static let buttonTapped = #selector(ViewController.buttonTapped)&#125;button.addTarget(self, action: Action.buttonTapped, for: .touchUpInside) 不过，还有种更好的方式，就是直接扩展Selector结构体，如下代码所示，这样可以在使用时直接用.buttonTapped这种方式来引用，就像我们使用.red这样的UIColor属性一样简洁。1234extension Selector &#123; static let buttonTapped = #selector(ViewController.buttonTapped)&#125;button.addTarget(self, action: .buttonTapped, for: .touchUpInside) typealias泛型闭包在 Swift 中我们可以用 typealias 来为已经存在的类型重新定义名字的,通过命名可以使代码变得更加清晰。当然也可以给闭包类型定义一个新名字，给带有泛型的闭包重新定义名字的方式如下代码所示：123456789typealias Block&lt;U&gt; = (U, U) -&gt; Boolfunc compare&lt;T: Comparable&gt;(number1: T, number2: T, algorithm: Block&lt;T&gt;) -&gt; Bool &#123; return algorithm(number1, number2)&#125;compare(number1: 10, number2: 20) &#123; $0 &lt; $1&#125; Swift自定义操作符在Swift中，自定义操作符就是简单的二步：首先在全局使用operator关键字来声明操作符，同时用prefix、infix或postfix来声明操作符的位置；然后在所需要的类/结构体中实现操作符。如下代码所示：123456789101112postfix operator &gt;?postfix operator &gt;!extension MIType &#123; public static postfix func &gt;?(type: MIType) -&gt; MIType &#123; return MIType(&quot;Optional&lt;\\(type.name)&gt;&quot;) &#125; public static postfix func &gt;!(type: MIType) -&gt; MIType &#123; return MIType(&quot;ImplicitlyUnwrappedOptional&lt;\\(type.name)&gt;&quot;) &#125;&#125; 自定义操作符需要以两类字符开头： ASCII字符中的 /, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?, ~ Unicode 中的 Mathematical Operators, Miscellaneous Symbols和Dingbats Unicode blocks这些字符中的字符 然后后面允许使用组合的Unicode字符。如下代码是以一个Miscellaneous Symbols开头的实现向量加法的操作符。1234567891011121314151617181920infix operator ★+struct Vector2D &#123; var x: CGFloat var y: CGFloat&#125;extension Vector2D &#123; static func ★+ (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125;let vector1 = Vector2D(x: 10, y: 20)let vector2 = Vector2D(x: 30, y: 10)let vector = vector1 ★+ vector2vector.x // 40.0vector.y // 30.0 自定义操作符中的.在自定义操作符时，可以以dot(.)开头，这种情况下，操作符后面还可以包含其它的dot(.)，如下代码所示：1234567891011121314151617181920infix operator .+.struct Vector2D &#123; var x: CGFloat var y: CGFloat&#125;extension Vector2D &#123; static func .+.(left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125;let vector1 = Vector2D(x: 10, y: 20)let vector2 = Vector2D(x: 30, y: 10)let vector = vector1 .+. vector2vector.xvector.y 但如果操作符不是以dot开头，则后面不能再包含dot，如operator +.+这个声明会被看成是”+”操作符后面跟了个”.+”操作符。编译器会给出如下错误提示：1infix operator +.+ // error: operator with postfix spacing cannot start a subexpression Swift中操作符优先级Swift 3中改进了操作符的优先级及结合性的声明方式。在Swift 3之前，是使用magic numbers(魔数)的方式来声明操作符的优先级，如下代码所示：1234infix operator &lt;~ &#123; associativity left precedence 125&#125; magic numbers总归是一个不好的东西，所以Swift 3改用precedence groups(优先级组)的方式来声明操作符的优先级，如下代码所示：1234567precedencegroup Equivalence &#123; associativity: left higherThan: LogicalConjunctionPrecedence lowerThan: ComparisonPrecedence&#125;infix operator ~ : Equivalence 系统为我们提供了一些默认的precedence groups，如下代码所示：12345678910111213141516171819202122232425262728293031323334353637383940414243precedencegroup AssignmentPrecedence &#123; assignment: true associativity: right&#125;precedencegroup TernaryPrecedence &#123; associativity: right higherThan: AssignmentPrecedence&#125;precedencegroup DefaultPrecedence &#123; higherThan: TernaryPrecedence&#125;precedencegroup LogicalDisjunctionPrecedence &#123; associativity: left higherThan: TernaryPrecedence&#125;precedencegroup LogicalConjunctionPrecedence &#123; associativity: left higherThan: LogicalDisjunctionPrecedence&#125;precedencegroup ComparisonPrecedence &#123; higherThan: LogicalConjunctionPrecedence&#125;precedencegroup NilCoalescingPrecedence &#123; associativity: right higherThan: ComparisonPrecedence&#125;precedencegroup CastingPrecedence &#123; higherThan: NilCoalescingPrecedence&#125;precedencegroup RangeFormationPrecedence &#123; higherThan: CastingPrecedence&#125;precedencegroup AdditionPrecedence &#123; associativity: left higherThan: RangeFormationPrecedence&#125;precedencegroup MultiplicationPrecedence &#123; associativity: left higherThan: AdditionPrecedence&#125;precedencegroup BitwiseShiftPrecedence &#123; higherThan: MultiplicationPrecedence&#125; wift打印对象的地址在Swift中，我们可以使用 withUnsafePointer(to:_:) 函数来获取一个变量的指针，如下代码所示：123456789101112131415var x = 42var y = 3.14var z = &quot;foo&quot;var obj = NSObject()withUnsafePointer(to: &amp;x) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;y) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;z) &#123;ptr in print(ptr)&#125;withUnsafePointer(to: &amp;obj) &#123;ptr in print(ptr)&#125;// 输出// 0x000000011a145660// 0x000000011a145668// 0x000000011a145670// 0x000000011a145688 withUnsafePointer(to:_:) 将第一个参数转换为指针，然后将这个指针作为参数去调用第二个参数指定的闭包。如果闭包有返回值，它将作为函数的返回值。需要注意的是，�生成的指针的生命周期限定于闭包内部，不能将其指定给外部的变量。 第二种打印变量的指针的方式如下代码所示：12345678910111213141516171819var x = 42var y = 3.14var z = &quot;foo&quot;var obj = NSObject()func printPointer&lt;T&gt;(ptr: UnsafePointer&lt;T&gt;) &#123; print(ptr)&#125;printPointer(ptr: &amp;x)printPointer(ptr: &amp;y)printPointer(ptr: &amp;z)printPointer(ptr: &amp;obj)// 输出// 0x000000011a145660// 0x000000011a145668// 0x000000011a145670// 0x000000011a145688 ArraySlice的用途Swift提供了ArraySlice来执行数组的切片操作。类似于其它语言中的切片(如Python)，ArraySlice对象复用了原始数组的存储结构，而不是新开辟一块内存区域来将数组片断的元素拷贝过来。因此，它能让我们快速高效地对大数组的片段执行操作。如下代码所示：1234567891011121314var array: [Int] = []for i in 0..&lt;1000 &#123; array.append(i)&#125;let slice = array[100..&lt;300]let result = slice.map &#123; $0 * 2&#125;.reduce(0) &#123; $0 + $1&#125;print(result) // 79800 ArraySlice与Array有相同的接口，所以通常可以在切片数组上执行与原始数组相同的操作。注意 ArraySlice会维持对原始数组的一个强引用，而不仅仅是它所表示的片断。这样即使原始数组对象的生命周期结束了，也可能无法释放。所以不建议长期存储ArraySlice对象，仅用于临时操作。 与Array不同的是，ArraySlice起始索引不一定是0，而是取决于其创建方式。一般是采用共享索引的方式，即ArraySlice对象的起始索引就是切片的开始位置，如代码清单8-2-2所示，切片是从100开始，所以slice[100]是OK的，而slice[99]会报越界错误。通常建议使用startIndex和endIndex来取代指定的索引值.","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://kysonyangs.github.io/tags/Swift/"}]},{"title":"导出p12文件","slug":"导出p12文件","date":"2017-06-20T07:12:36.000Z","updated":"2020-05-17T08:16:24.590Z","comments":true,"path":"default/导出p12文件/","link":"","permalink":"https://kysonyangs.github.io/default/导出p12文件/","excerpt":"","text":"为什么要导出.p12文件？当我们用大于等于三个MAC设备开发应用时，想要申请新的证书，如果在我们的证书里，包含了2个发布证书，2个开发证书，可以发现再也申请不了开发证书和发布证书了（一般在我们的证书界面中应该只有一个开发证书，一个发布证书，没必要生成那么多的证书，证书一般在过期之后才会重新添加。） 导出.p12文件我们的每一个证书都可以生成一个.p12文件，这个文件是一个加密的文件，只要知道其密码，就可以供给所有的mac设备使用，使设备不需要在苹果开发者网站重新申请开发和发布证书，就能使用。​​ 注意：一般.p12文件是给与别人使用的，本机必须已经有一个带秘钥的证书才可以生成.p12文件 如果你发现该证书没有秘钥，则删除钥匙串中的该证书，重新下载并双击打开加入到钥匙串即可！​ 打开钥匙串,先选择左侧钥匙串中的登录（不是系统！！！），再点击种类中的证书，选择我们需要的证书，右击，选择“导出“iPhone Distribition/Developer:为.p12文件填一个名字，设置密码 使用描述文件 拿到这两个文件后，依次双击“证书”，“.p12“文件（需要输入密码，密码就是当时生成.p12时设定的密码，），作用是加入钥匙串中，使我们的电脑具备开发的证明，”描述文件“（作用是置于Xcode中，让Xcode知道我们开发的合法性），添加完后就可以使用了。","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/tags/Xcode/"}]},{"title":"Mac终端","slug":"Mac终端","date":"2017-02-10T12:37:52.000Z","updated":"2020-05-17T08:13:51.115Z","comments":true,"path":"default/Mac终端/","link":"","permalink":"https://kysonyangs.github.io/default/Mac终端/","excerpt":"复制粘贴无效解决1234launchctl list | grep com.apple.pboardlaunchctl stop com.apple.pboardlaunchctl start com.apple.pboard","text":"复制粘贴无效解决1234launchctl list | grep com.apple.pboardlaunchctl stop com.apple.pboardlaunchctl start com.apple.pboard macOS Mojave 升级之后 oh-my-zsh 在终端下打开缓慢，清理终端 log 就会变快哦sudo rm -rf /private/var/log/asl/*.asl ​​​​ 解决Alfred每次开机后，都会提示“是否允许访问通讯录”1sudo codesign -f -d -s - /Applications/Alfred\\ 3.app/Contents/Frameworks/Alfred\\ Framework.framework/Versions/A/Alfred\\ Framework 设置别名 首先，你的别名得不存在，在终端输入你想要设置的别名，提示不能找到命令，则别名不存在，我们可以放心使用。 alias可以查看当前已设置的所有的别名 永久化的别名设置123456vim ~/.bash_profile// 在最下面添加你想要设置的别名，比如alias cdg=&quot;cd ~/Desktop/GG&quot;// 然后 wq保存退出，在终端输入source ~/.bash_profile// 现在，你可以使用你设置的别名了 修改终端前面的显示 修改终端的显示成 省略前面的电脑名 终端输入open /etc 找到bashrc-&gt;显示简介-&gt;将只读改成读与写，配置完成后改回去 终端输入sudo vim /etc/bashrc 找到PS1=’\\h:\\W \\u\\$ ‘，将其注释掉（为了备份） 换行添加PS1=’ \\W \\u\\$’，OK！！！","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://kysonyangs.github.io/tags/Mac/"}]},{"title":"Info.plist属性","slug":"Info-plist属性","date":"2017-01-05T12:00:03.000Z","updated":"2020-05-17T08:15:11.080Z","comments":true,"path":"default/Info-plist属性/","link":"","permalink":"https://kysonyangs.github.io/default/Info-plist属性/","excerpt":"","text":"Application does not run in background: 默认 NO， 自从iOS4.0之后，当你在应用程序执行的时候按下Home键，应用程序并不会中断目前的应用，而是放到后台去了。因此希望使用者在按下Home键之后就要退出当前应用的请勾选这个选项。 Localization native development region: 本地化相关 Bundle display name: 应用程序本地化的显示名称，预设值为${PRODUCT_NAME}。 Bundle name: 应用程序的短名称，通常就是你的应用程序名称。 Executable file: 程序安装包的名称, 一般不用改 Bundle identifier: 用来标示应用程序的唯一ID，通常是以反向的DNS方式命名的，例如：com.myCompany.myApp InfoDictionary version: info.plist格式的版本。一般来说，我们不会变动这个数值。 Bundle versions string, short: 应用程序的版本，通常是以三个数字來表示版本号，例如：1.0.1。 Bundle version: 标识编译版本(Bundle number)，你可以使用任何字串格式来表示这个版本。例如使用一个数字来表示编译次数。 Bundle OS Type code: 用用来标识整个封包的(bundle)的类型。在Mac裡面，一个封包可能是一个档案或目录，其目的在于将软体使用到的资源包在一起。例如应用程序应标识为APPL。 Bundle creator OS Type code: 开发者对应用程序的标识 Application requires iPhone environment: 如果应用程序不能在iPad、Touch上运行，设置此项为true; Application uses WIFI: 如果应用程序需要WiFi才能工作，应该将此属性设置为true。这么做会提示用户，如果没有代开WiFi的话，打开WiFi，为了节省电力，iPhone会在30分钟后自动关闭程序中的任何WiFi。设置这一属性可以防止这种情况发生，并且保持连接处于活动状态。 Icon already includes gloss and bevel effects: 应用程序设置玻璃效果，设置为true可以阻止这么做。 Main nib file base name: 应用程序首次启动载入的xib文件 Laumch image: 用以指定应用程序启动时的图片文件。 Initial interface orientation: 指定应用程序打开时的方向。 Localizations: 用以指定应用程序所支持的语言。 Localization native development region: 应用程序原始的语言版本。 Status bar is initially hidden: 设置是否隐藏状态栏 Status bar style: 选择三种不同格式中的一种 URL types: 应用程序支持的URL标识符的一个数组（用于程序回调） supported interface orientation: 程序的默认支持方向 View controller-based status bar appearance: YES/NO 123456// 设为 `YES`, 这时 view controller中对status bar的设置优先级高于application的设置，用下面的方式隐藏status bar:- (BOOL)prefersStatusBarHidden &#123; return YES;&#125;// 设为 `NO`, 这时application的设置优先级最高，用下面的方式隐藏status bar:[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:NO]; Required background modes: 设定当应用程序进入后台执行后，哪些动作要继续在背景执行。这个键值是一个阵列类型的设定，可设定动作包括：audio，locateon，voip。 App Transport Security Settings: https网络，这是个字典，如果需要请求 http 需要设置下列字典项 Allow Arbitrary Loads: YES Privacy ...: 一些权限123456789101112131415161718192021222324Privacy - Media Library Usage Description // 获取用户媒体库说明Privacy - Bluetooth Peripheral Usage Description // 蓝牙外设使用描述Privacy - Calendars Usage Description // 日历的使用说明Privacy - Camera Usage Description // 相机使用叙述说明Privacy - Contacts Usage Description // 联系人使用说明Privacy - Health Share Usage Description // 健康分享使用描述Privacy - Location Always Usage Description // 后台定位(在iOS设置中为&apos;永久&apos;)Privacy - Location Usage Description // 需要定位Privacy - Location When In Use Usage Description // 前台定位(在iOS设置中为&apos;使用期间&apos;)Privacy - Health Update Usage Description // 健康更新使用描述Privacy - HomeKit Usage Description // HomeKit使用描述Privacy - Microphone Usage Description // 麦克风的使用说明Privacy - Motion Usage Description // 运动使用的描述Privacy - Photo Library Usage Description // 照片库使用说明Privacy - Reminders Usage Description // 提醒使用描述Privacy - TV Provider Usage Description // 电视提供商使用的描述 (貌似国内用不到)Privacy - Speech Recognition Usage Description // 语音识别权限Privacy - Reminders Usage DescriptionPrivacy - Reminders Usage Description // 提醒事项权限Privacy - Motion Usage Description // 运动与健身// iOS11新增Privacy - NFC Reader Usage Description //NFC使用描述Privacy - Face ID Usage Descriptio //使用Face IDPrivacy - Photo Library Additions Usage Description // 保存图片到图库中 （重要）","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/tags/Xcode/"}]},{"title":"Git命令","slug":"Git命令","date":"2016-11-05T07:31:46.000Z","updated":"2020-05-17T08:15:15.638Z","comments":true,"path":"default/Git命令/","link":"","permalink":"https://kysonyangs.github.io/default/Git命令/","excerpt":"从O开始12345git initgit remote add origin xxx.gitgit add .git commit -m &quot;xxx&quot;git push origin master 查看远程仓库地址1git remote -v 放弃修改，强制覆盖本地代码123git fetch --allgit reset --hard origin/mastergit pull 打标签1234git tag -a &apos;0.0.1&apos; -m &quot;xxx&quot;git tag #查看git push --tags #提交本地所有标签git push origin 0.0.1 #提交某个标签 删除标签12git tag -d 0.0.1git push origin :0.0.1 #删除远程标签 git push 403 错误原因： 本地储存了用户名和密码，重新设置就好了1git remote set-url origin 用户名@git.coding.xxx.git Git常用命令 git init: 初始化一个Git仓库：把某个目录变成Git可以管理的仓库 git add test.h: 把文件test.h添加到仓库 git commit -m &quot;添加了test.h文件&quot;: 把文件提交到仓库。(git commit命令，-m后面输入的是本次提交的说明) git push (origin master(分支名称)): 推送到远程仓库,其中（）里面是可选的 git pull (origin master(分支名称)): 拉取远程仓库最新,其中（）里面是可选的 git status: 查看工作区的状态 git diff test.h: 查看test.h文件修改了什么（diff—&gt;difference） git log: 显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数 git remote add origin git@...: 关联一个远程库 git push -u origin master: 当远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git clone git@...: 克隆 git remote: 要查看远程库的名称 git remote -v: 显示更详细的远程库信息。显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址 git fetch: 个人粗浅的理解为将远程所有的分支信息拉取到本地1 回退与撤销 git reset --hard HEAD^: 回到上一个版本 git reset --hard HEAD^^: 回到上上个版本 git reset --hard HEAD~100: 回到上100个版本 git reset --hard 791c95aa44cc5540d93a146d6d341e5d38936762: 根据提交的版本号进行版本的回退 git reflog: 查看命令历史，以便确定要回到未来的哪个版本。 git checkout -- readme.txt: 让这个文件回到最近一次git commit或git add时的状态。这里是把readme.txt文件在工作区的修改全部撤销，这里有两种情况： a. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； b. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD 文件(readme.txt): a. 可以把暂存区的修改撤销掉（unstage），重新放回工作区。若要丢弃工作区的修改，还需要git checkout – readme.txt b. git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 分支与合并 git branch dev: 创建一个名称叫dev的分支 git checkout dev: 当前的分支切换为dev分支 git checkout -b dev: 创建一个dev分支，并且切换到dev分支（相当于是是前面两句命令的合并） git branch: 列出所有分支，当前分支前面会标一个*号 git merge dev: 把dev分支的工作成果合并到当前分支上, git merge命令用于合并指定分支到当前分支 git branch -d dev: 删除dev分支 git branch -D dev: 若dev分支还没合并到所切出来的分支，则git branch -d dev将不能删除dev分支，可以通过git branch -D dev强行删除dev分支 git log --graph: 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit git merge --no-ff -m &quot;备注的信息&quot; dev: 将dev分支合并到当前分支的时候强制禁用Fast forward模式 a. 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 b. 合并分支时，加上–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward 合并就看不出来曾经做过合并。 git branch -r: 查看远程分支 git branch -a: 查看所有分支（会显示本地分支和远程分支） 标签 tag git tag: 列出所有 tag git add tag xxxx: 新建一个tag git push --tags: 推送tag到远程 git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2","text":"从O开始12345git initgit remote add origin xxx.gitgit add .git commit -m &quot;xxx&quot;git push origin master 查看远程仓库地址1git remote -v 放弃修改，强制覆盖本地代码123git fetch --allgit reset --hard origin/mastergit pull 打标签1234git tag -a &apos;0.0.1&apos; -m &quot;xxx&quot;git tag #查看git push --tags #提交本地所有标签git push origin 0.0.1 #提交某个标签 删除标签12git tag -d 0.0.1git push origin :0.0.1 #删除远程标签 git push 403 错误原因： 本地储存了用户名和密码，重新设置就好了1git remote set-url origin 用户名@git.coding.xxx.git Git常用命令 git init: 初始化一个Git仓库：把某个目录变成Git可以管理的仓库 git add test.h: 把文件test.h添加到仓库 git commit -m &quot;添加了test.h文件&quot;: 把文件提交到仓库。(git commit命令，-m后面输入的是本次提交的说明) git push (origin master(分支名称)): 推送到远程仓库,其中（）里面是可选的 git pull (origin master(分支名称)): 拉取远程仓库最新,其中（）里面是可选的 git status: 查看工作区的状态 git diff test.h: 查看test.h文件修改了什么（diff—&gt;difference） git log: 显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数 git remote add origin git@...: 关联一个远程库 git push -u origin master: 当远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git clone git@...: 克隆 git remote: 要查看远程库的名称 git remote -v: 显示更详细的远程库信息。显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址 git fetch: 个人粗浅的理解为将远程所有的分支信息拉取到本地1 回退与撤销 git reset --hard HEAD^: 回到上一个版本 git reset --hard HEAD^^: 回到上上个版本 git reset --hard HEAD~100: 回到上100个版本 git reset --hard 791c95aa44cc5540d93a146d6d341e5d38936762: 根据提交的版本号进行版本的回退 git reflog: 查看命令历史，以便确定要回到未来的哪个版本。 git checkout -- readme.txt: 让这个文件回到最近一次git commit或git add时的状态。这里是把readme.txt文件在工作区的修改全部撤销，这里有两种情况： a. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； b. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD 文件(readme.txt): a. 可以把暂存区的修改撤销掉（unstage），重新放回工作区。若要丢弃工作区的修改，还需要git checkout – readme.txt b. git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 分支与合并 git branch dev: 创建一个名称叫dev的分支 git checkout dev: 当前的分支切换为dev分支 git checkout -b dev: 创建一个dev分支，并且切换到dev分支（相当于是是前面两句命令的合并） git branch: 列出所有分支，当前分支前面会标一个*号 git merge dev: 把dev分支的工作成果合并到当前分支上, git merge命令用于合并指定分支到当前分支 git branch -d dev: 删除dev分支 git branch -D dev: 若dev分支还没合并到所切出来的分支，则git branch -d dev将不能删除dev分支，可以通过git branch -D dev强行删除dev分支 git log --graph: 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit git merge --no-ff -m &quot;备注的信息&quot; dev: 将dev分支合并到当前分支的时候强制禁用Fast forward模式 a. 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 b. 合并分支时，加上–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward 合并就看不出来曾经做过合并。 git branch -r: 查看远程分支 git branch -a: 查看所有分支（会显示本地分支和远程分支） 标签 tag git tag: 列出所有 tag git add tag xxxx: 新建一个tag git push --tags: 推送tag到远程 git多账号的使用/体验 生成 ssh key 12ssh-keygen -t rsa -C &quot;your-email-address1&quot;ssh-keygen -t rsa -C &quot;your-email-address2&quot; 将key添加到ssh agent上 1ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_rsa_2 配置.ssh/config 123456789101112131415161718192021vi .ssh/config# 加上以下内容# github# first.github (first@gmail.com)Host github.comHostName github.comIdentityFile ~/.ssh/id_rsa# second (second@gmail.com)Host secondHostName github.comIdentityFile ~/.ssh/id_rsa_second# gitOSc# default git@oscHost git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/id_rsaHost second HostName git.oschina.net IdentityFile ~/.ssh/id_rsa_work 将 id_rsa.pub id_rsa_2.pub添加到对应账号上 验证是否成功 123456//1. Github验证ssh -T git@github.comssh -T git@second//2. Git Osc验证ssh -T git@git.oschina.netssh -T git@git.second.net(貌似是这个吧，有点忘了) 使用账号2clone push 123456git clone... 下来后 修改// 方法1git remote rm origingit remote add origin git@onemaybe:OneMaybe/OneMaybe.github.io.git// 方法2vi .git/config","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://kysonyangs.github.io/tags/Git/"}]},{"title":"CoreData使用","slug":"CoreData使用","date":"2016-08-02T07:28:11.000Z","updated":"2020-05-17T08:15:24.006Z","comments":true,"path":"default/CoreData使用/","link":"","permalink":"https://kysonyangs.github.io/default/CoreData使用/","excerpt":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。","text":"由于最近写了个 gank.io 客户端，鬼使神差的想添加一个收藏功能，并且秉着努力学习新知识的原则，所以我在该项目中试了一下水，感觉还不错，在此，分享出来，供新手参考参考。特别声明: 感谢干货集中营开源的接口。 干货集中营是一个不错的网站，希望越来越好。 创建一个新工程，在AppDelegate里面多了下面方法。 如果你已经创建好工程，但是没勾选上面选项，没关系，新建一个CoreData文件但是AppDelegate里面没东西，没关系，新建一个新项目，将里面的内容拷进你的项目，但是你得修改一个地方 新建一个实体双击修改名字 添加属性 新建NSManagedObject，通过Core Data从数据库取出的对象，默认情况下都是NSManagedObject对象next -&gt; next -&gt; next OK，多了两个文件 KL_Test+CoreDataProperties.swift 不需要变 KL_Test.swift 添加增删查改的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import Foundationimport CoreDataimport UIKit@objc(CollectGank)class KL_Test: NSManagedObject &#123; static let app = UIApplication.sharedApplication().delegate as! AppDelegate static let context = app.managedObjectContext // 插入 static func insert(model: KL_Test) &#123; let collectGank = NSEntityDescription.insertNewObjectForEntityForName(&quot;KL_Test&quot;,inManagedObjectContext: context) as! KL_Test collectGank.name = model.name collectGank.age = model.age do &#123; try context.save() print(&quot;成功&quot;) &#125;catch &#123; fatalError(&quot;不能保存\\(error)&quot;) &#125; &#125; // 查询所有的数据并返回 static func fetch() -&gt; [KL_Test] &#123; var array = [KL_Test]() //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) array = fetchedObjects as! [KL_Test] &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; return array &#125; // 修改 static func update(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() fetchRequest.fetchLimit = 1 //限定查询结果的数量 fetchRequest.fetchOffset = 0 //查询的偏移量 //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;kellen&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 print(fetchedObjects) try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 是否存在（查找） static func exist(gank: KL_Test) -&gt; Bool &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;KL_Test&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos; &quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) //遍历查询的结果 guard (fetchedObjects != nil &amp;&amp; fetchedObjects!.count &gt; 0) else &#123; return false &#125; return true &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125; // 删除 static func deleted(gank: KL_Test) &#123; //声明数据的请求 let fetchRequest:NSFetchRequest = NSFetchRequest() //声明一个实体结构 let entity:NSEntityDescription? = NSEntityDescription.entityForName(&quot;CollectGank&quot;, inManagedObjectContext: context) //设置数据请求的实体结构 fetchRequest.entity = entity //设置查询条件 let predicate = NSPredicate(format: &quot;name = &apos;\\(gank.name)&apos;&quot;) fetchRequest.predicate = predicate //查询操作 do &#123; let fetchedObjects:[AnyObject]? = try context.executeFetchRequest(fetchRequest) print(fetchedObjects) //遍历查询的结果 for info:KL_Test in fetchedObjects as! [KL_Test]&#123; //删除对象 context.deleteObject(info) &#125; //重新保存-更新到数据库 try context.save() &#125;catch &#123; fatalError(&quot;不能保存：\\(error)&quot;) &#125; &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"Charles使用","slug":"Charles使用","date":"2016-06-10T10:15:17.000Z","updated":"2020-05-17T08:15:40.358Z","comments":true,"path":"default/Charles使用/","link":"","permalink":"https://kysonyangs.github.io/default/Charles使用/","excerpt":"Charles 主要的功能 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。","text":"Charles 主要的功能 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 将Charles 设置成系统代理选择菜单中的”Proxy” -&gt; “Mac OX Proxy” 将Charles设置成系统代理。这样就可以看到本机的网络强求了… 过滤网络请求 在Filter中填入你想过需要的关键字 选择菜单”Proxy” -&gt; “Recording Setting” -&gt; “Include”,添加一个项目，填入监控的协议，主机地址，端口号，就可以只截取目标网站的封包。 在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项 其中1、3是临时性的， 2是经常性的。 截取iPhone上的网络封包 Charles 设置将 Charles 的代理功能打开， 选择菜单”Proxy” -&gt; “Proxy Settings”, 在Port填入代理端口8080，并且勾上”Enable transparent HTTP proxying”，如图： iPhone设置2.1 获取电脑IP地址 // 192.168.0.127选择菜单”Help” -&gt; “Local IP Address”查看本机IP2.2 iPhone设置 -&gt; Wi-Fi -&gt; 当前连接的wifi -&gt; 点击右侧详情按钮 -&gt; 底部HTTP代理选择手动 -&gt; 服务器填上电脑的IP地址 -&gt; 端口号填 8080 电脑Chroles会弹出一个是否确认的菜单，选择Allow！！！ OK,完成！ HTTP抓包 打开Charles程序 查看Mac电脑的IP地址，如192.168.1.7 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888 iOS设备打开你要抓包的app进行网络操作 Charles弹出确认框，点击Allow按钮即可 HTTPS抓包 在 iOS 设备上打开这个网址 http://www.charlesproxy.com/getssl 安装 Charles SSL 证书 在Charles的工具栏上点击设置按钮，选择Proxy Settings…3 切换到SSL选项卡，选中Enable SSL Proxying，别急，选完先别关掉，还有下一步 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles则麻烦一些，需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://kysonyangs.github.io/tags/工具/"}]},{"title":"GCD","slug":"GCD","date":"2016-06-10T07:38:34.000Z","updated":"2020-05-17T08:15:20.433Z","comments":true,"path":"default/GCD/","link":"","permalink":"https://kysonyangs.github.io/default/GCD/","excerpt":"Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。*","text":"Queue main queue: 主线程队列，串行队列。一般用于刷新UI。 global queue: 全局队列，并行队列。 custom queue: 自定义队列。* 123456789// 一般用法dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i = 0; i &lt; 100000; i++) &#123; NSLog(@&quot;%zd&quot;, i); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新UI&quot;); &#125;); &#125;); 自定义队列 串行队列 同步运行 123456789101112dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现在for循环之后即dispatch_sync任务执行完之后，因为串行队列同步运行，阻塞主线程。// 在这里发现创建的线程和主线程地址相同，说明串行队列同步运行是直接在主线程中运行的！ 异步运行 1234567891011dispatch_queue_t serialQueue = dispatch_queue_create(&quot;kl.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(serialQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue&quot;);&#125;// 运行结果分析: 线程指针地址相同，是同一个线程；输出结果按序输出，串行队列先进先出。// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 并行队列 同步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_sync(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 线程地址相同，且与主线程队列地址相同，// 结合串行队列同步运行与串行队列异步运行结果来看，同步运行时线程都是在主线程上运行，不开辟新的线程。// 运行结果与串行队列同步运行相同 异步运行 12345678910111213dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;kl.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);for (int j = 0; j &lt; 3; j++) &#123; dispatch_async(concurrentQueue, ^&#123; for (int i = 0 ; i &lt; 3; i++) &#123; NSLog(@&quot;current Thread %@ -- concurrentQueue %zd -- dispatch_async %zd&quot;,[NSThread currentThread] ,j, i); &#125; &#125;); NSLog(@&quot;run in mainQueue current Thread %@&quot;, [NSThread currentThread]);&#125;// 运行结果分析: 输出结构乱序，因为是并行的异步执行，// 不能决定谁先谁后，且发现线程地址不同，说明开了多条线程执行队列，// `run in mainQueue` 出现随机，因为是异步运行，不阻塞主线程。 总结: dispatch_sync 并不会开辟新的线程执行任务，所以不管是串行队列还是并行队列其实都在一个线程(mainQueue也在主线程)中运行，且它是同步的，所以阻塞主线程，一定得队列任务完成之后才会执行之后的任务！ dispatch_async 会异步的运行队列任务，但是串行队列只在一个线程中，所以只是不阻塞主线程，但是还是遵行串行队列FIFO(先进先出)执行任务， 而并行队列会开多条线程进行异步执行任务，效率更高！ dispatch_barrier在 dispatch_barrier 之后的任务总是会在 dispatch_barrier 之前的任务执行完之后在执行 dispatch_barrier_sync 1234567891011121314151617181920212223for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_1_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_sync(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_sync %zd&quot;,[NSThread currentThread], i); if (i == 4) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;);&#125;NSLog(@&quot;dispatch_barrier_sync_main&quot;);for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;);&#125;NSLog(@&quot;dispatch_async_2_main&quot;);// 结果分析 先并发异步执行 dispatch_async_1,// 在执行 dispatch_barrier_sync ,最后并发异步执行 dispatch_async_2, dispatch_barrier_sync 会阻塞主线程 dispatch_barrier_async 12345678910111213141516171819202122232425for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_1 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_1_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_barrier_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_barrier_async %zd&quot;,[NSThread currentThread], i); if (i == 2) &#123; NSLog(@&quot;dispatch_barrier_sync finished&quot;); &#125; &#125;); &#125; NSLog(@&quot;dispatch_barrier_sync_main&quot;); for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;current Thread %@ -- dispatch_async_2 %zd&quot;,[NSThread currentThread], i); &#125;); &#125; NSLog(@&quot;dispatch_async_2_main&quot;); // 结果分析: 首先它仍然会阻拦 dispatch_barrier_async 之后的任务等之前任务执行完之后再执行， // 其次他由于是异步的所以不阻塞主线程， // 但是我发现 `dispatch_barrier_async`里面执行的认为在一条线程中执行，且按顺序执行的！ // 所以我们做耗时操作的时候尽量不要放在`dispatch_barrier_async`中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列啊！ 注意： dispatch_barrier 不要用在global queue 中，因为 dispatch_barrier 只使用在一条并行队列中，而global queue 是每次系统分配一个并行队列(可能是不同的)，所以没有意义！ dispatch_barrier_async里面执行的认为在一条线程中执行，且按顺序执行的！所以我们做耗时操作的时候尽量不要放在dispatch_barrier_async中执行，因为虽然他不阻塞主线程队列，但是会阻塞我们自创的队列！ NSDictionary: 线程安全, 但是NSMutableDictionary: 不是线程安全的，所以我们可以使用 dispatch_barrier_async 来保证 NSMutableDictionary 线程安全!(Get&amp;&amp;Set) dispatch_semaphone: 信号量(用于并发控制) dispatch_semaphore_create(3) 创建信号量，传入一个大于等于0的long型整数(比作停车位，有了停车位才能停车) dispatch_semaphore_signal(semaphone) 传入一个信号量，执行一次，增加一次semaphone计数(可以这么理解: 一辆车开走了，然后这个停车位就空出来了，算作增加一个停车位); 返回值为0时表示当前并没有线程等待其处理的信号量; 返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程(优先级高的先被唤醒，否则随机) dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 5)); 每运行一次，semaphone计数-1，如果semaphone计数为0，那么根据传入的等待时间等待，如果等待时间设置为DISPATCH_TIME_FOREVER,那么就永远等待，永远不会执行之后的了， 除非信号量计数&gt;1了! (可以这么理解: 在这里判断是否有停车位剩余，如果有就停车，没有的话就等待车位空出再停车，如果超出等待时间，这个人就等不下去了，开车走了); 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句 1234567891011121314// sample1:dispatch_semaphore_t semaphone = dispatch_semaphore_create(2); for (int i = 0; i &lt; 10; i++) &#123; if(dispatch_semaphore_wait(semaphone, dispatch_time(DISPATCH_TIME_NOW, 2 *NSEC_PER_SEC)) == 0) &#123; dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;i will sleep 3 second %zd&quot;, i); sleep(3); NSLog(@&quot;i am wake up %zd&quot;, i); NSLog(@&quot;%zd signal %ld&quot;,i, dispatch_semaphore_signal(semaphone)); &#125;); &#125;else&#123; NSLog(@&quot;等不下去了，走人&quot;); &#125; &#125; 123456789101112// sample2:dispatch_semaphore_t semaphone = dispatch_semaphore_create(0);NSLog(@&quot;Boss: Kellen, wake up! working&quot;);dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;Kellen: I am sleep!&quot;); sleep(5); NSLog(@&quot;Kellen: I am wake up!&quot;); dispatch_semaphore_signal(semaphone);&#125;);dispatch_semaphore_wait(semaphone, DISPATCH_TIME_FOREVER);NSLog(@&quot;Kellen: I am working...&quot;);// 等待执行 NSLog(@&quot;Kellen: I am working...&quot;); 以上两种方案的话 看你情况使用！(信号量设为0 ,!0) dispatch_group dispatch_group_notify监听dispatch_queue中所有的任务执行完成，执行某些操作 1234567891011121314151617dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, self.concurrentQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;1 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 1111&quot;);dispatch_group_async(group, self.serialQueue, ^&#123; for (int i = 0; i &lt; 3; i++) &#123; NSLog(@&quot;2 %@ %zd&quot;, [NSThread currentThread], i); &#125;&#125;);NSLog(@&quot;haha 2222&quot;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 任务全部完成处理 NSLog(@&quot;组内任务全部完成，请检验...&quot;);&#125;); enter &amp;&amp; levep dispatch_group_enter(group); 进入组 dispatch_group_leave(group); 离开组 dispatch_group_wait(group, DISPATCH_TIME_FOREVER);(等待组内任务完成)12345678910111213141516171819dispatch_group_t group = dispatch_group_create();for (int i = 0; i &lt; 3; i++) &#123; dispatch_group_enter(group); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@&quot;进入第%zd个异步 sleep 3秒&quot;, i); sleep(3); NSLog(@&quot;离开第%zd个异步 sleep 完成&quot;, i); dispatch_group_leave(group); &#125;);&#125;// 1 -----dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);&#125;);// // 2 ------ 1/2 任选1// dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;网络下载任务全部完成，请刷新UI&quot;);// &#125;);","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"CoreAniamtion","slug":"CoreAniamtion","date":"2016-05-25T07:34:51.000Z","updated":"2020-05-17T08:15:27.662Z","comments":true,"path":"default/CoreAniamtion/","link":"","permalink":"https://kysonyangs.github.io/default/CoreAniamtion/","excerpt":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);","text":"UIView vs CALayer 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews; 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display; View 可以接受事件，而 Layer 不行 属性说明 @property(nullable, strong) id contents; : 可以将CGImage赋值给他，显示成为一张图片1layerView.layer.contents = (__bridge id _Nullable)(image.CGImage); @property(copy) NSString *contentsGravity; : 类似于UIView的contentMode 123456789101112kCAGravityCenterkCAGravityTopkCAGravityBottomkCAGravityLeftkCAGravityRightkCAGravityTopLeftkCAGravityTopRightkCAGravityBottomLeftkCAGravityBottomRightkCAGravityResizekCAGravityResizeAspectkCAGravityResizeAspectFill @property BOOL masksToBounds; : 超出位置是否裁切 @property CGRect contentsRect;这个属性决定图片的显示位置，默认是{0，0，1，1}从左上角到左下角显示，你也可以设为其他的,前两个是起点比例，后两个分别对应宽度和高度比例(该属性一般用于给你一张有许多小图的大图，然后你根据自己的需要去拿你需要的图片) @property CGRect contentsCenter; : 类似于UIImage resizableImageWithCapInsets 属性！ @property CGPoint position; : 类似于UIView的Center， 但是它作用的也是UIView的Center而不是Layer的Center哦 @property CGPoint anchorPoint; : 我的理解是layer中心点的位置，默认为{0.5，0.5}，所以居中显示，但是将它设置为{0，0}，那么layer会以{0，0}为中心点显示哦！这时position没变哦！ @property CGFloat zPosition; @property CGFloat anchorPointZ;由于CALayer是存在于3维空间中的，所以我们可以改变他的z轴(你可以理解为Z轴就是垂直严你的屏幕的轴) @property CGFloat cornerRadius; : 圆角半径(我们一般给视图做圆角的时候，如果界面不是太多，可以使用该方法，但是如果是对Cell里面的视图进行圆角设置或者太多视图需要进行圆角设置，就别用这个属性了，因为layer的渲染会耗资源) @property CGFloat borderWidth; @property(nullable) CGColorRef borderColor;边框的Width和颜色，不必多说 @property CGFloat shadowRadius; 阴影模糊度关于阴影的一些属性，建议如cornerRadius一样，使用阴影的时候别用maskToBounds哦！因为阴影在范围外，使用了会被裁剪掉哦！shadowPath @property(nullable) CGColorRef shadowColor; 阴影颜色 @property float shadowOpacity; 阴影透明度 @property CGSize shadowOffset; 阴影偏移量 @property(nullable) CGPathRef shadowPath; 感觉该属性就是为了解决使用上述属性设置阴影好资源诞生的，推荐使用这个属性设置阴影哦！123456layerView.layer.shadowOpacity = 0.5;layerView.layer.shadowColor = [UIColor redColor].CGColor;layerView.layer.shadowOffset = CGSizeMake(10, 10);// layerView.layer.shadowPath = CGPathCreateWithRect(layerView.layer.bounds, NULL);// layerView.layer.shadowPath = CGPathCreateWithRoundedRect(layerView.layer.bounds, layerView.layer.bounds.size.width * 0.5, layerView.layer.bounds.size.width * 0.5, NULL); (void)setAffineTransform:(CGAffineTransform)m; 这个就是UIView的transform实现1234567891011CGAffineTransform 方法CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 移动CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 放缩CGAffineTransformMakeRotation(CGFloat angle) // 旋转CGAffineTransformIdentity // 复位，初始状态混合变换CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) // 在t的基础上移动CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) // 在t的基础上放缩CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) // 在t的基础上旋转注意： 旋转时使用的是弧度而不是角度，你可以利用下列公式转换角度到弧度#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) @property CATransform3D transform; 仿射变换 3D动画 12345CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz)CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)CATransform3D的 m34 元素, 用来做透视,m34用于按比例缩放X和Y的值来计算到底要离视角多远。 CAShapeLayer 渲染快，高效实用内存，不会被图层边界剪裁掉，不会出现像素化 一般用CGPath来绘制形状12345678910111213141516171819202122UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(200, 100)]; // 绘制圆[path addArcWithCenter:CGPointMake(170, 100) radius:30 startAngle:0 endAngle:2*M_PI clockwise:YES];// 绘制线条[path moveToPoint:CGPointMake(150, 125)];[path addLineToPoint:CGPointMake(150, 175)];// 绘制，展示CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor clearColor].CGColor;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinRound;shapeLayer.lineCap = kCALineCapRound;shapeLayer.path = path.CGPath;[self.view.layer addSublayer:shapeLayer];// 再提一个 绘制圆角(可选4角)CGRect rect = CGRectMake(50, 50, 100, 100);CGSize radii = CGSizeMake(20, 20);UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii]; CATextLabel图层的形式包含了UILabel几乎所有的绘制特性，而且比UILabel渲染的更快哦！(如果你有需求做一个自定制的Label,不防试试这个)1234567891011121314151617181920212223242526272829303132333435363738CATextLayer *textLayel = [CATextLayer layer]; textLayel.frame = CGRectMake(100, 100, 200, 300); [self.view.layer addSublayer:textLayel]; textLayel.foregroundColor = [UIColor blackColor].CGColor; textLayel.backgroundColor = [UIColor orangeColor].CGColor; textLayel.alignmentMode = @&quot;justified&quot;; textLayel.wrapped = YES; UIFont *font = [UIFont systemFontOfSize:17]; CFStringRef fontName = (__bridge CFStringRef)(font.fontName); CGFontRef fontRef = CGFontCreateWithFontName(fontName); textLayel.font = fontRef; textLayel.fontSize = font.pointSize; /** * 分辨率 */ textLayel.contentsScale = [UIScreen mainScreen].scale; CGFontRelease(fontRef); NSString *text = @&quot;Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy! Kellen is a good boy!&quot;; NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:text]; //set text attributes NSDictionary *attribs = @&#123; NSForegroundColorAttributeName : [UIColor blackColor], NSFontAttributeName : font &#125;; [string setAttributes:attribs range:NSMakeRange(0, [text length])]; attribs = @&#123;NSForegroundColorAttributeName : [UIColor redColor]&#125;; [string setAttributes:attribs range:NSMakeRange(6, 5)]; textLayel.string = string; CAGradientLayer处理颜色渐变1234567CAGradientLayer *gradientLayer = [CAGradientLayer layer];gradientLayer.frame = CGRectMake(100, 100, 100, 100);[self.view.layer addSublayer:gradientLayer];gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor blackColor].CGColor];gradientLayer.locations = @[@0,@0.5,@1];gradientLayer.startPoint = CGPointMake(0, 0);gradientLayer.endPoint = CGPointMake(1, 1); CAEmitterLayer : 粒子引擎(直播那些❤️动画之类的)123456789101112131415161718192021222324252627282930313233343536373839404142CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];// 发射器在xy平面的中心位置emitterLayer.emitterPosition = CGPointMake(self.view.frame.size.width-50,self.view.frame.size.height-50);// 发射器的尺寸大小emitterLayer.emitterSize = CGSizeMake(20, 20);// 渲染模式emitterLayer.renderMode = kCAEmitterLayerUnordered;// 开启三维效果// _emitterLayer.preservesDepth = YES;NSMutableArray *array = [NSMutableArray array];// 创建粒子for (int i = 0; i&lt;10; i++) &#123; // 发射单元 CAEmitterCell *stepCell = [CAEmitterCell emitterCell]; // 粒子的创建速率，默认为1/s stepCell.birthRate = 1; // 粒子存活时间 stepCell.lifetime = arc4random_uniform(4) + 1; // 粒子的生存时间容差 stepCell.lifetimeRange = 1.5; // 颜色 // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]]; // 粒子显示的内容 stepCell.contents = (id)[image CGImage]; // 粒子的名字 // [fire setName:@&quot;step%d&quot;, i]; // 粒子的运动速度 stepCell.velocity = arc4random_uniform(100) + 100; // 粒子速度的容差 stepCell.velocityRange = 80; // 粒子在xy平面的发射角度 stepCell.emissionLongitude = M_PI+M_PI_2;; // 粒子发射角度的容差 stepCell.emissionRange = M_PI_2/6; // 缩放比例 stepCell.scale = 0.3; [array addObject:stepCell];&#125;emitterLayer.emitterCells = array;[self.view.layer addSublayer:emitterLayer]; 隐式动画就是当你改变某个属性是时，他会自动平滑的过渡到新的值。而你不需要去开启动画。比如： CALayer的backgroundColor 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。 123456789101112131415161718// 使用事务改变执行时间（默认 0.25s）[CATransaction begin];(入栈)[CATransaction setAnimationDuration:1.0];// 完成之后在旋转90度(0.25s完成)[CATransaction setCompletionBlock:^&#123; NSLog(@&quot;改变颜色完成，开始旋转&quot;); 在颜色改变之后(入栈) CGAffineTransform transform = self.colorLayer.affineTransform; self.colorLayer.affineTransform = CGAffineTransformRotate(transform, M_PI_2); (出栈)&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;[CATransaction commit];(出栈) 你也可以改变隐式动画的行为（如何渐变）12345 // 行为CATransition *transition = [CATransition animation];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;self.colorLayer.actions = @&#123;@&quot;backgroundColor&quot;: transition&#125;; 但是你把上述的self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;改成self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;你会发现它是瞬间改变的，而不是平滑的动画。因为隐式动画被UIView关联图层给禁了！因为处理UIView动画用UIView的动画函数，而不依赖CATransaction。 显式动画 CABasicAnimation(基本动画) 123456789101112CABasicAnimation *basicA = [CABasicAnimation animation];basicA.keyPath = @&quot;backgroundColor&quot;;basicA.toValue = (__bridge id _Nullable)(color.CGColor);basicA.delegate = self;basicA.duration = 1.0;[self.layerView.layer addAnimation:basicA forKey:nil];// 代理，监听动画完成，还有个动画开始的监听- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag &#123; NSLog(@&quot;animation end&quot;); self.layerView.layer.backgroundColor = (__bridge CGColorRef _Nullable)(anim.toValue);&#125; CAKeyframeAnimation (关键帧动画)不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。 123456789CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;backgroundColor&quot;;animation.duration = 2.0;animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];[self.layerView.layer addAnimation:animation forKey:nil]; 123456789UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.keyPath = @&quot;position&quot;;animation.duration = 4.0;animation.path = bezierPath.CGPath;animation.rotationMode = kCAAnimationRotateAuto;[shipLayer addAnimation:animation forKey:nil]; 动画组CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起。 12345678910111213141516171819202122232425262728293031UIBezierPath *bezierPath = [[UIBezierPath alloc] init];[bezierPath moveToPoint:CGPointMake(0, 150)];[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];//draw the path using a CAShapeLayerCAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.path = bezierPath.CGPath;pathLayer.fillColor = [UIColor clearColor].CGColor;pathLayer.strokeColor = [UIColor redColor].CGColor;pathLayer.lineWidth = 3.0f;[self.view.layer addSublayer:pathLayer];//add a colored layerCALayer *colorLayer = [CALayer layer];colorLayer.frame = CGRectMake(0, 0, 64, 64);colorLayer.position = CGPointMake(0, 150);colorLayer.backgroundColor = [UIColor greenColor].CGColor;[self.view.layer addSublayer:colorLayer];//create the position animationCAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];animation1.keyPath = @&quot;position&quot;;animation1.path = bezierPath.CGPath;animation1.rotationMode = kCAAnimationRotateAuto;//create the color animationCABasicAnimation *animation2 = [CABasicAnimation animation];animation2.keyPath = @&quot;backgroundColor&quot;;animation2.toValue = (__bridge id)[UIColor redColor].CGColor;//create group animationCAAnimationGroup *groupAnimation = [CAAnimationGroup animation];groupAnimation.animations = @[animation1, animation2];groupAnimation.duration = 4.0;//add the animation to the color layer[colorLayer addAnimation:groupAnimation forKey:nil]; 过度动画属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。 1234567891011121314151617181920212223type值:kCATransitionFade, // 平滑过渡kCATransitionMoveIn,kCATransitionMoveIn,kCATransitionReveal,subtype值: 控制方向kCATransitionFromRight，kCATransitionFromLeft，kCATransitionFromTop,kCATransitionFromBottomCATransition *transition = [CATransition animation];transition.type = kCATransitionFade;[self.imgv.layer addAnimation:transition forKey:nil];UIImage *currentImage = self.imgv.image;NSUInteger index = [arr indexOfObject:currentImage];index = (index + 1) % [arr count];self.imgv.image = arr[index];// 过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。// 但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，// 因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"js交互","slug":"js交互","date":"2016-05-12T12:19:29.000Z","updated":"2018-11-05T07:20:20.979Z","comments":true,"path":"default/js交互/","link":"","permalink":"https://kysonyangs.github.io/default/js交互/","excerpt":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","text":"现在貌似很多APP都有需求利用HTML5,所以我们需要了解iOS中JavaScript和OC交互的实现。新建一个工程，添加一个空文件index.html1234567891011121314151617181920&lt;html&gt; &lt;!-- 网页的描述信息 --&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script&gt; function event() &#123; alert(&quot;调用JS方法成功哦~&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;!-- 网页的具体内容 --&gt; &lt;body&gt; JS调用OC哦~~ &lt;button style=&quot;background: blue; width:100px; height:30px;&quot; onclick=&quot;event();&quot;&gt;JS调用OC&lt;/button&gt; &lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Objective-C语言调用JavaScript语言 通过UIWebView的 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 方法实现，利用该方法执行一段JavaScript代码。（JavaScript: 以下使用JS代替） 获取当前网页的标题 1self.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title;&quot;]; 获取当前网页的网址URL 1NSLog(@&quot;%@&quot;, [webView stringByEvaluatingJavaScriptFromString:@&quot;document.location.href;&quot;]); 调用JS的方法 1[webView stringByEvaluatingJavaScriptFromString:@&quot;klevent();&quot;] 以上执行情况如下 如果是自己写的HTML5网页，你可以控制里面的元素删除或者添加之类的，当然你得先懂点HTML5-JS知识123NSString *str = @&quot;var p = document.getElementsByTagName(&apos;p&apos;)[0];&quot; &quot;p.remove();&quot;;[webView stringByEvaluatingJavaScriptFromString:str]; * JS调用OC的方法 先来个简单的不带参数1234567891011121314151617181920// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; // 判断是否包含 if ([url hasPrefix:scheme]) &#123; [self js1]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有一个参数12345678910111213141516171819202122232425262728// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://one=kellen&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js2?one=kellen NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js2 NSString *methodName = [[subpaths firstObject] stringByAppendingString:@&quot;:&quot;]; // 参数 kellen NSString *param = [subpaths lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:param]; // 当然，你也可以只获得参数，调用的方法名自己写 return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有两个或多个参数1234567891011121314151617181920212223242526272829303132333435// 1. 先改变index.html中 function event() &#123; location.href = &apos;kl://js3_two_?one=kellen&amp;two=Yangs&apos;; &#125;// 2. 在webView的代理方法中实现- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取将要加载的URL NSString *url = request.URL.absoluteString; NSString *scheme = @&quot;kl://&quot;; if ([url hasPrefix:scheme]) &#123; // 获得协议后面的路径 path == js3_two_?one=kellen&amp;two=Yangs NSString *path = [url substringFromIndex:scheme.length]; // 利用?切割路径 NSArray *subpaths = [path componentsSeparatedByString:@&quot;?&quot;]; // 方法名 methodName == js3_two_ NSString *methodName = [[subpaths firstObject] stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;:&quot;]; // 参数 one=kellen&amp;two=Yangs NSString *param = [subpaths lastObject]; NSArray *subparams = nil; if (subpaths.count == 2 || [param containsString:@&quot;&amp;&quot;]) &#123; subparams = [param componentsSeparatedByString:@&quot;&amp;&quot;]; &#125; // 取出前面的2个参数 NSString *firstParam = [subparams firstObject]; NSString *secondParam = subparams.count &lt;= 1 ? nil : [subparams lastObject]; [self performSelector:NSSelectorFromString(methodName) withObject:firstParam withObject:secondParam]; return NO; &#125; NSLog(@&quot;加载其他请求，不是调用OC的方法&quot;); return YES;&#125; 有个三方库可以方便开发","categories":[],"tags":[]},{"title":"iOS国际化","slug":"iOS国际化","date":"2016-05-09T03:16:08.000Z","updated":"2018-11-05T07:17:21.544Z","comments":true,"path":"default/iOS国际化/","link":"","permalink":"https://kysonyangs.github.io/default/iOS国际化/","excerpt":"应用名称国际化 1.ctrl+n 创建一个.strings文件，如图","text":"应用名称国际化 1.ctrl+n 创建一个.strings文件，如图 2.选中InfoPlist.strings， 点击Localization中的Localized…按钮，选则English 3.选择Project -&gt; Localization，添加Chinese,如图 最后，在InfoPlist.strings(English)添加：CFBundleDisplayName = “Internationlization”; 在InfoPlist.strings(Chineses)添加：CFBundleDisplayName = “国际化”; 即可，你可以在模拟器切换English和中文设置查看效果 应用字符国际化 在InfoPlist.strings(English)添加：”key” = “test”; 在InfoPlist.strings(Chineses)添加：”key” = “测试”; 在代码添加1self.title = NSLocalizedStringFromTable(@&quot;key&quot;, @&quot;InfoPlist&quot;, @&quot;&quot;); Xib/StoryBoard 1.选中Main.storyboard,打开文件选择器，勾选Localization下面的base\\chinese\\english 2.在storyboard拖一个Label,在如图所示的地方了看到他的ID","categories":[],"tags":[]},{"title":"Xcode插件","slug":"Xcode插件","date":"2016-04-12T07:18:20.000Z","updated":"2020-05-17T08:12:19.931Z","comments":true,"path":"default/Xcode插件/","link":"","permalink":"https://kysonyangs.github.io/default/Xcode插件/","excerpt":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter）","text":"哎，插件久了没用都忘了快捷键是啥了，特写此文，以备忘… 先上几个快捷键常用图案： 快捷键中常用符号⌘（command）、⌥（option）、⇧（shift）、⇪（caps lock）、⌃（control）、↩（return）、⌅（enter） 常用插件以及用法：1.Alcatraz: 插件管理123456// 安装(mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins)curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh// 删除rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz 2.XcodeColors：给 Xcode 控制台添加颜色 用法见我以前写的一篇简书Xcode带颜色Log 当然这个插件与CocoaLumberjack是一对好基友，有兴趣的可以自行了解… 3.XToDo：这个插件可以给注释加书签类的功能，你可以随时跳转到你加此类注释的地方 添加 TODO 书签 – ⌃⇧T 添加 FIXME 书签 – ⌃⇧X 添加 ？？？ 书签 – ⌃⇧1 添加 ！！！ 书签 – ⌃⇧Q 书签窗口 – ⌃T 4.KSImageNamed：自动补全图片名5.Peckham：导入头文件 ⌘ + ctrl + P 然后选择你要导入的头文件即可 6.FuzzyAutocomplete：自动补全，提升编写效率7.CodePilot: 便捷查找你所需要的文件，代码… ⌘ + shift + X 输入你需要查找的内容即可 8.HOStringSense：很方便的编写大段文本9.XcodeBoost: 功能十分强大也十分方便，具体请进github自行观看10.SCXcodeMiniMap: 给Xcode创建一个迷你地图11.XAlign：对齐代码 选中你需要对齐的代码 – ⌘ + shift + Z 12.VVDocumenter: 规范化注释插件 -&gt; /// – 快捷键13.BBUDebuggerTuckAway: 自动隐藏底部的调试栏14.Backlight：高亮当前正在编辑的那一行15.xcode语法高亮插件16.ColorSense: 可视化颜色17.[SCXcodeSwitchExpander(https://github.com/stefanceriu/SCXcodeSwitchExpander):switch枚举的时候会自动生成代码 补充一点很实用的东东1.插件目录： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/2.当Xcode升级版本，然后插件失效后：12341.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID2.然后输入如下命令 【最后一项是获取到的DVTPlugInCompatibilityUUID】 find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add 9F75337B-21B4-4ADC-B558-F9CADF7073A7 3.playground无效，可能是误删模拟器的类型，重置12rm -rf ~/Library/Developer/CoreSimulator/Devices killall -9 com.apple.CoreSimulator.CoreSimulatorService 神一般的插件 injectionforxcode 安装插件使用Alcatraz插件管理器直接安装injectionforxcode-Github地址当你看到红框里面的东西有了之后说明，插件安装成功了！ 使用在Controller添加以下方法 123456789// OC- (void)injected&#123; NSLog(@&quot;I&apos;ve been injected: %@&quot;, self);&#125;// Swiftfunc injected() &#123; print(&quot;I&apos;ve been injected: \\(self)&quot;)&#125; ctrl + = 看一下你的控制台有没有输出 I’ve been injected 有了说明成功了 在 injected 方法中加入你要修改的UI代码，按下 ctrl + = 你可以看到模拟器界面的变化 或者按下 ctrl + shift + = 这个可以不用将代码写在injected 方法中，他会重新运行一遍你的程序，而不是单个Controller","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://kysonyangs.github.io/tags/Xcode/"}]},{"title":"条形码和二维码生成","slug":"条形码和二维码生成","date":"2016-04-11T09:56:06.000Z","updated":"2020-05-17T08:16:05.014Z","comments":true,"path":"default/条形码和二维码生成/","link":"","permalink":"https://kysonyangs.github.io/default/条形码和二维码生成/","excerpt":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","text":"生成条形码12345678910111213141516- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成条形码图片 CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CICode128BarcodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 生成二维码123456789101112131415161718- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; // 生成二维码图片 CIImage *qrcodeImage; NSData *data = [_code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;]; [filter setValue:data forKey:@&quot;inputMessage&quot;]; [filter setValue:@&quot;H&quot; forKey:@&quot;inputCorrectionLevel&quot;]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"iOS基础知识","slug":"iOS基础知识","date":"2016-02-05T11:05:07.000Z","updated":"2018-12-12T08:49:40.151Z","comments":true,"path":"default/iOS基础知识/","link":"","permalink":"https://kysonyangs.github.io/default/iOS基础知识/","excerpt":"应用沙盒 Documents: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录. Library: Caches: 保存应用运行时生成的需要持久化的数据，一般存储体积大、不需要备份的非重要数据,缓存文件存储地. - Preferences: 保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息,iTunes同步设备时会备份该目录. tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除;应用没有运行时，系统也可能会清除该目录下的文件;iTunes同步设备时不会备份该目录.","text":"应用沙盒 Documents: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录. Library: Caches: 保存应用运行时生成的需要持久化的数据，一般存储体积大、不需要备份的非重要数据,缓存文件存储地. - Preferences: 保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息,iTunes同步设备时会备份该目录. tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除;应用没有运行时，系统也可能会清除该目录下的文件;iTunes同步设备时不会备份该目录. 路径获取：12345678910111213141516// 沙盒根目录NSLog(@&quot;%@&quot;, NSHomeDirectory());// DocumentsNSLog(@&quot;%@&quot;, [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;]);// ORNSLog(@&quot;%@&quot;, [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]);// Library - CachesNSLog(@&quot;%@&quot;, [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library&quot;] stringByAppendingPathComponent:@&quot;Caches&quot;]);// ORNSLog(@&quot;%@&quot;, [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]);Preference[NSUserDefaults standardUserDefaults] ...// tmpNSLog(@&quot;t - %@&quot;, NSTemporaryDirectory()); content Hugging ／ content Compression Resistance不想变大/不想变小约束 灰常有用哦 layoutSubviews方法调用 init方法不会调用 addSubview方法等时候会调用 bounds改变的时候调用 scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑) 旋转设备的时候调用 子视图被移除的时候调用 内存的几大区域栈区（Stack）由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点时有限制，数据不灵活。［先进后出］ 栈空间分 静态分配 和 动态分配两种。 静态分配是编译器完成的，比如自动变量（auto）的分配 动态变量是由 alloc 函数完成的 栈的动态分配无需释放（是自动的），也就没有释放函数。 为可移植的程序起见，栈的动态分配是不被鼓励的。 堆区（heap）由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在 ios 中 alloc 都是存放在堆中。 优点是灵活方便，数据适应面广泛，但是效率有一定降低。 堆是函数库内部数据结构，不一定唯一。 不同堆的分配的内存无法相互操作。 堆空间的分配总是动态的 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 全局区(静态区) (static)全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。 文字常量区存放常量字符串，程序结束后由系统释放； 代码区存放函数的二进制代码 CGRectInset 与 CGRectOffsetCGRectInset 与 CGRectOffset 都是通过参数改变 CGRect 并返回一个 CGRect 类型的数据。总结出两者的区别在于：CGRectInset 会进行平移和缩放两个操作。CGRectOffset 做的只是平移。 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)通过第二个参数 dx 和第三个参数 dy 重置第一个参数 rect 作为结果返回。重置的方式为，首先将 rect 的坐标（origin）按照(dx,dy) 进行平移，然后将 rect 的大小（size） 宽度缩小2倍的 dx，高度缩小2倍的 dy。注意: dx dy 正数 左右两边缩小，负数则是放大 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)rect 按照（dx,dy）进行平移。 断言 NSAssert() 和 NSParameterAssert 区别和用处NSAssert 和 assert 是断言,主要的差别是 assert 在断言失败的时候只是简单的终止程序, 而 NSAssert 会报告出错误信息并且打印出来. 所以尽管的使用 NSAssert,可以不去使用 assert. NSAssert/NSCAssert 两者的差别, 前者是适合于Objective-C的方法, 后者是适用于 C 的函数.NSParameterAssert/NSCparameterAssert 两者的区别也是前者适用于 Objective-C 的方法, 后者适用于 C 的函数.NSAssert/NSCAssert 和 NSParameterAssert/NSCparameterAssert 的区别是前者是所有断言, 后者只是针对参数是否存在的断言, 所以可以先进行参数的断言,确认参数是正确的,再进行所有的断言,确认其他原因.NSAssert的用法12int a = 4;NSAssert(a == 5, @&quot;a must equal to 5&quot;); //第一个参数是条件,如果第一个参数不满足条件,就会记录和打印第二个参数 NSParameterAssert的用法1NSParameterAssert(str); //只需要一个参数,如果参数存在程序继续运行,如果参数为空,则程序停止打印日志 注: Xcode 已经默认将release环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. iOS模拟器的Debug菜单iOS模拟器的Debug菜单中提供了几个菜单项来检测影响帧率的一些因素： Color Blended Layers: 高亮显示有混合操作的区域； Color Copied Images: 高亮显示被拷贝的图片。拷贝图片意味着Core Animation需要拷贝一份图片并发送给render server，这对内存和CPU的使用都是昂贵的； Color Misaligned Images: 高亮显示缩放或拉伸过的图片，或者没有正确对齐对到像素边界的图片； Color Offscreen-Rendered: 高亮显示离屏渲染的层对象。 nil、NIL、NULL、 NSNull 的区别 nil: 指向一个对象的空指针, 对 Objective-C id 对象赋空值. 1NSString *str = nil; Nil: 指向一个类的空指针, 表示对类进行赋空值. 1Class Class1 = Nil; NULL: 指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值. 123int *intA = NULL;char *charC = NULL;struct structStr = NULL; NSNull: 在集合对象中，表示空值的对象.NSNull在Objective-C中是一个类. NSNull有 + (NSNull *)null; 单例方法. 多用于集合(NSArray,NSDictionary)中值为空的对象. 1234567891011NSArray *array = [NSArray arrayWithObjects: [[NSObject alloc] init], [NSNull null], nil];NSMutableDictionary *mutableDictionary = [[NSMutableDictionary alloc] init];[mutableDictionary setObject:nil forKey:@&quot;Key-nil&quot;]; // 会引起Crash[mutableDictionary setObject:[NSNull null] forKey:@&quot;Key-nil&quot;]; // 不会引起Crash//所以在使用时，如下方法是比较安全的[mutableDictionary setObject:(nil == value ? [NSNull null] : value) forKey:@&quot;Key&quot;]; property 属性的关键字 表示原子性 atomic（默认）: 线程安全，但是线程开销大，影响性能注: atomic不一定是线程安全，因为其只保证 setter&amp;getter 是线程安全，但是如果 threadA 进行写，这时其他现线程的读或者写会因为该操作而等待。但是当 threadA 写操作完成后，threadB 进行写操作，threadA 需要读操作的时候，可能会获得 threadB 线程的值，这就破坏了线程安全。而且如果 threadC 在 threadA 线程读操作之前 release 了， 会导致崩溃。所以 atomic 所说的线程安全只是保证了 getter和setter 存取方法的线程安全，并不能保证整个对象是线程安全的。 nonatomic: 非线程安全 表示引用计数 assign: assign 用于非指针变量，一般用于基础类型和C数据类型，这些类型不是对象，统一由系统栈进行内存管理。 weak: 对对象的弱引用，不增加对象的引用计数，也不持有对象，当对象消失后指针自动指向nil，所以这里也就防止了野指针的存在。 strong: 对对象的强引用，会增加对象的引用计数，如果指向了一个空对象，会造成野指针，平常我们用得最多的应该也是strong了。 copy: 建立一个引用计数为1的新对象，赋值时对传入值进行一份拷贝，所以使用 copy 关键字的时候，你将一个对象复制给该属性，该属性并不会持有那个对象，而是会创建一个新对象，并将那个对象的值拷贝给它。而使用 copy 关键字的对象必须要实现 NSCopying 协议。 unsafe_unretained: 跟 weak 类似，声明一个弱引用，但是当引用计数为 0 时，变量不会自动设置为 nil，现在基本都用 weak 了。 表示权限 readwrite: 可读可写 readonly: 只读，当你希望暴露出来的属性不能被外界修改时就需要申明为 readonly 。 id 和 instanceType instancetype 和 id 都是万能指针，指向对象。 id 在编译的适合不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型 id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型 instancetype 只适用于初始化方法和便利构造器的返回值类型 @synthesize 和 @dynamic @property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic 都没写，那么默认的就是 @syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter方法和 getter方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器,属性的 setter与getter 方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和@getter 方法，编译的时候没问题，但是当程序运行到instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 UIView 和 CALayer UIView 和 CALayer 算是相互补充的关系。 UIView = CALayer.delegate UIView : 负责用户的交互事件。 CALayer: 负责图像和动画的渲染。 Bounds 和 Frame Bounds: 一般是相对于自身来说的，是控件的内部尺寸。如果你修改了 Bounds，那么子控件的相对位置也会发生改变。 Frame: 是相对于父控件来说的，是控件的外部尺寸。 UIViewController 生命周期 深拷贝与浅拷贝浅拷贝指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。 单层深拷贝 对于不可变的容器类对象(如 NSArray、NSSet、NSDictionary)进行 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化，属于单层深拷贝。 对于可变集合类对象(如 NSMutableArray、NSMutableSet、NSMutableDictionary)，不管是进行 copy 操作还是 mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。 深拷贝指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。 非集合类型的 copy 与 mutableCopy NSString copy 内存地址不变，浅拷贝 mutableCopy 内存地址改变，深拷贝 NSMutableString copy 内存地址改变，深拷贝 mutableCopy 内存地址改变，深拷贝 集合类型的 copy 与 mutableCopy NSArray copy 内存地址不变，内部元素地址不变，浅拷贝 mutableCopy 内存地址改变，但是内部元素地址不变，单层深拷贝 NSMutableArray copy 内存地址改变，但是内部元素地址不变，单层深拷贝 mutableCopy 内存地址改变，但是内部元素地址不变，单层深拷贝 实现集合类型的深拷贝 通过归解档生成两份完全独立的对象，但是前提是对象(子对象)必须全部支持 NSCoding 协议。推荐使用 YYModel + NSCopying 这样就不用自己写逻辑代码了 😁 自己实现一个深拷贝协议 123@protocol YSDeepCopy &lt;NSObject&gt;- (id)ys_deepCopy;@end @interface NSArray (YSDeepCopy) @end123456789101112131415161718192021222324- (instancetype)ys_deepCopy &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:self.count]; for (id subObject in self) &#123; id deepCopySubObject = nil; if ([subObject respondsToSelector:@selector(ys_deepCopy)]) &#123; deepCopySubObject = [subObject ys_deepCopy]; &#125; else if ([subObject conformsToProtocol:@protocol(NSCopying)]) &#123; deepCopySubObject = [subObject copy]; &#125; else &#123; NSAssert1(NO, @&quot;Class \\&quot;%s\\&quot; not support YSDeepCopy&quot;, object_getClassName(subObject)); deepCopySubObject = subObject; &#125; [mArray addObject:deepCopySubObject ?: subObject]; &#125; if ([self isKindOfClass:[NSMutableArray class]]) &#123; return mArray; &#125; else &#123; return [NSArray arrayWithArray:mArray]; &#125;&#125; 但是如果 数组里面 添加的是自己定义的Model， 则应该实现 Model 的 NSCopying 协议， 或者 YSDeepCopy 协议推荐使用 YYModel + NSCopying 这样就不用自己写逻辑代码了 😁","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kysonyangs.github.io/tags/iOS/"}]},{"title":"发布pods到CocoaPods","slug":"发布pods到CocoaPods","date":"2016-01-20T07:12:36.000Z","updated":"2020-05-17T08:16:16.849Z","comments":true,"path":"default/发布pods到CocoaPods/","link":"","permalink":"https://kysonyangs.github.io/default/发布pods到CocoaPods/","excerpt":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose","text":"注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; pod trunk register xxx@gmail.com &#39;KL&#39; --verbose 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: xxx- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec cretae 文件名 比如pod spec cretae KLTest 就会生成一个KLTest.podspec 填写podspec内容123456789101112Pod::Spec.new do |s| s.name = &quot;KLTest&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/xxx/KLTest&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;KL&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/xxx/KLTest.git&quot;, :tag =&gt; s.version &#125; s.source_files = &quot;KLTestExample/KLTestExample/KLTest&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint KLTest.podspec pod spec lint KLTest.podspec —allow-warnings 忽略所有警告 发布podspec pod trunk push KLTest.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.git","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://kysonyangs.github.io/tags/CocoaPods/"}]},{"title":"iOS数组排序","slug":"iOS数组排序","date":"2015-10-24T07:10:27.000Z","updated":"2018-11-05T07:11:32.218Z","comments":true,"path":"default/iOS数组排序/","link":"","permalink":"https://kysonyangs.github.io/default/iOS数组排序/","excerpt":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图","text":"iOS 数组排序现在有下列两个数组，我们从他们开始接触数组的排序 12NSArray *arrayString = @[@&quot;20&quot;, @&quot;30&quot;, @&quot;8&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;88&quot;, @&quot;66&quot;];NSArray *arrayNumber = @[@20, @30, @8, @10, @9, @88, @66]; 1、sortedArrayUsingSelector这个方法很简单，使用也很便捷，它返回一个排好序的数组 [arrayString sortedArrayUsingSelector:@selector(compare:)]； 但是当你执行打印会发现arrayString执行该方法排序后的结果是下图 在这里我们要注意的时，它排序的时候如果对于arrayString 来说，它是按字母书序排列的，而不是按照数字大小，这个要注意， arrayNumber 这个数组则没问题，如果你想要按照自己的规则来排序，可以自己写个方法，传到@selector() 里面就行 2、sortedArrayUsingComparator使用这个方法，我们可以在block里面写入自己定义的规则，实现起来也听方便的 123[arrayString sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; return [obj1 integerValue] &gt; [obj2 integerValue];&#125;] 现在就是正确的按照数字大小排序了，嘿嘿嘿~ 3、sortedArrayUsingDescriptors &amp; sortUsingDescriptors前者返回一个排好序的数组，后者则是对自身进行排序，无返回值~哲理我们讲一下前者的方法，不多说，上代码— 12345678910111213141516171819202122232425262728293031323334353637//首先我们定义一个类Person@interface Person : NSObject@property NSString *name;@property NSNumber *age;@end@implementation Person- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;name = %@, age = %@&quot;, self.name, self.age];&#125;@end//然后实例化一个Person数组NSArray *name = @[ @&quot;Allen&quot;, @&quot;Kellem&quot;, @&quot;God&quot;, @&quot;Queen&quot;, @&quot;King&quot;, @&quot;Bob&quot;];NSArray *ages = @[@8, @20, @9, @88, @70, @20];NSMutableArray *people = [NSMutableArray array];//这里是一个数组的遍历方法，建议大家使用这种方法进行数组的遍历[name enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; Person *person = [[Person alloc] init]; person.name = [name objectAtIndex:idx]; person.age = [ages objectAtIndex:idx]; [people addObject:person];&#125;];// 名字进行排序，降序规则，key可以传nil,或者&quot;self&quot;，在对如下数组排序时可用 NSArray *ages = @[@8, @20, @9, @88, @70, @20];//再多说一句，key 这里用到的类似KVC，其中理念自己体会 =-=NSSortDescriptor *nameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES];// 年龄进行排序，升序规则NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:NO];//然后使用规则进行排序，执行，打印// 这里规则是一个数组，你可以传入多个规则，例如3NSLog(@&quot;By age: %@&quot;, [people sortedArrayUsingDescriptors:@[ageSortDescriptor]]); NSLog(@&quot;By name name: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor]]);NSLog(@&quot;By name, age: %@&quot;, [people sortedArrayUsingDescriptors:@[nameSortDescriptor, ageSortDescriptor]]); 结果如下图： 最后再体验一下其中的KVC奥妙，我们用字典来体验一下 123456789NSArray *dict =@[ @&#123;@&quot;age&quot;:@20&#125;, @&#123;@&quot;age&quot;:@5&#125;, @&#123;@&quot;age&quot;:@70&#125;, @&#123;@&quot;age&quot;:@33&#125;];NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:YES];NSArray *arr = [dict sortedArrayUsingDescriptors:@[sort]];NSLog(@&quot;%@&quot;,arr);","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"https://kysonyangs.github.io/tags/数组/"}]},{"title":"iOS技巧","slug":"iOS技巧","date":"2015-10-06T12:00:23.000Z","updated":"2018-11-05T07:43:17.533Z","comments":true,"path":"default/iOS技巧/","link":"","permalink":"https://kysonyangs.github.io/default/iOS技巧/","excerpt":"判断iPhoneX++123456789101112131415static inline BOOL isIPhoneXSeries() &#123; BOOL iPhoneXSeries = NO; if (UIDevice.currentDevice.userInterfaceIdiom != UIUserInterfaceIdiomPhone) &#123; return iPhoneXSeries; &#125; if (@available(iOS 11.0, *)) &#123; UIWindow *mainWindow = [[[UIApplication sharedApplication] delegate] window]; if (mainWindow.safeAreaInsets.bottom &gt; 0.0) &#123; iPhoneXSeries = YES; &#125; &#125; return iPhoneXSeries;&#125;","text":"判断iPhoneX++123456789101112131415static inline BOOL isIPhoneXSeries() &#123; BOOL iPhoneXSeries = NO; if (UIDevice.currentDevice.userInterfaceIdiom != UIUserInterfaceIdiomPhone) &#123; return iPhoneXSeries; &#125; if (@available(iOS 11.0, *)) &#123; UIWindow *mainWindow = [[[UIApplication sharedApplication] delegate] window]; if (mainWindow.safeAreaInsets.bottom &gt; 0.0) &#123; iPhoneXSeries = YES; &#125; &#125; return iPhoneXSeries;&#125; Button 大小12345- (CGSize)intrinsicContentSize &#123; CGSize originalSize = [super intrinsicContentSize]; CGSize size = CGSizeMake(originalSize.width+10, originalSize.height); return size;&#125; 截屏12345678- (UIImage *)screenshot &#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; UIGraphicsBeginImageContextWithOptions(window.bounds.size, YES, [UIScreen mainScreen].scale); [window.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 设置pageControl单页不显示1self.pageControl.hidesForSinglePage = YES; 让数组中的所有对象都执行一下方法1[self.view.subViews makeObjectsPerformSelector:@selecter(removeFromSuperView)]; scrollsToTopscrollsToTop是UIScrollView的一个属性，主要用于点击设备的状态栏时，是scrollsToTop == YES的控件滚动返回至顶部。每一个默认的UIScrollView的实例，他的scrollsToTop属性默认为YES，所以要实现某一UIScrollView的实例点击设备状态栏返回顶部，则需要关闭其他的UIScrollView的实例的scrollsToTop属性为NO。 SB跳转12345678910// 跳转[self performSegueWithIdentifier:@&quot;login2Contact&quot; sender:nil];// 在执行跳转之前的时候调用- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; UIViewController *vc = segue.destinationViewController; vc.title = [NSString stringWithFormat:@&quot;%@的联系人列表&quot;, _accountField.text]; NSLog(@&quot;%@--%@&quot;,segue.sourceViewController,segue.destinationViewController);&#125; iOS 10拨打系统电话发现弹出框会延迟2s左右解决方案一：12345678910111213+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; NSComparisonResult compare = [[UIDevice currentDevice].systemVersion compare:@&quot;10.0&quot;]; if (compare == NSOrderedDescending || compare == NSOrderedSame) &#123; /// 大于等于10.0系统使用此openURL方法 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone] options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;&#125; 解决方案二：123456789+ (void)callPhone:(NSString *)phoneNum &#123; if (phoneNum.length == 0) &#123; return; &#125; NSString *callPhone = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, phoneNum]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:callPhone]]; &#125;);&#125; 修改TableViewHeaderView字体大小123456- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section &#123; UITableViewHeaderFooterView *header = (UITableViewHeaderFooterView *)view; header.textLabel.textColor = [UIColor grayColor]; header.textLabel.font = [UIFont systemFontOfSize:15]; header.contentView.backgroundColor = [UIColor groupTableViewBackgroundColor];&#125; heightForHeaderInSection设置高度无效1234iOS11默认开启Self-Sizing，关闭Self-Sizing即可。self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0; 屏蔽一些无知的警告Xcode8里边 Edit Scheme-&gt; Run -&gt; Arguments, 在Environment Variables里边添加 OS_ACTIVITY_MODE ＝ Disable · 如果写了之后还是打印log,请重新勾选对勾，就可以解决了。 UITableView收起键盘1tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; 长按复制功能123456789- (void)viewDidLoad &#123; [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];&#125;- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress &#123; if (longPress.state == UIGestureRecognizerStateBegan) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;需要复制的文本&quot;; &#125;&#125; 禁止手机睡眠1[UIApplication sharedApplication].idleTimerDisabled = YES; 禁用button高亮123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 控制屏幕旋转，在控制器中写1234567891011121314/** 是否支持自动转屏 */- (BOOL)shouldAutorotate &#123; return YES;&#125;/** 支持哪些屏幕方向 */- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;&#125;/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;&#125; 获取app缓存大小123456789101112131415161718- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; UITextView中打开或禁用复制，剪切，选择，全选等功能12345678910111213141516171819// 继承UITextView重写这个方法- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; // 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125; 禁止textField和textView的复制粘贴菜单123456- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if ([UIMenuController sharedMenuController]) &#123; [UIMenuController sharedMenuController].menuVisible = NO; &#125; return NO;&#125; 为一个view添加虚线边框1234567 CAShapeLayer *border = [CAShapeLayer layer];border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;border.fillColor = nil;border.lineDashPattern = @[@4, @2];border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;border.frame = view.bounds;[view.layer addSublayer:border]; 设置tableView分割线颜色1[self.tableView setSeparatorColor:[UIColor myColor]]; UIImage和base64互转12345678- (NSString *)encodeToBase64String:(UIImage *)image &#123; return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];&#125;- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData &#123; NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [UIImage imageWithData:data];&#125; 摇一摇功能12345678910111、打开摇一摇功能[UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;2、让需要摇动的控制器成为第一响应者[self becomeFirstResponder];3、实现以下方法// 开始摇动- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event// 取消摇动- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event// 摇动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 发起QQ聊天QQ开通推广服务以接收陌生消息12345678//是否安装QQif([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) &#123; //用来接收临时消息的客服QQ号码(注意此QQ号需开通QQ推广功能,否则陌生人向他发送消息会失败) NSString *QQ = @&quot;1099779883&quot;; //调用QQ客户端,发起QQ临时会话 NSString *url = [NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,QQ]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];&#125; MJRefresh webview去掉长按后的选择和复制菜单12345678910111213141516171819202122231. webview 执行 js- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; NSLog(@&quot;%s&quot;, __FUNCTION__); // 禁用选中效果 [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot; completionHandler:nil]; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot; completionHandler:nil];&#125;func webViewDidFinishLoad(webView: UIWebView) &#123; //禁用webview长按后文字选择框和放大框 webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;&quot;) webView.stringByEvaluatingJavaScriptFromString(&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;&quot;) &#125;2. 或者前端写css&lt;style type=&quot;text/css&quot;&gt;*:not(input,textarea) &#123; -webkit-touch-callout: none; -webkit-user-select: none; /* Disable selection/Copy of UIWebView */&#125;&lt;/style&gt; XIB 可见属性设置（eg: 圆角） OC: IB_DESIGNABLE 和 IBInspectable 12345678910111213// .h@property (nonatomic, assign) IBInspectable CGFloat cornerRadius;// .mIB_DESIGNABLE @implementation KLButton- (void)setCornerRadius:(CGFloat)cornerRadius &#123; self.layer.cornerRadius = cornerRadius; self.layer.masksToBounds = (cornerRadius &gt; 0);&#125;- (CGFloat)cornerRadius &#123; return self.layer.cornerRadius;&#125; Swift: IBInspectable 和 IBDesignable 方法不确定的参数 va_arg 宏的使用当我们方法需要传入多个不确定的参数时(如：[NSArray arrayWithObjects]), 我们可以使用 ,… 的形式表示,当要取传入的参数的值时就需要用到 va_arg 宏去取。例如：1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; [self testMethod:@&quot;123&quot;,@&quot;456&quot;,@&quot;789&quot;，nil];&#125;- (void)testMethod:(NSString *)test,.. NS_REQUIRES_NIL_TERMINATION &#123; va_list argList; va_start(argList, test); &#123; for (id params = test; params != nil; params = va_arg(argList, id))&#123; NSLog(@&quot;id = %@---class = %@&quot;,params,NSStringFromClass([params class])); &#125; &#125; va_end(argList);&#125; 去除数组中重复的对象1NSArray *newArr = [oldArr valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]; 删除NSUserDefaults所有记录1234567891011121314//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];//方法二- (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize]; &#125;// 方法三[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; UITableViewCell 分割线置顶1234567891011121314if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; [self.tableView setSeparatorInset:UIEdgeInsetsMake(0, 10, 0, 0)];&#125;if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; [self.tableView setLayoutMargins:UIEdgeInsetsMake(0, 10, 0, 0)];&#125;// 3. cell 下if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsZero];&#125;if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero];&#125; 设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面12tabBarController.tabBar.translucent = NO;uiviewController.navigationController.navigationBar.translucent = NO; 禁用button高亮,点击变灰的效果123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 自定义cell选中背景颜色123UIView *bgColorView = [[UIView alloc] init];bgColorView.backgroundColor = [UIColor redColor];[cell setSelectedBackgroundView:bgColorView]; UILabel设置内边距123456子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect &#123; // 边距，上左下右 UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];&#125; UILabel设置文字描边12345678910111213141516子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect&#123; CGContextRef c = UIGraphicsGetCurrentContext(); // 设置描边宽度 CGContextSetLineWidth(c, 1); CGContextSetLineJoin(c, kCGLineJoinRound); CGContextSetTextDrawingMode(c, kCGTextStroke); // 描边颜色 self.textColor = [UIColor redColor]; [super drawTextInRect:rect]; // 文本颜色 self.textColor = [UIColor yellowColor]; CGContextSetTextDrawingMode(c, kCGTextFill); [super drawTextInRect:rect];&#125; 改变UISlider的进度条高度需要继承UISlider并t重载trackRectForBounds方法123- (CGRect)trackRectForBounds:(CGRect)bounds &#123; return CGRectMake(0, 0, CGRectGetWidth(self.frame), 5.0);&#125; iOS 11中隐藏section头尾的实现1234567891011121314- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 0.1f;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123; return 0.1f;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; return nil;&#125;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; return nil;&#125; 更改UITabBar &amp;&amp; UINavigationBar背景颜色12[[UITabBar appearance] setBarTintColor:[UIColor redColor]];[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]]; 更改UITabBar &amp;&amp; UINavigationBar字体颜色1234567//改变按钮navigationBar tintColor颜色self.navigationController.navigationBar.tintColor = [UIColor colorWithRed:102/255.0 green:102/255.0 blue:102/255.0 alpha:1.0];//改变tabbar 正常颜色，选中色NSDictionary *attributeNormal = @&#123;NSForegroundColorAttributeName:[UIColor grayColor]&#125;;[subVC.tabBarItem setTitleTextAttributes:attributeNormal forState:(UIControlStateNormal)];NSDictionary *attributeSelected = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;;[subVC.tabBarItem setTitleTextAttributes:attributeSelected forState: (UIControlStateSelected)];","categories":[],"tags":[]},{"title":"Bug收集","slug":"Bug收集","date":"2015-10-01T07:29:21.000Z","updated":"2020-05-17T08:15:49.970Z","comments":true,"path":"default/Bug收集/","link":"","permalink":"https://kysonyangs.github.io/default/Bug收集/","excerpt":"CocoaPods BugUse the $(inherited) flag1234567[!] The `MBPeopleBaseApp [Debug]` target overrides the `OTHER_LDFLAGS` build setting defined in `Pods/Target Support Files/Pods-MBPeopleBaseApp/Pods-MBPeopleBaseApp.debug.xcconfig&apos;. This can lead to problems with the CocoaPods installation - Use the `$(inherited)` flag, or - Remove the build settings from the target.[!] The `MBPeopleBaseApp [Release]` target overrides the `OTHER_LDFLAGS` build setting defined in `Pods/Target Support Files/Pods-MBPeopleBaseApp/Pods-MBPeopleBaseApp.release.xcconfig&apos;. This can lead to problems with the CocoaPods installation - Use the `$(inherited)` flag, or - Remove the build settings from the target. 解决方法：1Other link flag 添加 $(inherited) Xcode Bug自定义的代码片段存放位置1~/Library/Developer/Xcode/UserData/CodeSnippets Xcode 10 Multiple commands produce 报错解决1target &gt; Build phase &gt; Copy Bundle Resource/Compile Sources，删掉第三方库中重复的 README.txt，LICENSE，Info.plist 文件 工程文件乱序选中要整理的文件夹右键，点一下“Sort by Name”或者“Sort by Type”即可排序。 项目打不开 Failed to load project at ‘’ “,incompatible project version打开 project.pbxproj 文件，修改 objectVersion = 48; 不知道填什么往低了填，或者在自己想买找 Xcode 不高亮123cd Library/Developer/Xcode/DerivedDatarm -rf ./*重新打开XCODE 打开Playground提示打开失败，找不到合适的devices1231. Quit Xcode2. Delete the folder /Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices. For example, in Terminal: rm -rf ~/Library/Developer/CoreSimulator/Devices3. In Terminal: killall -9 com.apple.CoreSimulator.CoreSimulatorService (or just reboot). OR Add a iOS8.0Device 碰到Xib加载不出来，什么什么工程文件找不到，请看看引用有没有，没有的话加上就好了！用Xcode 7.3打开一个Xcode 8创建的工程，编译时报错：xxx.storyboard(或者xxx.xib) The document “null” required Xcode 8.0 or later.点击xxx.storyboard(或者xxx.xib)时，弹出如图所示提示框。解决方法是以源码的方式打开xxx.storyboard(或者xxx.xib)，然后删除&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;这一行代码，就OK了。 程序报错No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=armv7 armv7s)build 这个target的时候命令行报错。可以在 build setting 中，搜索bitcode,并吧 enable bitcode 设置为 NO. CopyPngFile Error 报错TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 删除灰色或红色的文件 Cannot find interface declaration for ‘xxxxViewController’, superclass of ‘xxxViewController’; did you mean ‘UIViewController’这是因为 父类总出现了交叉引用 前去父类查看 然后改掉就好了 pathForResource nil的情况，而项目命名有该资源可能没拷贝进bundle1Xcode -&gt; TARAGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 添加 ‘Could not instantiate class named xxx’比如 ‘Could not instantiate class named WKWebView’ 解决方法1Xcode -&gt; TARAGETS -&gt; General -&gt; Linked Frameworks and Librarier ，点击“+”号添加相应的系统库 webkit.framework 添加新字体， info.plist也配置好了，就是无效请检查 TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources 中是否添加此资源 其他添加资源后无效也可参考此条解决方案 ld: library not found for -lxxx:类似出现上面这种问题(我的问题出现在libWeChatSDK这个包) ld:library not found for -lXXX 的问题有可能是你的某个库的连接引用有问题, —–解决的办法就是在项目的target里,选中Link Binary With Libraries 里的.a或framework 取消再加入,就可以了 —–如果是拖拽进入工程的,那就删除,在拖一次. ld: symbol(s) not found for architecture x86_64依赖库未导入 tableview遇到这种报错failed to obtain a cell from its dataSource是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了 可能原因： xib的cell没有注册 内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识 UIView-Encapsulated-Layout-Width 错误修改约束优先级即可解决 Swift 创建控制器时自带xib加载在iOS8崩溃的问题项目中有部分跟随控制器一起创建出来的xib，在iOS8之外的系统运行正常，在iOS8下崩溃，找不到对应关系，一番网上搜索，终于找到解决办法1234567override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123; super.init(nibName: &quot;AddressViewController&quot;, bundle: nil)&#125;required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125; 原来在iOS8下，也需要给控制器的xib重写一下init 方法，只记得在自定义view的是时候用过，没想到这里也需要，特意加上，算是兼容手机系统 ios开发中，xib加载view，loadNibNamed方法奔溃原因之一xib中某一属性在代码中已删除，但在xib中没有解除关联 -[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject];","text":"CocoaPods BugUse the $(inherited) flag1234567[!] The `MBPeopleBaseApp [Debug]` target overrides the `OTHER_LDFLAGS` build setting defined in `Pods/Target Support Files/Pods-MBPeopleBaseApp/Pods-MBPeopleBaseApp.debug.xcconfig&apos;. This can lead to problems with the CocoaPods installation - Use the `$(inherited)` flag, or - Remove the build settings from the target.[!] The `MBPeopleBaseApp [Release]` target overrides the `OTHER_LDFLAGS` build setting defined in `Pods/Target Support Files/Pods-MBPeopleBaseApp/Pods-MBPeopleBaseApp.release.xcconfig&apos;. This can lead to problems with the CocoaPods installation - Use the `$(inherited)` flag, or - Remove the build settings from the target. 解决方法：1Other link flag 添加 $(inherited) Xcode Bug自定义的代码片段存放位置1~/Library/Developer/Xcode/UserData/CodeSnippets Xcode 10 Multiple commands produce 报错解决1target &gt; Build phase &gt; Copy Bundle Resource/Compile Sources，删掉第三方库中重复的 README.txt，LICENSE，Info.plist 文件 工程文件乱序选中要整理的文件夹右键，点一下“Sort by Name”或者“Sort by Type”即可排序。 项目打不开 Failed to load project at ‘’ “,incompatible project version打开 project.pbxproj 文件，修改 objectVersion = 48; 不知道填什么往低了填，或者在自己想买找 Xcode 不高亮123cd Library/Developer/Xcode/DerivedDatarm -rf ./*重新打开XCODE 打开Playground提示打开失败，找不到合适的devices1231. Quit Xcode2. Delete the folder /Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices. For example, in Terminal: rm -rf ~/Library/Developer/CoreSimulator/Devices3. In Terminal: killall -9 com.apple.CoreSimulator.CoreSimulatorService (or just reboot). OR Add a iOS8.0Device 碰到Xib加载不出来，什么什么工程文件找不到，请看看引用有没有，没有的话加上就好了！用Xcode 7.3打开一个Xcode 8创建的工程，编译时报错：xxx.storyboard(或者xxx.xib) The document “null” required Xcode 8.0 or later.点击xxx.storyboard(或者xxx.xib)时，弹出如图所示提示框。解决方法是以源码的方式打开xxx.storyboard(或者xxx.xib)，然后删除&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;这一行代码，就OK了。 程序报错No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=armv7 armv7s)build 这个target的时候命令行报错。可以在 build setting 中，搜索bitcode,并吧 enable bitcode 设置为 NO. CopyPngFile Error 报错TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 删除灰色或红色的文件 Cannot find interface declaration for ‘xxxxViewController’, superclass of ‘xxxViewController’; did you mean ‘UIViewController’这是因为 父类总出现了交叉引用 前去父类查看 然后改掉就好了 pathForResource nil的情况，而项目命名有该资源可能没拷贝进bundle1Xcode -&gt; TARAGETS -&gt; Build Phases -&gt; Copy Bundle Resources -&gt; 添加 ‘Could not instantiate class named xxx’比如 ‘Could not instantiate class named WKWebView’ 解决方法1Xcode -&gt; TARAGETS -&gt; General -&gt; Linked Frameworks and Librarier ，点击“+”号添加相应的系统库 webkit.framework 添加新字体， info.plist也配置好了，就是无效请检查 TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources 中是否添加此资源 其他添加资源后无效也可参考此条解决方案 ld: library not found for -lxxx:类似出现上面这种问题(我的问题出现在libWeChatSDK这个包) ld:library not found for -lXXX 的问题有可能是你的某个库的连接引用有问题, —–解决的办法就是在项目的target里,选中Link Binary With Libraries 里的.a或framework 取消再加入,就可以了 —–如果是拖拽进入工程的,那就删除,在拖一次. ld: symbol(s) not found for architecture x86_64依赖库未导入 tableview遇到这种报错failed to obtain a cell from its dataSource是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了 可能原因： xib的cell没有注册 内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识 UIView-Encapsulated-Layout-Width 错误修改约束优先级即可解决 Swift 创建控制器时自带xib加载在iOS8崩溃的问题项目中有部分跟随控制器一起创建出来的xib，在iOS8之外的系统运行正常，在iOS8下崩溃，找不到对应关系，一番网上搜索，终于找到解决办法1234567override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123; super.init(nibName: &quot;AddressViewController&quot;, bundle: nil)&#125;required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125; 原来在iOS8下，也需要给控制器的xib重写一下init 方法，只记得在自定义view的是时候用过，没想到这里也需要，特意加上，算是兼容手机系统 ios开发中，xib加载view，loadNibNamed方法奔溃原因之一xib中某一属性在代码中已删除，但在xib中没有解除关联 -[__NSArray0 addObject:]: unrecognized selector sent to instance 0x7f8a40d039a0造成原因是你使用[NSArray addObject],而不是[NSMutabeArray addObject]; 添加了一个All Exceptions 出现停在线程队列的情况，点继续运行仍然可以运行，将该断点删除或者将里面的All改成Object-C也可以！ios7下面用autolayout报错类似 *** Assertion failure in -[XXX layoutSublayersOfLayer:], /SourceCache/UIKit/UIKit-2935.138/UIView.解决方案：在布局之后 加上 [super layoutsubviews] [self lauoutifneed] 这两个方法。 there was an internal api error “—- xcode7，解决: bulid settings -&gt; packaging -&gt; product name 不要写中文。。。。 linker command failed with exit code 1 (use -v to see invocation) 检查是否重复引用，或者依赖引用.h 检查某个属性是否重复定义 检查是否 import 错误，把 .m 引入了 555 查看报错信息详情，一般都会提示，观察一下重复引用的两个文件名，分析即可","categories":[],"tags":[{"name":"Bugs","slug":"Bugs","permalink":"https://kysonyangs.github.io/tags/Bugs/"}]},{"title":"警告收集","slug":"警告收集","date":"2015-10-01T06:32:33.000Z","updated":"2020-05-17T08:16:09.543Z","comments":true,"path":"default/警告收集/","link":"","permalink":"https://kysonyangs.github.io/default/警告收集/","excerpt":"消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告）","text":"消除警告 使用cocoapods管理的第三方库的警告，直接在podfile文件里面加入 inhibit_all_warnings! 加入预编译指令：12345#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; //这里是会报警告的代码 UIAlertView *alert = [[UIAlertView alloc] initWithFrame:self.view.bounds];#pragma clang diagnostic pop 其中：-Wdeprecated-declarations 表示这里有废除，不支持的代码（UIAlertView在2.0-9.0,9.0以上弃用，所以会有警告） 那么，如何得到类似 -Wdeprecated-declarations 的标识符呢？如果下图的 Reveal in log有效，那么点击即可无效的话也别急，你可以如下图操作查看，如果没有就先编译/运行一下然后在下图红框位置找到警告的标识符 如果要删除一个.m里面的所有弃用的警告，如下图操作： 如果要删除项目中所有弃用的警告，如下图操作：当然，你也可以填入别的标识符~ 有的警告编译器会教你如何消除，而你只需要点一下即可！！！ 添加警告 直接 #warning &lt;#message#&gt; 在自己写的三方库提供的接口下写上适用范围 1- (void)test NS_DEPRECATED_IOS(2_0, 4_0); 也可以加点信息提示该方法弃用了 123- (void)test __attribute((deprecated(&quot;这个接口已弃用，请使用xxx！&quot;));或者- (void)test NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, &quot;这个接口已弃用，请使用xxx！&quot;); 碰到过的警告 Unused variable &#39;xxx&#39; - 没有使用 Deprecated: Push segues are deprecated in iOS 8.0 and later - iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:. - 一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示 &#39;sizeWithFont:constrainedToSize:lineBreakMode:&#39; is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context: - 方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法 Undeclared selector &#39;historyAction&#39; - 使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了 Code will never be executed - 代码永远也不会执行，检查代码吧 &quot;Two-stage rotation animation is deprecated. This application should use the smoother single-stage animation.&quot;原因：不应该将UITabBarControllier嵌入到UINavigationController中作为rootViewController，但是，我们的确想要这样做，只需要在将tabbar作为rootviewcontroller之前先设置tabBarController.selectedIndex= 0。 Expected a type : 两个类相互包含, 在其中一个使用@class Presenting view controllers on detached view controllers is discouraged &lt;SetViewController: 0x7fedb94f0f60&gt;.: 因为present出来的模态窗口，禁止再使用present 来弹出其它的子窗口 解决方法: 123AppDelegate *delegate = (AppDelegate *)[UIApplication sharedApplication].delegate;ViewController *with=[[ViewController alloc]init];[delegate.window.rootViewController presentViewController:with animated:YES completion:^&#123;&#125;]; This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.: 在主线程做的事情却放在了子线程,比如发送通知,刷新UI等 xcodewarning :no rule to process file xxx: 在build phases—&gt;compile sources 里面将对应的文件移除即可。如果有些还不行的话,xcode里面哪儿包含了这个，删。 ld: warning: directory not found for option &#39;-L/Users/xxxx/Desktop/Mos: 123选择 Build Settings 菜单,之后找到Build Settings ,在Search Paths 中有个Deug和Release点击之后有会相对的路径删除该路径,清理一下工程即可.Library Search Paths &amp; Framework Search Paths，删掉编译报warning的路径 Check dependencies Warning: Multiple build commands for output file: 在copy…查找重复资源 删除一个 警告类型","categories":[],"tags":[{"name":"Warnning","slug":"Warnning","permalink":"https://kysonyangs.github.io/tags/Warnning/"}]}]}